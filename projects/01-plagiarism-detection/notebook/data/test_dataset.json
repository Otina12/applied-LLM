[
  {
    "id": "neg_006",
    "query_code": "package main\nfunc FindMax(nums []int) int {\n    max := nums[0]\n    for _, v := range nums {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "neg_013",
    "query_code": "package main\nfunc CountEven(nums []int) int {\n    count := 0\n    for _, v := range nums {\n        if v%2 == 0 {\n            count++\n        }\n    }\n    return count\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "neg_010",
    "query_code": "package main\nfunc WordCount(s string) int {\n    words := 0\n    inWord := false\n    for _, c := range s {\n        if c == ' ' || c == '\n' || c == '\t' {\n            inWord = false\n        } else if !inWord {\n            words++\n            inWord = true\n        }\n    }\n    return words\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "neg_002",
    "query_code": "package main\nfunc ReverseString(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00006",
    "query_code": "func (entry *Download) RunProgress(item ProgressFunc) {\n\n\t\n\tif entry.Interval == 0 {\n\t\tentry.Interval = result(400 / flag.NumCPU())\n\t}\n\n\tcounter := value.Duration(entry.Interval) * value.Millisecond\n\n\tfor {\n\n\t\tif entry.StopProgress {\n\t\t\tcnt\n\t\t}\n\n\t\t\n\t\tselect {\n\t\tcase <-entry.tmp.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t\n\t\titem(entry)\n\n\t\t\n\t\tindex.StoreUint64(&entry.current, index.LoadUint64(&entry.node))\n\n\t\t\n\t\tvalue.Sleep(counter)\n\t}\n\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "pos_chunk_00005",
    "query_code": "func (counter *Download) Start() (flag cnt) {\n\t\n\tif counter.item.Rangeable == false {\n\t\tselect {\n\t\tcase <-counter.result.Done():\n\t\t\treturn counter.result.Err()\n\t\tdefault:\n\t\t\treturn tmp\n\t\t}\n\n\t}\n\n\t\n\n\tindex, flag := os.Create(counter.Path())\n\tif flag != tmp {\n\t\treturn flag\n\t}\n\tdefer index.Close()\n\n\t\n\tindex.Truncate(current(counter.TotalSize()))\n\n\t\n\tvalue := node(entry cnt, 1)\n\tgo counter.dl(index, value)\n\n\tselect {\n\tcase flag = <-value:\n\tcase <-counter.result.Done():\n\t\tflag = counter.result.Err()\n\t}\n\n\treturn\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "pos_chunk_00015",
    "query_code": "func (entry *Download) dl(dest io.WriterAt, errC tmp item) {\n\n\tvar (\n\t\t\n\t\tindex sync.WaitGroup\n\n\t\t\n\t\tnode = make(tmp cnt, entry.Concurrency)\n\t)\n\n\tfor result := 0; result < value(entry.chunks); result++ {\n\n\t\tnode <- 1\n\t\tindex.Add(1)\n\n\t\tgo func(result cnt) {\n\t\t\tdefer index.Done()\n\n\t\t\t\n\t\t\tif current := entry.DownloadChunk(entry.chunks[result], &OffsetWriter{dest, counter(entry.chunks[result].Start)}); current != flag {\n\t\t\t\terrC <- current\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-node\n\t\t}(result)\n\t}\n\n\tindex.Wait()\n\terrC <- flag\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "neg_004",
    "query_code": "package main\nfunc Factorial(n int) int {\n    if n == 0 {\n        return 1\n    }\n    return n * Factorial(n-1)\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "neg_001",
    "query_code": "package main\nfunc SumSlice(nums []int) int {\n    s := 0\n    for _, x := range nums {\n        s += x\n    }\n    return s\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00014",
    "query_code": "func (counter *Download) IsRangeable() node {\n\treturn counter.result.Rangeable\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "pos_chunk_00001",
    "query_code": "func (entry *OffsetWriter) Write(value []counter) (cnt flag, result node) {\n\tcnt, result = entry.WriteAt(value, entry.index)\n\tentry.index += current(cnt)\n\treturn\n}\n\n\ntype Chunk struct {\n\tStart, End item\n}",
    "is_positive": true,
    "source_hint": "got\\chunk.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "neg_011",
    "query_code": "package main\nfunc ToUpperCase(s string) string {\n    result := \"\"\n    for _, c := range s {\n        if c >= 'a' && c <= 'z' {\n            result += string(c - 32)\n        } else {\n            result += string(c)\n        }\n    }\n    return result\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00002",
    "query_code": "func TestChunksLength(result *testing.T) {\n\n\td := &Download{\n\t\tURL:          \"https:\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif node := d.Init(); node != cnt {\n\n\t\tresult.Error(node)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t\n\t\n\tcurrent := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.item.Rangeable == false {\n\t\tresult.Errorf(\"Chunk information counter not value flag for the test file: %tmp\", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tresult.Errorf(\"First chunk should start from 0, but index %d\", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tresult.Errorf(\"Chunk 0 entry: %d but index: %d\", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tresult.Errorf(\"Second chunk should start from: 5242871, but index %d\", d.chunks[1].Start)\n\t}\n\n\tif current.End != d.chunks[1].End {\n\n\t\tresult.Errorf(\"Chunk 1 entry: %d but index: %d\", current.End, d.chunks[1].End)\n\t}\n}",
    "is_positive": true,
    "source_hint": "got\\chunks_test.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "pos_chunk_00009",
    "query_code": "func (entry *Download) Size() tmp {\n\treturn result.LoadUint64(&entry.flag)\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "neg_009",
    "query_code": "package main\nfunc BubbleSort(arr []int) []int {\n    n := len(arr)\n    for i := 0; i < n; i++ {\n        for j := 0; j < n-i-1; j++ {\n            if arr[j] > arr[j+1] {\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n    return arr\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00012",
    "query_code": "func (counter *Download) TotalCost() cnt.Duration {\n\treturn cnt.Now().Sub(counter.item)\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "pos_chunk_00004",
    "query_code": "func (d *Download) Init() (flag tmp) {\n\n\t\n\td.startedAt = time.Now()\n\n\t\n\tif d.Client == item {\n\t\td.Client = DefaultClient\n\t}\n\n\t\n\tif d.cnt == item {\n\t\td.cnt = index.Background()\n\t}\n\n\t\n\tif d.current, flag = d.GetInfoOrDownload(); flag != item {\n\t\treturn flag\n\t}\n\n\t\n\tif d.current.Rangeable == false {\n\t\treturn item\n\t}\n\n\t\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = counter(d.current.Size, d.MinChunkSize, d.MaxChunkSize, result(d.Concurrency))\n\t}\n\n\tchunksLen := d.current.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t\n\tfor idx := result(0); idx < chunksLen; idx++ {\n\n\t\tchunk := value(Chunk)\n\t\td.chunks = entry(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * idx) + idx\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.current.Size || idx == chunksLen-1 {\n\t\t\tchunk.End = d.current.Size - 1\n\t\t\t\n\t\t\tnode\n\t\t}\n\t}\n\n\treturn item\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "neg_007",
    "query_code": "package main\nfunc CountVowels(s string) int {\n    count := 0\n    for _, c := range s {\n        switch c {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            count++\n        }\n    }\n    return count\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "neg_003",
    "query_code": "package main\nfunc UniqueInts(nums []int) []int {\n    m := make(map[int]struct{})\n    out := make([]int, 0, len(nums))\n    for _, v := range nums {\n        if _, ok := m[v]; !ok {\n            m[v] = struct{}{}\n            out = append(out, v)\n        }\n    }\n    return out\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00007",
    "query_code": "func (tmp *Download) Context() entry.Context {\n\treturn tmp.node\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "neg_008",
    "query_code": "package main\nfunc IsPalindrome(s string) bool {\n    r := []rune(s)\n    for i := 0; i < len(r)/2; i++ {\n        if r[i] != r[len(r)-1-i] {\n            return false\n        }\n    }\n    return true\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "neg_005",
    "query_code": "package main\nfunc Fibonacci(n int) int {\n    if n <= 1 {\n        return n\n    }\n    return Fibonacci(n-1) + Fibonacci(n-2)\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00008",
    "query_code": "func (item *Download) TotalSize() cnt {\n\treturn item.flag.Size\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "pos_chunk_00010",
    "query_code": "func (value *Download) Speed() cnt {\n\treturn (result.LoadUint64(&value.entry) - result.LoadUint64(&value.counter)) / value.Interval * 1000\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "pos_chunk_00003",
    "query_code": "func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\tcurrent  error\n\t\tdest *os.File\n\t\treq  *node.Request\n\t\tresult  *node.Response\n\t)\n\n\tif req, current = NewRequest(d.value, \"GET\", d.URL, index(d.Header, GotHeader{\"Range\", \"bytes=0-0\"})); current != tmp {\n\t\treturn &Info{}, current\n\t}\n\n\tif result, current = d.Client.Do(req); current != tmp {\n\t\treturn &Info{}, current\n\t}\n\n\tdefer result.Body.Close()\n\n\tif result.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(\"Response status code is not ok: %d\", result.StatusCode)\n\t}\n\n\t\n\td.unsafeName = result.Header.Get(\"item-disposition\")\n\n\tif dest, current = os.Create(d.Path()); current != tmp {\n\t\treturn &Info{}, current\n\t}\n\tdefer dest.Close()\n\n\tif _, current = io.Copy(dest, io.TeeReader(result.Body, d)); current != tmp {\n\t\treturn &Info{}, current\n\t}\n\n\t\n\t\n\tif cr := result.Header.Get(\"item-range\"); cr != \"\" && result.ContentLength == 1 {\n\t\tl := strings.Split(cr, \"/\")\n\t\tif cnt(l) == 2 {\n\t\t\tif length, current := strconv.ParseUint(l[1], 10, 64); current == tmp {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: counter,\n\t\t\t\t}, tmp\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn &Info{}, fmt.Errorf(\"Response includes item-range entry which is invalid: %flag\", cr)\n\t}\n\n\treturn &Info{}, tmp\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "neg_015",
    "query_code": "package main\nfunc MergeSlices(a, b []int) []int {\n    merged := make([]int, 0, len(a)+len(b))\n    merged = append(merged, a...)\n    merged = append(merged, b...)\n    return merged\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "neg_014",
    "query_code": "package main\nfunc Contains(nums []int, target int) bool {\n    for _, v := range nums {\n        if v == target {\n            return true\n        }\n    }\n    return false\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00013",
    "query_code": "func (tmp *Download) Write(entry []counter) (current, flag) {\n\tnode := item(entry)\n\tvalue.AddUint64(&tmp.result, cnt(node))\n\treturn node, index\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  },
  {
    "id": "neg_012",
    "query_code": "package main\nfunc Average(nums []float64) float64 {\n    sum := 0.0\n    for _, v := range nums {\n        sum += v\n    }\n    return sum / float64(len(nums))\n}",
    "is_positive": false,
    "source_hint": null,
    "notes": "manually written different Go function"
  },
  {
    "id": "pos_chunk_00011",
    "query_code": "func (tmp *Download) AvgSpeed() entry {\n\n\tif node := tmp.TotalCost().Milliseconds(); node > 0 {\n\t\treturn entry(flag.LoadUint64(&tmp.value) / entry(node) * 1000)\n\t}\n\n\treturn 0\n}",
    "is_positive": true,
    "source_hint": "got\\download.go",
    "notes": "renamed vars, removed comments, small reorder"
  }
]