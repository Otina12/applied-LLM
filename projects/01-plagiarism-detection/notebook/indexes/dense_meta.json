{
  "chunk_ids": [
    "chunk_00001",
    "chunk_00002",
    "chunk_00003",
    "chunk_00004",
    "chunk_00005",
    "chunk_00006",
    "chunk_00007",
    "chunk_00008",
    "chunk_00009",
    "chunk_00010",
    "chunk_00011",
    "chunk_00012",
    "chunk_00013",
    "chunk_00014",
    "chunk_00015",
    "chunk_00016",
    "chunk_00017",
    "chunk_00018",
    "chunk_00019",
    "chunk_00020",
    "chunk_00021",
    "chunk_00022",
    "chunk_00023",
    "chunk_00024",
    "chunk_00025",
    "chunk_00026",
    "chunk_00027",
    "chunk_00028",
    "chunk_00029",
    "chunk_00030",
    "chunk_00031",
    "chunk_00032",
    "chunk_00033",
    "chunk_00034",
    "chunk_00035",
    "chunk_00036",
    "chunk_00037",
    "chunk_00038",
    "chunk_00039",
    "chunk_00040",
    "chunk_00041",
    "chunk_00042",
    "chunk_00043",
    "chunk_00044",
    "chunk_00045",
    "chunk_00046",
    "chunk_00047",
    "chunk_00048",
    "chunk_00049",
    "chunk_00050",
    "chunk_00051",
    "chunk_00052",
    "chunk_00053",
    "chunk_00054",
    "chunk_00055",
    "chunk_00056",
    "chunk_00057",
    "chunk_00058",
    "chunk_00059",
    "chunk_00060",
    "chunk_00061",
    "chunk_00062",
    "chunk_00063",
    "chunk_00064",
    "chunk_00065",
    "chunk_00066",
    "chunk_00067",
    "chunk_00068",
    "chunk_00069",
    "chunk_00070",
    "chunk_00071",
    "chunk_00072",
    "chunk_00073",
    "chunk_00074",
    "chunk_00075",
    "chunk_00076",
    "chunk_00077",
    "chunk_00078",
    "chunk_00079",
    "chunk_00080",
    "chunk_00081",
    "chunk_00082",
    "chunk_00083",
    "chunk_00084",
    "chunk_00085",
    "chunk_00086",
    "chunk_00087",
    "chunk_00088",
    "chunk_00089",
    "chunk_00090",
    "chunk_00091",
    "chunk_00092",
    "chunk_00093",
    "chunk_00094",
    "chunk_00095",
    "chunk_00096",
    "chunk_00097",
    "chunk_00098",
    "chunk_00099",
    "chunk_00100",
    "chunk_00101",
    "chunk_00102",
    "chunk_00103",
    "chunk_00104",
    "chunk_00105",
    "chunk_00106",
    "chunk_00107",
    "chunk_00108",
    "chunk_00109",
    "chunk_00110",
    "chunk_00111",
    "chunk_00112",
    "chunk_00113",
    "chunk_00114",
    "chunk_00115",
    "chunk_00116",
    "chunk_00117",
    "chunk_00118",
    "chunk_00119",
    "chunk_00120",
    "chunk_00121",
    "chunk_00122",
    "chunk_00123",
    "chunk_00124",
    "chunk_00125",
    "chunk_00126",
    "chunk_00127",
    "chunk_00128",
    "chunk_00129",
    "chunk_00130",
    "chunk_00131",
    "chunk_00132",
    "chunk_00133",
    "chunk_00134",
    "chunk_00135",
    "chunk_00136",
    "chunk_00137",
    "chunk_00138",
    "chunk_00139",
    "chunk_00140",
    "chunk_00141",
    "chunk_00142",
    "chunk_00143",
    "chunk_00144",
    "chunk_00145",
    "chunk_00146",
    "chunk_00147",
    "chunk_00148",
    "chunk_00149",
    "chunk_00150",
    "chunk_00151",
    "chunk_00152",
    "chunk_00153",
    "chunk_00154",
    "chunk_00155",
    "chunk_00156",
    "chunk_00157",
    "chunk_00158",
    "chunk_00159",
    "chunk_00160",
    "chunk_00161",
    "chunk_00162",
    "chunk_00163",
    "chunk_00164",
    "chunk_00165",
    "chunk_00166",
    "chunk_00167",
    "chunk_00168",
    "chunk_00169",
    "chunk_00170",
    "chunk_00171",
    "chunk_00172",
    "chunk_00173",
    "chunk_00174",
    "chunk_00175",
    "chunk_00176",
    "chunk_00177",
    "chunk_00178",
    "chunk_00179",
    "chunk_00180",
    "chunk_00181",
    "chunk_00182",
    "chunk_00183",
    "chunk_00184",
    "chunk_00185",
    "chunk_00186",
    "chunk_00187",
    "chunk_00188",
    "chunk_00189",
    "chunk_00190",
    "chunk_00191",
    "chunk_00192",
    "chunk_00193",
    "chunk_00194",
    "chunk_00195",
    "chunk_00196",
    "chunk_00197",
    "chunk_00198",
    "chunk_00199",
    "chunk_00200",
    "chunk_00201",
    "chunk_00202",
    "chunk_00203",
    "chunk_00204",
    "chunk_00205",
    "chunk_00206",
    "chunk_00207",
    "chunk_00208",
    "chunk_00209",
    "chunk_00210",
    "chunk_00211",
    "chunk_00212",
    "chunk_00213",
    "chunk_00214",
    "chunk_00215",
    "chunk_00216",
    "chunk_00217",
    "chunk_00218",
    "chunk_00219",
    "chunk_00220",
    "chunk_00221",
    "chunk_00222",
    "chunk_00223",
    "chunk_00224",
    "chunk_00225",
    "chunk_00226",
    "chunk_00227",
    "chunk_00228",
    "chunk_00229",
    "chunk_00230",
    "chunk_00231",
    "chunk_00232",
    "chunk_00233",
    "chunk_00234",
    "chunk_00235",
    "chunk_00236",
    "chunk_00237",
    "chunk_00238",
    "chunk_00239",
    "chunk_00240",
    "chunk_00241",
    "chunk_00242",
    "chunk_00243",
    "chunk_00244",
    "chunk_00245",
    "chunk_00246",
    "chunk_00247",
    "chunk_00248",
    "chunk_00249",
    "chunk_00250",
    "chunk_00251",
    "chunk_00252",
    "chunk_00253",
    "chunk_00254",
    "chunk_00255",
    "chunk_00256",
    "chunk_00257",
    "chunk_00258",
    "chunk_00259",
    "chunk_00260",
    "chunk_00261",
    "chunk_00262",
    "chunk_00263",
    "chunk_00264",
    "chunk_00265",
    "chunk_00266",
    "chunk_00267",
    "chunk_00268",
    "chunk_00269",
    "chunk_00270",
    "chunk_00271",
    "chunk_00272",
    "chunk_00273",
    "chunk_00274",
    "chunk_00275",
    "chunk_00276",
    "chunk_00277",
    "chunk_00278",
    "chunk_00279",
    "chunk_00280",
    "chunk_00281",
    "chunk_00282",
    "chunk_00283",
    "chunk_00284",
    "chunk_00285",
    "chunk_00286",
    "chunk_00287",
    "chunk_00288",
    "chunk_00289",
    "chunk_00290",
    "chunk_00291",
    "chunk_00292",
    "chunk_00293",
    "chunk_00294",
    "chunk_00295",
    "chunk_00296",
    "chunk_00297",
    "chunk_00298",
    "chunk_00299",
    "chunk_00300",
    "chunk_00301",
    "chunk_00302",
    "chunk_00303",
    "chunk_00304",
    "chunk_00305",
    "chunk_00306",
    "chunk_00307",
    "chunk_00308",
    "chunk_00309",
    "chunk_00310",
    "chunk_00311",
    "chunk_00312",
    "chunk_00313",
    "chunk_00314",
    "chunk_00315",
    "chunk_00316",
    "chunk_00317",
    "chunk_00318",
    "chunk_00319",
    "chunk_00320",
    "chunk_00321",
    "chunk_00322",
    "chunk_00323",
    "chunk_00324",
    "chunk_00325",
    "chunk_00326",
    "chunk_00327",
    "chunk_00328",
    "chunk_00329",
    "chunk_00330",
    "chunk_00331",
    "chunk_00332",
    "chunk_00333",
    "chunk_00334",
    "chunk_00335",
    "chunk_00336",
    "chunk_00337",
    "chunk_00338",
    "chunk_00339",
    "chunk_00340",
    "chunk_00341",
    "chunk_00342",
    "chunk_00343",
    "chunk_00344",
    "chunk_00345",
    "chunk_00346",
    "chunk_00347",
    "chunk_00348",
    "chunk_00349",
    "chunk_00350",
    "chunk_00351",
    "chunk_00352",
    "chunk_00353",
    "chunk_00354",
    "chunk_00355",
    "chunk_00356",
    "chunk_00357",
    "chunk_00358",
    "chunk_00359",
    "chunk_00360",
    "chunk_00361",
    "chunk_00362",
    "chunk_00363",
    "chunk_00364",
    "chunk_00365",
    "chunk_00366",
    "chunk_00367",
    "chunk_00368",
    "chunk_00369",
    "chunk_00370",
    "chunk_00371"
  ],
  "repos": [
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "interpreter-go",
    "raft-go",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "got",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "interpreter-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "leetcode-go",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "proglog",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go",
    "raft-go"
  ],
  "paths": [
    "got\\chunk.go",
    "got\\chunks_test.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "got\\download_test.go",
    "interpreter-go\\main.go",
    "raft-go\\main.go",
    "got\\cmd\\got\\main.go",
    "got\\cmd\\got\\main.go",
    "got\\cmd\\got\\main.go",
    "got\\cmd\\got\\main.go",
    "got\\cmd\\got\\main.go",
    "got\\cmd\\got\\main.go",
    "got\\cmd\\got\\variables_unix.go",
    "got\\cmd\\got\\variables_windows.go",
    "got\\cmd\\wgot\\main.go",
    "got\\cmd\\wgot\\main.go",
    "got\\cmd\\wgot\\main.go",
    "got\\cmd\\wgot\\main.go",
    "got\\cmd\\wgot\\main.go",
    "got\\cmd\\wgot\\main.go",
    "got\\cmd\\wgot\\variables_unix.go",
    "got\\cmd\\wgot\\variables_windows.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast.go",
    "interpreter-go\\ast\\ast_test.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer.go",
    "interpreter-go\\lexer\\lexer_test.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\parser\\parser_test.go",
    "interpreter-go\\repl\\repl.go",
    "interpreter-go\\repl\\repl.go",
    "interpreter-go\\token\\token.go",
    "leetcode-go\\1029-vertical-order-traversal-of-a-binary-tree\\vertical-order-traversal-of-a-binary-tree.go",
    "leetcode-go\\1049-minimum-domino-rotations-for-equal-row\\minimum-domino-rotations-for-equal-row.go",
    "leetcode-go\\105-construct-binary-tree-from-preorder-and-inorder-traversal\\construct-binary-tree-from-preorder-and-inorder-traversal.go",
    "leetcode-go\\1055-pairs-of-songs-with-total-durations-divisible-by-60\\pairs-of-songs-with-total-durations-divisible-by-60.go",
    "leetcode-go\\107-binary-tree-level-order-traversal-ii\\binary-tree-level-order-traversal-ii.go",
    "leetcode-go\\1072-next-greater-node-in-linked-list\\next-greater-node-in-linked-list.go",
    "leetcode-go\\109-convert-sorted-list-to-binary-search-tree\\convert-sorted-list-to-binary-search-tree.go",
    "leetcode-go\\1092-maximum-difference-between-node-and-ancestor\\maximum-difference-between-node-and-ancestor.go",
    "leetcode-go\\1092-maximum-difference-between-node-and-ancestor\\maximum-difference-between-node-and-ancestor.go",
    "leetcode-go\\1121-partition-array-for-maximum-sum\\partition-array-for-maximum-sum.go",
    "leetcode-go\\1184-car-pooling\\car-pooling.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\error.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\error.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\api\\v1\\log_grpc.pb.go",
    "proglog\\ClientSideServiceDiscovery\\cmd\\proglog\\main.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent_test.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\agent\\agent_test.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\auth\\authorizer.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\auth\\authorizer.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\config\\files.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\config\\tls.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "proglog\\ClientSideServiceDiscovery\\internal\\discovery\\membership.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\mygob\\gob.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\myrpc\\rpc.go",
    "raft-go\\raft\\append_entries.go",
    "raft-go\\raft\\append_entries.go",
    "raft-go\\raft\\append_entries.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\config.go",
    "raft-go\\raft\\leader_election.go",
    "raft-go\\raft\\leader_election.go",
    "raft-go\\raft\\leader_election.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\persister.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go",
    "raft-go\\raft\\raft_test.go"
  ],
  "texts": [
    "func (dst *OffsetWriter) Write(b []byte) (n int, err error) {\n\tn, err = dst.WriteAt(b, dst.offset)\n\tdst.offset += int64(n)\n\treturn\n}\n\n// Chunk represents the partial content range\ntype Chunk struct {\n\tStart, End uint64\n}",
    "func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          \"https://proof.ovh.net/files/10Mb.dat\",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(\"Chunk information could not be retrieved for the test file: %s\", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(\"First chunk should start from 0, but got %d\", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(\"Chunk 0 expecting: %d but got: %d\", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(\"Second chunk should start from: 5242871, but got %d\", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(\"Chunk 1 expecting: %d but got: %d\", chunk1.End, d.chunks[1].End)\n\t}\n}",
    "func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, \"GET\", d.URL, append(d.Header, GotHeader{\"Range\", \"bytes=0-0\"})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(\"Response status code is not ok: %d\", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(\"content-disposition\")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(\"content-range\"); cr != \"\" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, \"/\")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don't just silently fail\n\t\treturn &Info{}, fmt.Errorf(\"Response includes content-range header which is invalid: %s\", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start",
    "func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init",
    "func (d *Download) Start() (err error) {\n\t// If the file was already downloaded during GetInfoOrDownload, then there will be no chunks\n\tif d.info.Rangeable == false {\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn d.ctx.Err()\n\t\tdefault:\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Otherwise there are always at least 2 chunks\n\n\tfile, err := os.Create(d.Path())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t// Allocate the file completely so that we can write concurrently\n\tfile.Truncate(int64(d.TotalSize()))\n\n\t// Download chunks.\n\terrs := make(chan error, 1)\n\tgo d.dl(file, errs)\n\n\tselect {\n\tcase err = <-errs:\n\tcase <-d.ctx.Done():\n\t\terr = d.ctx.Err()\n\t}\n\n\treturn\n}\n\n// RunProgress runs ProgressFunc based on Interval and updates lastSize.",
    "func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.",
    "func (d *Download) Context() context.Context {\n\treturn d.ctx\n}\n\n// TotalSize returns file total size (0 if unknown).",
    "func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.",
    "func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.",
    "func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.",
    "func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.",
    "func (d *Download) TotalCost() time.Duration {\n\treturn time.Now().Sub(d.startedAt)\n}\n\n// Write updates progress size.",
    "func (d *Download) Write(b []byte) (int, error) {\n\tn := len(b)\n\tatomic.AddUint64(&d.size, uint64(n))\n\treturn n, nil\n}\n\n// IsRangeable returns file server partial content support state.",
    "func (d *Download) IsRangeable() bool {\n\treturn d.info.Rangeable\n}\n\n// Download chunks",
    "func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts",
    "func (d *Download) Path() string {\n\n\t// Set the default path\n\tif d.path == \"\" {\n\n\t\td.path = GetFilename(d.URL) // default case\n\t\tif d.Dest != \"\" {\n\t\t\td.path = d.Dest\n\t\t} else if d.unsafeName != \"\" {\n\t\t\tif path := getNameFromHeader(d.unsafeName); path != \"\" {\n\t\t\t\td.path = path\n\t\t\t}\n\t\t}\n\t\td.path = filepath.Join(d.Dir, d.path)\n\t}\n\n\treturn d.path\n}\n\n// DownloadChunk downloads a file chunk.",
    "func (d *Download) DownloadChunk(c *Chunk, dest io.Writer) error {\n\n\tvar (\n\t\terr error\n\t\treq *http.Request\n\t\tres *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, \"GET\", d.URL, d.Header); err != nil {\n\t\treturn err\n\t}\n\n\tcontentRange := fmt.Sprintf(\"bytes=%d-%d\", c.Start, c.End)\n\treq.Header.Set(\"Range\", contentRange)\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify the length\n\tif res.ContentLength != int64(c.End-c.Start+1) {\n\t\treturn fmt.Errorf(\n\t\t\t\"Range request returned invalid Content-Length: %d however the range was: %s\",\n\t\t\tres.ContentLength, contentRange,\n\t\t)\n\t}\n\n\tdefer res.Body.Close()\n\n\t_, err = io.CopyN(dest, io.TeeReader(res.Body, d), res.ContentLength)\n\n\treturn err\n}\n\n// NewDownload returns new *Download with context.",
    "func NewDownload(ctx context.Context, URL, dest string) *Download {\n\treturn &Download{\n\t\tctx:    ctx,\n\t\tURL:    URL,\n\t\tDest:   dest,\n\t\tClient: DefaultClient,\n\t}\n}",
    "func getDefaultConcurrency() uint {\n\n\tc := uint(runtime.NumCPU() * 3)\n\n\t// Set default max concurrency to 20.\n\tif c > 20 {\n\t\tc = 20\n\t}\n\n\t// Set default min concurrency to 4.\n\tif c <= 2 {\n\t\tc = 4\n\t}\n\n\treturn c\n}",
    "func getDefaultChunkSize(totalSize, min, max, concurrency uint64) uint64 {\n\n\tcs := totalSize / concurrency\n\n\t// if chunk size >= 102400000 bytes set default to (ChunkSize / 2)\n\tif cs >= 102400000 {\n\t\tcs = cs / 2\n\t}\n\n\t// Set default min chunk size to 2m, or file size / 2\n\tif min == 0 {\n\n\t\tmin = 2097152\n\n\t\tif min >= totalSize {\n\t\t\tmin = totalSize / 2\n\t\t}\n\t}\n\n\t// if Chunk size < Min size set chunk size to min.\n\tif cs < min {\n\t\tcs = min\n\t}\n\n\t// Change ChunkSize if MaxChunkSize are set and ChunkSize > Max size\n\tif max > 0 && cs > max {\n\t\tcs = max\n\t}\n\n\t// When chunk size > total file size, divide chunk / 2\n\tif cs >= totalSize {\n\t\tcs = totalSize / 2\n\t}\n\n\treturn cs\n}",
    "func init() {\n\n\tvar err error\n\n\tokFileStat, err = os.Stat(\"go.mod\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
    "func TestGetInfoAndInit(t *testing.T) {\n\n\tt.Run(\"getInfoTest\", getInfoTest)\n\tt.Run(\"okInitTest\", okInitTest)\n\tt.Run(\"errInitTest\", errInitTest)\n\tt.Run(\"sendHeadersTest\", sendHeadersTest)\n}",
    "func TestDownloading(t *testing.T) {\n\n\tt.Run(\"downloadOkFileTest\", downloadOkFileTest)\n\tt.Run(\"downloadNotFoundTest\", downloadNotFoundTest)\n\tt.Run(\"downloadOkFileContentTest\", downloadOkFileContentTest)\n\tt.Run(\"downloadTimeoutContextTest\", downloadTimeoutContextTest)\n\tt.Run(\"downloadHeadNotSupported\", downloadHeadNotSupported)\n\tt.Run(\"downloadPartialContentNotSupportedTest\", downloadPartialContentNotSupportedTest)\n\tt.Run(\"getFilenameTest\", getFilenameTest)\n\tt.Run(\"coverTests\", coverTests)\n}",
    "func getInfoTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\tdl := got.NewDownload(context.Background(), httpt.URL+\"/ok_file\", tmpFile)\n\n\tinfo, err := dl.GetInfoOrDownload()\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif info.Rangeable == false {\n\t\tt.Error(\"rangeable should be true\")\n\t}\n\n\tif info.Size != uint64(okFileStat.Size()) {\n\t\tt.Errorf(\"Invalid file size, wants %d but got %d\", okFileStat.Size(), info.Size)\n\t}\n}",
    "func sendHeadersTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\tdl := got.NewDownload(context.Background(), httpt.URL+\"/header_values\", tmpFile)\n\tdl.Header = []got.GotHeader{\n\t\t{\n\t\t\tKey:   \"x-test-header\",\n\t\t\tValue: \"foobar\",\n\t\t},\n\t}\n\n\tinfo, err := dl.GetInfoOrDownload()\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif info.Rangeable == false {\n\t\tt.Error(\"rangeable should be true\")\n\t}\n\n\tif info.Size != uint64(okFileStat.Size()) {\n\t\tt.Errorf(\"Invalid file size, wants %d but got %d\", okFileStat.Size(), info.Size)\n\t}\n}",
    "func getFilenameTest(t *testing.T) {\n\n\ttmpDir := os.TempDir()\n\tdefer os.RemoveAll(tmpDir)\n\n\tdl := got.NewDownload(context.Background(), httpt.URL+\"/file_name\", \"\")\n\tdl.Dir = tmpDir\n\n\t_, err := dl.GetInfoOrDownload()\n\n\tif err != nil {\n\n\t\tt.Errorf(\"Unexpected error: \" + err.Error())\n\t}\n\n\tif dl.Path() != filepath.Join(tmpDir, \"go.mod\") {\n\t\tt.Errorf(\"Expecting file name to be: go.mod but got: \" + filepath.Join(tmpDir, \"go.mod\"))\n\t}\n\n}",
    "func okInitTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\tdl := &got.Download{\n\t\tURL:  httpt.URL + \"/ok_file\",\n\t\tDest: tmpFile,\n\t}\n\n\tif err := dl.Init(); err != nil {\n\t\tt.Error(err)\n\t}\n}",
    "func errInitTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\tdl := &got.Download{\n\t\tURL:  httpt.URL + \"/not_found\",\n\t\tDest: tmpFile,\n\t}\n\n\tif err := dl.Init(); err == nil {\n\t\tt.Error(\"Expecting error but got nil\")\n\t}\n}",
    "func downloadOkFileTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\tdl := &got.Download{\n\t\tURL:  httpt.URL + \"/ok_file\",\n\t\tDest: tmpFile,\n\t}\n\n\t// Init\n\tif err := dl.Init(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t// Check size\n\tif dl.TotalSize() != uint64(okFileStat.Size()) {\n\t\tt.Errorf(\"Invalid file size, wants %d but got %d\", okFileStat.Size(), dl.TotalSize())\n\t}\n\n\t// Start download\n\tif err := dl.Start(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tstat, err := os.Stat(tmpFile)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif okFileStat.Size() != stat.Size() {\n\t\tt.Errorf(\"Expecting size: %d, but got %d\", okFileStat.Size(), stat.Size())\n\t}\n}",
    "func downloadNotFoundTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\tdl := &got.Download{\n\t\tURL:  httpt.URL + \"/not_found\",\n\t\tDest: tmpFile,\n\t}\n\n\terr := dl.Init()\n\n\tif err == nil {\n\t\tt.Error(\"It should have an error\")\n\t\treturn\n\t}\n}",
    "func downloadOkFileContentTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\td := &got.Download{\n\t\tURL:       httpt.URL + \"/ok_file_with_range_delay\",\n\t\tDest:      tmpFile,\n\t\tChunkSize: 10,\n\t}\n\n\tif err := d.Init(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif err := d.Start(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tmod, err := ioutil.ReadFile(\"go.mod\")\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tdlFile, err := ioutil.ReadFile(tmpFile)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif string(mod) != string(dlFile) {\n\n\t\tfmt.Println(\"a\", string(mod))\n\t\tfmt.Println(\"b\", string(dlFile))\n\t\tt.Error(\"Corrupted file\")\n\t}\n\n}",
    "func downloadTimeoutContextTest(t *testing.T) {\n\n\ttmpFile, _ := ioutil.TempDir(\"\", \"\")\n\tdefer clean(tmpFile)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\n\td := got.NewDownload(ctx, httpt.URL+\"/ok_file_with_range_delay\", tmpFile)\n\td.ChunkSize = 2\n\n\tif err := d.Init(); err == nil {\n\t\tt.Error(\"Expecting context deadline\")\n\t}\n\n\tif err := d.Start(); err == nil {\n\t\tt.Error(\"Expecting context deadline\")\n\t}\n\n\td = got.NewDownload(ctx, httpt.URL+\"/ok_file_with_range_delay\", tmpFile)\n\n\t// just to cover request error.\n\tg := got.NewWithContext(ctx)\n\terr := g.Download(\"invalid://ok_file_with_range_delay\", tmpFile)\n\n\tif err == nil {\n\t\tt.Errorf(\"Expecting invalid scheme error\")\n\t}\n}",
    "func downloadHeadNotSupported(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\td := &got.Download{\n\t\tURL:  httpt.URL + \"/found_and_head_not_allowed\",\n\t\tDest: tmpFile,\n\t}\n\n\t// init\n\tif err := d.Init(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif d.TotalSize() != 0 {\n\t\tt.Error(\"Size should be 0\")\n\t}\n\n\tif d.IsRangeable() != false {\n\t\tt.Error(\"rangeable should be false\")\n\t}\n\n\td = &got.Download{\n\t\tURL:  httpt.URL + \"/found_and_head_not_allowed\",\n\t\tDest: \"/invalid/path\",\n\t}\n\n\tif err := d.Init(); err == nil {\n\t\tt.Error(\"Expecting invalid path error\")\n\t}\n}",
    "func downloadPartialContentNotSupportedTest(t *testing.T) {\n\n\ttmpFile := createTemp()\n\tdefer clean(tmpFile)\n\n\td := &got.Download{\n\t\tURL:  httpt.URL + \"/found_and_head_not_allowed\",\n\t\tDest: tmpFile,\n\t}\n\n\tif err := d.Init(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif d.TotalSize() != 0 {\n\t\tt.Errorf(\"Expect length to be 0, but got %d\", d.TotalSize())\n\t}\n\n\tif err := d.Start(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tstat, err := os.Stat(tmpFile)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif stat.Size() != 10 {\n\t\tt.Errorf(\"Invalid size: %d\", stat.Size())\n\t}\n}",
    "func coverTests(t *testing.T) {\n\n\t// Just for testing\n\tdestPath := createTemp()\n\tdefer clean(destPath)\n\n\t// cover default dest path.\n\t// cover progress func and methods\n\td := &got.Download{\n\t\tURL: httpt.URL + \"/ok_file_with_range_delay\",\n\t}\n\n\t// init\n\tif err := d.Init(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif d.Path() != got.DefaultFileName {\n\t\tt.Errorf(\"Expecting name to be: %s but got: %s\", got.DefaultFileName, d.Path())\n\t}\n\n\tgo d.RunProgress(func(d *got.Download) {\n\t\td.Size()\n\t\td.Speed()\n\t\td.AvgSpeed()\n\t\td.TotalCost()\n\t})\n}",
    "func ExampleDownload() {\n\n\t// Just for testing\n\tdestPath := createTemp()\n\tdefer clean(destPath)\n\n\tctx := context.Background()\n\n\tdl := got.NewDownload(ctx, testUrl, destPath)\n\n\t// Init\n\tif err := dl.Init(); err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\t// Start download\n\tif err := dl.Start(); err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(\"Done\")\n\n\t// Output: Done\n}",
    "func createTemp() string {\n\n\ttmp, err := ioutil.TempFile(\"\", \"\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer tmp.Close()\n\n\treturn tmp.Name()\n}",
    "func clean(tmpFile string) {\n\n\tos.Remove(tmpFile)\n}",
    "func main() {\n\tosUser, err := user.Current()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Hello %s! This is the Monkey programming language!\\n\", osUser.Username)\n\tfmt.Printf(\"Feel free to type in commands\\n\")\n\trepl.Start(os.Stdin, os.Stdout)\n}",
    "func main() {\n  //TIP <p>Press <shortcut actionId=\"ShowIntentionActions\"/> when your caret is at the underlined text\n  // to see how GoLand suggests fixing the warning.</p><p>Alternatively, if available, click the lightbulb to view possible fixes.</p>\n  s := \"gopher\"\n  fmt.Println(\"Hello and welcome, %s!\", s)\n\n  for i := 1; i <= 5; i++ {\n\t//TIP <p>To start your debugging session, right-click your code in the editor and select the Debug option.</p> <p>We have set one <icon src=\"AllIcons.Debugger.Db_set_breakpoint\"/> breakpoint\n\t// for you, but you can always add more by pressing <shortcut actionId=\"ToggleLineBreakpoint\"/>.</p>\n\tfmt.Println(\"i =\", 100/i)\n  }\n}",
    "func main() {\n\n\t// New context.\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tinterruptChan := make(chan os.Signal, 1)\n\n\tsignal.Notify(interruptChan, syscall.SIGINT, syscall.SIGKILL, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-interruptChan\n\t\tcancel()\n\t\tsignal.Stop(interruptChan)\n\t\tlog.Fatal(got.ErrDownloadAborted)\n\t}()\n\n\t// CLI app.\n\tapp := &cli.App{\n\t\tName:  \"Got\",\n\t\tUsage: \"The fastest http downloader.\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"output\",\n\t\t\t\tUsage:   \"Download `path`, if dir passed the path witll be `dir + output`.\",\n\t\t\t\tAliases: []string{\"o\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"dir\",\n\t\t\t\tUsage:   \"Save downloaded file to a `directory`.\",\n\t\t\t\tAliases: []string{\"d\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"file\",\n\t\t\t\tUsage:   \"Batch download from list of urls in a `file`.\",\n\t\t\t\tAliases: []string{\"bf\", \"f\"},\n\t\t\t},\n\t\t\t&cli.Uint64Flag{\n\t\t\t\tName:    \"size\",\n\t\t\t\tUsage:   \"Chunk size in `bytes` to split the file.\",\n\t\t\t\tAliases: []string{\"chunk\"},\n\t\t\t},\n\t\t\t&cli.UintFlag{\n\t\t\t\tName:    \"concurrency\",\n\t\t\t\tUsage:   \"Chunks that will be downloaded concurrently.\",\n\t\t\t\tAliases: []string{\"c\"},\n\t\t\t},\n\t\t\t&cli.StringSliceFlag{\n\t\t\t\tName:    \"header\",\n\t\t\t\tUsage:   `Set these HTTP-Headers on the requests. The format has to be: -H \"Key: Value\"`,\n\t\t\t\tAliases: []string{\"H\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"agent\",\n\t\t\t\tUsage:   `Set user agent for got HTTP requests.`,\n\t\t\t\tAliases: []string{\"u\"},\n\t\t\t},\n\t\t},\n\t\tVersion: version,\n\t\tAuthors: []*cli.Author{\n\t\t\t{\n\t\t\t\tName:  \"Mohamed Elbahja and Contributors\",\n\t\t\t\tEmail: \"bm9qdW5r@gmail.com\",\n\t\t\t},\n\t\t},\n\t\tAction: func(c *cli.Context) error {\n\t\t\treturn run(ctx, c)\n\t\t},\n\t}\n\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "func run(ctx context.Context, c *cli.Context) error {\n\n\tvar (\n\t\tg *got.Got           = got.NewWithContext(ctx)\n\t\tp *progress.Progress = new(progress.Progress)\n\t)\n\n\t// Set progress style.\n\tp.SetStyle(progressStyle)\n\n\t// Progress func.\n\tg.ProgressFunc = func(d *got.Download) {\n\n\t\t// 55 is just an estimation of the text showed with the progress.\n\t\t// it's working fine with $COLUMNS >= 47\n\t\tp.Width = getWidth() - 55\n\n\t\tperc, err := progress.GetPercentage(float64(d.Size()), float64(d.TotalSize()))\n\t\tif err != nil {\n\t\t\tperc = 100\n\t\t}\n\n\t\tvar bar string\n\t\tif getWidth() <= 46 {\n\t\t\tbar = \"\"\n\t\t} else {\n\t\t\tbar = r + color(p.GetBar(perc, 100)) + l\n\t\t}\n\n\t\tfmt.Printf(\n\t\t\t\" %6.2f%% %s %s/%s @ %s/s%s\\r\",\n\t\t\tperc,\n\t\t\tbar,\n\t\t\thumanize.Bytes(d.Size()),\n\t\t\thumanize.Bytes(d.TotalSize()),\n\t\t\thumanize.Bytes(d.Speed()),\n\t\t\tansi.ClearRight(),\n\t\t)\n\t}\n\n\tinfo, err := os.Stdin.Stat()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create dir if not exists.\n\tif c.String(\"dir\") != \"\" {\n\n\t\tif _, err := os.Stat(c.String(\"dir\")); os.IsNotExist(err) {\n\t\t\tos.MkdirAll(c.String(\"dir\"), os.ModePerm)\n\t\t}\n\t}\n\n\t// Set default user agent.\n\tif c.String(\"agent\") != \"\" {\n\t\tgot.UserAgent = c.String(\"agent\")\n\t}\n\n\t// Piped stdin\n\tif info.Mode()&os.ModeNamedPipe > 0 || info.Size() > 0 {\n\n\t\tif err := multiDownload(ctx, c, g, bufio.NewScanner(os.Stdin)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Batch file.\n\tif c.String(\"file\") != \"\" {\n\n\t\tfile, err := os.Open(c.String(\"file\"))\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := multiDownload(ctx, c, g, bufio.NewScanner(file)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.StringSlice(\"header\") != nil {\n\t\theader := c.StringSlice(\"header\")\n\n\t\tfor _, h := range header {\n\t\t\tsplit := strings.SplitN(h, \":\", 2)\n\t\t\tif len(split) == 1 {\n\t\t\t\treturn errors.New(\"malformatted header \" + h)\n\t\t\t}\n\t\t\tHeaderSlice = append(HeaderSlice, got.GotHeader{Key: split[0], Value: strings.TrimSpace(split[1])})\n\t\t}\n\t}\n\n\t// Download from args.\n\tfor _, url := range c.Args().Slice() {\n\n\t\tif err = download(ctx, c, g, url); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Print(ansi.ClearLine())\n\t\tfmt.Println(fmt.Sprintf(\"\u2714 %s\", url))\n\t}\n\n\treturn nil\n}",
    "func getWidth() int {\n\n\tif width, _, err := terminal.GetSize(0); err == nil && width > 0 {\n\t\treturn width\n\t}\n\n\treturn 80\n}",
    "func multiDownload(ctx context.Context, c *cli.Context, g *got.Got, scanner *bufio.Scanner) error {\n\n\tfor scanner.Scan() {\n\n\t\turl := strings.TrimSpace(scanner.Text())\n\n\t\tif url == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := download(ctx, c, g, url); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Print(ansi.ClearLine())\n\t\tfmt.Println(fmt.Sprintf(\"\u2714 %s\", url))\n\t}\n\n\treturn nil\n}",
    "func download(ctx context.Context, c *cli.Context, g *got.Got, url string) (err error) {\n\n\tif url, err = getURL(url); err != nil {\n\t\treturn err\n\t}\n\n\treturn g.Do(&got.Download{\n\t\tURL:         url,\n\t\tDir:         c.String(\"dir\"),\n\t\tDest:        c.String(\"output\"),\n\t\tHeader:      HeaderSlice,\n\t\tInterval:    150,\n\t\tChunkSize:   c.Uint64(\"size\"),\n\t\tConcurrency: c.Uint(\"concurrency\"),\n\t})\n}",
    "func getURL(URL string) (string, error) {\n\n\tu, err := url.Parse(URL)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Fallback to https by default.\n\tif u.Scheme == \"\" {\n\t\tu.Scheme = \"https\"\n\t}\n\n\treturn u.String(), nil\n}",
    "func color(content ...interface{}) string {\n\treturn ansi.Blue(fmt.Sprint(content...))\n}",
    "func color(content ...interface{}) string {\n\treturn fmt.Sprint(content...)\n}",
    "func main() {\n\n\t// New context.\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tinterruptChan := make(chan os.Signal, 1)\n\n\tsignal.Notify(interruptChan, syscall.SIGINT, syscall.SIGKILL, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-interruptChan\n\t\tcancel()\n\t\tsignal.Stop(interruptChan)\n\t\tlog.Fatal(got.ErrDownloadAborted)\n\t}()\n\n\t// CLI app.\n\tapp := &cli.App{\n\t\tName:  \"Got\",\n\t\tUsage: \"The fastest http downloader.\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"output\",\n\t\t\t\tUsage:   \"Download `path`, if dir passed the path witll be `dir + output`.\",\n\t\t\t\tAliases: []string{\"o\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"dir\",\n\t\t\t\tUsage:   \"Save downloaded file to a `directory`.\",\n\t\t\t\tAliases: []string{\"d\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"file\",\n\t\t\t\tUsage:   \"Batch download from list of urls in a `file`.\",\n\t\t\t\tAliases: []string{\"bf\", \"f\"},\n\t\t\t},\n\t\t\t&cli.Uint64Flag{\n\t\t\t\tName:    \"size\",\n\t\t\t\tUsage:   \"Chunk size in `bytes` to split the file.\",\n\t\t\t\tAliases: []string{\"chunk\"},\n\t\t\t},\n\t\t\t&cli.UintFlag{\n\t\t\t\tName:    \"concurrency\",\n\t\t\t\tUsage:   \"Chunks that will be downloaded concurrently.\",\n\t\t\t\tAliases: []string{\"c\"},\n\t\t\t},\n\t\t\t&cli.StringSliceFlag{\n\t\t\t\tName:    \"header\",\n\t\t\t\tUsage:   `Set these HTTP-Headers on the requests. The format has to be: -H \"Key: Value\"`,\n\t\t\t\tAliases: []string{\"H\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"agent\",\n\t\t\t\tUsage:   `Set user agent for got HTTP requests.`,\n\t\t\t\tAliases: []string{\"u\"},\n\t\t\t},\n\t\t},\n\t\tVersion: version,\n\t\tAuthors: []*cli.Author{\n\t\t\t{\n\t\t\t\tName:  \"Mohamed Elbahja and Contributors\",\n\t\t\t\tEmail: \"bm9qdW5r@gmail.com\",\n\t\t\t},\n\t\t},\n\t\tAction: func(c *cli.Context) error {\n\t\t\treturn run(ctx, c)\n\t\t},\n\t}\n\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "func run(ctx context.Context, c *cli.Context) error {\n\n\tvar (\n\t\tg *got.Got           = got.NewWithContext(ctx)\n\t\tp *progress.Progress = new(progress.Progress)\n\t)\n\n\t// Set progress style.\n\tp.SetStyle(progressStyle)\n\n\t// Progress func.\n\tg.ProgressFunc = func(d *got.Download) {\n\n\t\t// 55 is just an estimation of the text showed with the progress.\n\t\t// it's working fine with $COLUMNS >= 47\n\t\tp.Width = getWidth() - 55\n\n\t\tperc, err := progress.GetPercentage(float64(d.Size()), float64(d.TotalSize()))\n\t\tif err != nil {\n\t\t\tperc = 100\n\t\t}\n\n\t\tvar bar string\n\t\tif getWidth() <= 46 {\n\t\t\tbar = \"\"\n\t\t} else {\n\t\t\tbar = r + color(p.GetBar(perc, 100)) + l\n\t\t}\n\n\t\tfmt.Printf(\n\t\t\t\" %6.2f%% %s %s/%s @ %s/s%s\\r\",\n\t\t\tperc,\n\t\t\tbar,\n\t\t\thumanize.Bytes(d.Size()),\n\t\t\thumanize.Bytes(d.TotalSize()),\n\t\t\thumanize.Bytes(d.Speed()),\n\t\t\tansi.ClearRight(),\n\t\t)\n\t}\n\n\tinfo, err := os.Stdin.Stat()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create dir if not exists.\n\tif c.String(\"dir\") != \"\" {\n\n\t\tif _, err := os.Stat(c.String(\"dir\")); os.IsNotExist(err) {\n\t\t\tos.MkdirAll(c.String(\"dir\"), os.ModePerm)\n\t\t}\n\t}\n\n\t// Set default user agent.\n\tif c.String(\"agent\") != \"\" {\n\t\tgot.UserAgent = c.String(\"agent\")\n\t}\n\n\t// Piped stdin\n\tif info.Mode()&os.ModeNamedPipe > 0 || info.Size() > 0 {\n\n\t\tif err := multiDownload(ctx, c, g, bufio.NewScanner(os.Stdin)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Batch file.\n\tif c.String(\"file\") != \"\" {\n\n\t\tfile, err := os.Open(c.String(\"file\"))\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := multiDownload(ctx, c, g, bufio.NewScanner(file)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.StringSlice(\"header\") != nil {\n\t\theader := c.StringSlice(\"header\")\n\n\t\tfor _, h := range header {\n\t\t\tsplit := strings.SplitN(h, \":\", 2)\n\t\t\tif len(split) == 1 {\n\t\t\t\treturn errors.New(\"malformatted header \" + h)\n\t\t\t}\n\t\t\tHeaderSlice = append(HeaderSlice, got.GotHeader{Key: split[0], Value: strings.TrimSpace(split[1])})\n\t\t}\n\t}\n\n\t// Download from args.\n\tfor _, url := range c.Args().Slice() {\n\n\t\tif err = download(ctx, c, g, url); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Print(ansi.ClearLine())\n\t\tfmt.Println(fmt.Sprintf(\"\u2714 %s\", url))\n\t}\n\n\treturn nil\n}",
    "func getWidth() int {\n\n\tif width, _, err := terminal.GetSize(0); err == nil && width > 0 {\n\t\treturn width\n\t}\n\n\treturn 80\n}",
    "func multiDownload(ctx context.Context, c *cli.Context, g *got.Got, scanner *bufio.Scanner) error {\n\n\tfor scanner.Scan() {\n\n\t\turl := strings.TrimSpace(scanner.Text())\n\n\t\tif url == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := download(ctx, c, g, url); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Print(ansi.ClearLine())\n\t\tfmt.Println(fmt.Sprintf(\"\u2714 %s\", url))\n\t}\n\n\treturn nil\n}",
    "func download(ctx context.Context, c *cli.Context, g *got.Got, url string) (err error) {\n\n\tif url, err = getURL(url); err != nil {\n\t\treturn err\n\t}\n\n\treturn g.Do(&got.Download{\n\t\tURL:         url,\n\t\tDir:         c.String(\"dir\"),\n\t\tDest:        c.String(\"output\"),\n\t\tHeader:      HeaderSlice,\n\t\tInterval:    150,\n\t\tChunkSize:   c.Uint64(\"size\"),\n\t\tConcurrency: c.Uint(\"concurrency\"),\n\t})\n}",
    "func getURL(URL string) (string, error) {\n\n\tu, err := url.Parse(URL)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Fallback to https by default.\n\tif u.Scheme == \"\" {\n\t\tu.Scheme = \"https\"\n\t}\n\n\treturn u.String(), nil\n}",
    "func color(content ...interface{}) string {\n\treturn ansi.Blue(fmt.Sprint(content...))\n}",
    "func color(content ...interface{}) string {\n\treturn fmt.Sprint(content...)\n}",
    "func (p *Program) TokenLiteral() string {\n\tif len(p.Statements) > 0 {\n\t\treturn p.Statements[0].TokenLiteral()\n\t} else {\n\t\treturn \"\"\n\t}\n}",
    "func (p *Program) String() string {\n\tvar out bytes.Buffer\n\tfor _, s := range p.Statements {\n\t\tout.WriteString(s.String())\n\t}\n\n\treturn out.String()\n}\n\n// statement definitions\n\ntype LetStatement struct {\n\tToken token.Token\n\tName  *Identifier\n\tValue Expression\n}",
    "func (ls *LetStatement) statementNode() {}",
    "func (ls *LetStatement) TokenLiteral() string {\n\treturn ls.Token.Literal\n}",
    "func (ls *LetStatement) String() string {\n\tvar out bytes.Buffer\n\tout.WriteString(ls.TokenLiteral() + \" \")\n\tout.WriteString(ls.Name.String())\n\tout.WriteString(\" = \")\n\tif ls.Value != nil {\n\t\tout.WriteString(ls.Value.String())\n\t}\n\tout.WriteString(\";\")\n\treturn out.String()\n}\n\ntype ReturnStatement struct {\n\tToken       token.Token\n\tReturnValue Expression\n}",
    "func (rs *ReturnStatement) statementNode() {}",
    "func (rs *ReturnStatement) TokenLiteral() string {\n\treturn rs.Token.Literal\n}",
    "func (rs *ReturnStatement) String() string {\n\tvar out bytes.Buffer\n\tout.WriteString(rs.TokenLiteral() + \" \")\n\tif rs.ReturnValue != nil {\n\t\tout.WriteString(rs.ReturnValue.String())\n\t}\n\tout.WriteString(\";\")\n\treturn out.String()\n}\n\ntype ExpressionStatement struct {\n\tToken      token.Token\n\tExpression Expression\n}",
    "func (es *ExpressionStatement) statementNode() {}",
    "func (es *ExpressionStatement) TokenLiteral() string {\n\treturn es.Token.Literal\n}",
    "func (es *ExpressionStatement) String() string {\n\tif es.Expression != nil {\n\t\treturn es.Expression.String()\n\t}\n\treturn \"\"\n}\n\ntype Identifier struct {\n\tToken token.Token\n\tValue string\n}",
    "func (i *Identifier) expressionNode() {}",
    "func (i *Identifier) TokenLiteral() string {\n\treturn i.Token.Literal\n}",
    "func (i *Identifier) String() string {\n\treturn i.Value\n}\n\ntype IntegerLiteral struct {\n\tToken token.Token\n\tValue int64\n}",
    "func (il *IntegerLiteral) expressionNode() {}",
    "func (il *IntegerLiteral) TokenLiteral() string {\n\treturn il.Token.Literal\n}",
    "func (il *IntegerLiteral) String() string {\n\treturn il.Token.Literal\n}\n\ntype PrefixExpression struct {\n\tToken    token.Token\n\tOperator string\n\tRight    Expression\n}",
    "func (pe *PrefixExpression) expressionNode() {}",
    "func (pe *PrefixExpression) TokenLiteral() string {\n\treturn pe.Token.Literal\n}",
    "func (pe *PrefixExpression) String() string {\n\tvar out bytes.Buffer\n\tout.WriteString(\"(\")\n\tout.WriteString(pe.Operator)\n\tout.WriteString(pe.Right.String())\n\tout.WriteString(\")\")\n\treturn out.String()\n}\n\ntype InfixExpression struct {\n\tToken    token.Token\n\tLeft     Expression\n\tOperator string\n\tRight    Expression\n}",
    "func (ie *InfixExpression) expressionNode() {}",
    "func (ie *InfixExpression) TokenLiteral() string {\n\treturn ie.Token.Literal\n}",
    "func (ie *InfixExpression) String() string {\n\tvar out bytes.Buffer\n\tout.WriteString(\"(\")\n\tout.WriteString(ie.Left.String())\n\tout.WriteString(\" \" + ie.Operator + \" \")\n\tout.WriteString(ie.Right.String())\n\tout.WriteString(\")\")\n\treturn out.String()\n}\n\ntype Boolean struct {\n\tToken token.Token\n\tValue bool\n}",
    "func (b *Boolean) expressionNode() {}",
    "func (b *Boolean) TokenLiteral() string {\n\treturn b.Token.Literal\n}",
    "func (b *Boolean) String() string {\n\treturn b.Token.Literal\n}\n\ntype IfExpression struct {\n\tToken     token.Token // The 'if' token\n\tCondition Expression\n\tIfBody    *BlockStatement\n\tElseBody  *BlockStatement\n}",
    "func (ie *IfExpression) expressionNode() {}",
    "func (ie *IfExpression) TokenLiteral() string {\n\treturn ie.Token.Literal\n}",
    "func (ie *IfExpression) String() string {\n\tvar out bytes.Buffer\n\n\tout.WriteString(\"if \")\n\tout.WriteString(ie.Condition.String())\n\tout.WriteString(\" { \")\n\tout.WriteString(ie.IfBody.String())\n\tout.WriteString(\" }\")\n\n\tif ie.ElseBody != nil {\n\t\tout.WriteString(\" else\")\n\t\tout.WriteString(\" { \")\n\t\tout.WriteString(ie.ElseBody.String())\n\t\tout.WriteString(\" }\")\n\t}\n\n\treturn out.String()\n}\n\ntype BlockStatement struct {\n\tToken      token.Token // the { token\n\tStatements []Statement\n}",
    "func (bs *BlockStatement) statementNode() {}",
    "func (bs *BlockStatement) TokenLiteral() string {\n\treturn bs.Token.Literal\n}",
    "func (bs *BlockStatement) String() string {\n\tvar out bytes.Buffer\n\n\tfor _, s := range bs.Statements {\n\t\tout.WriteString(s.String())\n\t}\n\treturn out.String()\n}\n\ntype FunctionLiteral struct {\n\tToken      token.Token // The 'fn' token\n\tParameters []*Identifier\n\tBody       *BlockStatement\n}",
    "func (fl *FunctionLiteral) expressionNode() {}",
    "func (fl *FunctionLiteral) TokenLiteral() string {\n\treturn fl.Token.Literal\n}",
    "func (fl *FunctionLiteral) String() string {\n\tparams := []string{}\n\tfor _, p := range fl.Parameters {\n\t\tparams = append(params, p.String())\n\t}\n\n\tvar out bytes.Buffer\n\n\tout.WriteString(\"fn\")\n\tout.WriteString(\"(\")\n\tout.WriteString(strings.Join(params, \", \"))\n\tout.WriteString(\")\")\n\tout.WriteString(\" { \")\n\tout.WriteString(fl.Body.String())\n\tout.WriteString(\" }\")\n\n\treturn out.String()\n}\n\ntype FunctionCallExpression struct {\n\tToken     token.Token // The '(' token\n\tFunction  Expression  // Identifier (function name) or FunctionLiteral (whole function)\n\tArguments []Expression\n}",
    "func (fce *FunctionCallExpression) expressionNode() {}",
    "func (fce *FunctionCallExpression) TokenLiteral() string {\n\treturn fce.Token.Literal\n}",
    "func (fce *FunctionCallExpression) String() string {\n\tvar args []string\n\tfor _, a := range fce.Arguments {\n\t\targs = append(args, a.String())\n\t}\n\n\tvar out bytes.Buffer\n\n\tout.WriteString(fce.Function.String())\n\tout.WriteString(\"(\")\n\tout.WriteString(strings.Join(args, \", \"))\n\tout.WriteString(\")\")\n\n\treturn out.String()\n}",
    "func TestString(t *testing.T) {\n\tprogram := &Program{\n\t\tStatements: []Statement{\n\t\t\t&LetStatement{\n\t\t\t\tToken: token.Token{Type: token.Let, Literal: \"let\"},\n\t\t\t\tName: &Identifier{\n\t\t\t\t\tToken: token.Token{Type: token.Identifier, Literal: \"myVar\"},\n\t\t\t\t\tValue: \"myVar\",\n\t\t\t\t},\n\t\t\t\tValue: &Identifier{\n\t\t\t\t\tToken: token.Token{Type: token.Identifier, Literal: \"anotherVar\"},\n\t\t\t\t\tValue: \"anotherVar\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif program.String() != \"let myVar = anotherVar;\" {\n\t\tt.Errorf(\"program.String() wrong. got=%q\", program.String())\n\t}\n}",
    "func New(input string) *Lexer {\n\tl := &Lexer{input: input}\n\tl.readChar()\n\treturn l\n}",
    "func (l *Lexer) NextToken() token.Token {\n\tvar tok token.Token\n\n\tl.skipSpaces()\n\n\tswitch l.ch {\n\tcase '=':\n\t\tif l.peekChar() == '=' {\n\t\t\tl.readChar()\n\t\t\ttok = token.Token{Type: token.Equal, Literal: \"==\"}\n\t\t} else {\n\t\t\ttok = newToken(token.Assign, l.ch)\n\t\t}\n\tcase '+':\n\t\ttok = newToken(token.Plus, l.ch)\n\tcase '-':\n\t\ttok = newToken(token.Minus, l.ch)\n\tcase '!':\n\t\tif l.peekChar() == '=' {\n\t\t\tl.readChar()\n\t\t\ttok = token.Token{Type: token.NotEqual, Literal: \"!=\"}\n\t\t} else {\n\t\t\ttok = newToken(token.Bang, l.ch)\n\t\t}\n\tcase '*':\n\t\ttok = newToken(token.Asterisk, l.ch)\n\tcase '/':\n\t\ttok = newToken(token.Slash, l.ch)\n\tcase '<':\n\t\ttok = newToken(token.LessThan, l.ch)\n\tcase '>':\n\t\ttok = newToken(token.GreaterThan, l.ch)\n\tcase ',':\n\t\ttok = newToken(token.Comma, l.ch)\n\tcase ';':\n\t\ttok = newToken(token.Semicolon, l.ch)\n\tcase ':':\n\t\ttok = newToken(token.Colon, l.ch)\n\tcase '(':\n\t\ttok = newToken(token.LeftParen, l.ch)\n\tcase ')':\n\t\ttok = newToken(token.RightParen, l.ch)\n\tcase '{':\n\t\ttok = newToken(token.LeftBrace, l.ch)\n\tcase '}':\n\t\ttok = newToken(token.RightBrace, l.ch)\n\tcase '[':\n\t\ttok = newToken(token.LeftBracket, l.ch)\n\tcase ']':\n\t\ttok = newToken(token.RightBracket, l.ch)\n\tcase '\"':\n\t\ttok.Type = token.String\n\t\ttok.Literal = l.readString()\n\tcase 0:\n\t\ttok.Literal = \"\"\n\t\ttok.Type = token.EOF\n\tdefault:\n\t\tif isLetter(l.ch) {\n\t\t\tident := l.readIdentifier()\n\t\t\ttok.Type = token.LookupIdentifier(ident)\n\t\t\ttok.Literal = ident\n\t\t\treturn tok\n\t\t} else if isDigit(l.ch) {\n\t\t\ttok.Type = token.Int\n\t\t\ttok.Literal = l.readNumber()\n\t\t\treturn tok\n\t\t} else {\n\t\t\ttok = newToken(token.Illegal, l.ch)\n\t\t}\n\t}\n\n\tl.readChar()\n\treturn tok\n}",
    "func newToken(tokenType token.TokenType, ch byte) token.Token {\n\treturn token.Token{Type: tokenType, Literal: string(ch)}\n}",
    "func isLetter(ch byte) bool {\n\treturn 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_'\n}",
    "func isDigit(ch byte) bool {\n\treturn '0' <= ch && ch <= '9'\n}",
    "func (l *Lexer) readChar() {\n\tif l.readPosition >= len(l.input) {\n\t\tl.ch = 0\n\t} else {\n\t\tl.ch = l.input[l.readPosition]\n\t}\n\tl.position = l.readPosition\n\tl.readPosition += 1\n}",
    "func (l *Lexer) readIdentifier() string {\n\tposition := l.position\n\n\tfor isLetter(l.ch) {\n\t\tl.readChar()\n\t}\n\n\treturn l.input[position:l.position]\n}",
    "func (l *Lexer) readNumber() string {\n\tpos := l.position\n\tfor isDigit(l.ch) {\n\t\tl.readChar()\n\t}\n\treturn l.input[pos:l.position]\n}",
    "func (l *Lexer) readString() string {\n\tpos := l.position + 1\n\tfor {\n\t\tl.readChar()\n\t\tif l.ch == '\"' || l.ch == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn l.input[pos:l.position]\n}",
    "func (l *Lexer) skipSpaces() {\n\tfor l.ch == ' ' || l.ch == '\\t' || l.ch == '\\n' || l.ch == '\\r' {\n\t\tl.readChar()\n\t}\n}",
    "func (l *Lexer) peekChar() byte {\n\tif l.readPosition >= len(l.input) {\n\t\treturn 0\n\t} else {\n\t\treturn l.input[l.readPosition]\n\t}\n}",
    "func TestNextToken(t *testing.T) {\n\tinput := `\n\t\tlet two = 2;\n\t\tlet three = 3;\n\n\t\tlet add = fn(x, y) {\n\t\t\tx + y;\n\t\t};\n\n\t\tlet result = add(two, three);\n\n\t\t3 == 3\n\t\t4 < 5\n\t\t6 > 700\n\t\t8 != 9\n\n\t\tlet fiveStr = \"five\";\n\t`\n\n\ttests := []tokenStruct{\n\t\t{token.Let, \"let\"},\n\t\t{token.Identifier, \"two\"},\n\t\t{token.Assign, \"=\"},\n\t\t{token.Int, \"2\"},\n\t\t{token.Semicolon, \";\"},\n\t\t{token.Let, \"let\"},\n\t\t{token.Identifier, \"three\"},\n\t\t{token.Assign, \"=\"},\n\t\t{token.Int, \"3\"},\n\t\t{token.Semicolon, \";\"},\n\t\t{token.Let, \"let\"},\n\t\t{token.Identifier, \"add\"},\n\t\t{token.Assign, \"=\"},\n\t\t{token.Function, \"fn\"},\n\t\t{token.LeftParen, \"(\"},\n\t\t{token.Identifier, \"x\"},\n\t\t{token.Comma, \",\"},\n\t\t{token.Identifier, \"y\"},\n\t\t{token.RightParen, \")\"},\n\t\t{token.LeftBrace, \"{\"},\n\t\t{token.Identifier, \"x\"},\n\t\t{token.Plus, \"+\"},\n\t\t{token.Identifier, \"y\"},\n\t\t{token.Semicolon, \";\"},\n\t\t{token.RightBrace, \"}\"},\n\t\t{token.Semicolon, \";\"},\n\t\t{token.Let, \"let\"},\n\t\t{token.Identifier, \"result\"},\n\t\t{token.Assign, \"=\"},\n\t\t{token.Identifier, \"add\"},\n\t\t{token.LeftParen, \"(\"},\n\t\t{token.Identifier, \"two\"},\n\t\t{token.Comma, \",\"},\n\t\t{token.Identifier, \"three\"},\n\t\t{token.RightParen, \")\"},\n\t\t{token.Semicolon, \";\"},\n\t\t{token.Int, \"3\"},\n\t\t{token.Equal, \"==\"},\n\t\t{token.Int, \"3\"},\n\t\t{token.Int, \"4\"},\n\t\t{token.LessThan, \"<\"},\n\t\t{token.Int, \"5\"},\n\t\t{token.Int, \"6\"},\n\t\t{token.GreaterThan, \">\"},\n\t\t{token.Int, \"700\"},\n\t\t{token.Int, \"8\"},\n\t\t{token.NotEqual, \"!=\"},\n\t\t{token.Int, \"9\"},\n\t\t{token.Let, \"let\"},\n\t\t{token.Identifier, \"fiveStr\"},\n\t\t{token.Assign, \"=\"},\n\t\t{token.String, \"five\"},\n\t\t{token.Semicolon, \";\"},\n\t\t{token.EOF, \"\"},\n\t}\n\n\tl := New(input)\n\n\tfor i, testTok := range tests {\n\t\ttok := l.NextToken()\n\n\t\tif tok.Type != testTok.expectedType {\n\t\t\tt.Fatalf(\"tests[%d] - tokentype wrong. expected=%q, got=%q\",\n\t\t\t\ti, testTok.expectedType, tok.Type)\n\t\t}\n\t\tif tok.Literal != testTok.expectedLiteral {\n\t\t\tt.Fatalf(\"tests[%d] - literal wrong. expected=%q, got=%q\",\n\t\t\t\ti, testTok.expectedLiteral, tok.Literal)\n\t\t}\n\t}\n}",
    "func New(l *lexer.Lexer) *Parser {\n\tp := &Parser{\n\t\tl:      l,\n\t\terrors: []string{},\n\t}\n\n\tp.nextToken()\n\tp.nextToken()\n\n\tp.prefixParseFns = make(map[token.TokenType]prefixParseFn)\n\tp.registerPrefix(token.Identifier, p.parseIdentifier)\n\tp.registerPrefix(token.Int, p.parseIntegerLiteral)\n\tp.registerPrefix(token.Bang, p.parsePrefixExpression)\n\tp.registerPrefix(token.Minus, p.parsePrefixExpression)\n\tp.registerPrefix(token.True, p.parseBoolean)\n\tp.registerPrefix(token.False, p.parseBoolean)\n\tp.registerPrefix(token.LeftParen, p.parseGroupedExpression)\n\tp.registerPrefix(token.If, p.parseIfExpression)\n\tp.registerPrefix(token.Function, p.parseFunctionLiteral)\n\n\tp.infixParseFns = make(map[token.TokenType]infixParseFn)\n\tp.registerInfix(token.Plus, p.parseInfixExpression)\n\tp.registerInfix(token.Minus, p.parseInfixExpression)\n\tp.registerInfix(token.Slash, p.parseInfixExpression)\n\tp.registerInfix(token.Asterisk, p.parseInfixExpression)\n\tp.registerInfix(token.Equal, p.parseInfixExpression)\n\tp.registerInfix(token.NotEqual, p.parseInfixExpression)\n\tp.registerInfix(token.LessThan, p.parseInfixExpression)\n\tp.registerInfix(token.GreaterThan, p.parseInfixExpression)\n\tp.registerInfix(token.LeftParen, p.parseFunctionCallExpression)\n\n\treturn p\n}",
    "func (p *Parser) Errors() []string {\n\treturn p.errors\n}",
    "func (p *Parser) peekError(expected token.TokenType) {\n\tmsg := fmt.Sprintf(\"expected next token to be %s, got %s instead\", expected, p.peekToken.Type)\n\tp.errors = append(p.errors, msg)\n}",
    "func (p *Parser) registerPrefix(tokenType token.TokenType, fn prefixParseFn) {\n\tp.prefixParseFns[tokenType] = fn\n}",
    "func (p *Parser) registerInfix(tokenType token.TokenType, fn infixParseFn) {\n\tp.infixParseFns[tokenType] = fn\n}",
    "func (p *Parser) nextToken() {\n\tp.curToken = p.peekToken\n\tp.peekToken = p.l.NextToken()\n}",
    "func (p *Parser) ParseProgram() *ast.Program {\n\tprogram := &ast.Program{}\n\tprogram.Statements = []ast.Statement{}\n\n\tfor !p.curTokenIs(token.EOF) {\n\t\tstmt := p.parseStatement()\n\t\tif stmt != nil {\n\t\t\tprogram.Statements = append(program.Statements, stmt)\n\t\t}\n\t\tp.nextToken()\n\t}\n\n\treturn program\n}",
    "func (p *Parser) parseStatement() ast.Statement {\n\tswitch p.curToken.Type {\n\tcase token.Let:\n\t\treturn p.parseLetStatement()\n\tcase token.Return:\n\t\treturn p.parseReturnStatement()\n\tdefault:\n\t\treturn p.parseExpressionStatement()\n\t}\n}",
    "func (p *Parser) parseLetStatement() *ast.LetStatement {\n\tstmt := &ast.LetStatement{Token: p.curToken}\n\n\tif !p.expectPeek(token.Identifier) {\n\t\treturn nil\n\t}\n\n\tstmt.Name = &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}\n\n\tif !p.expectPeek(token.Assign) {\n\t\treturn nil\n\t}\n\n\tp.nextToken()\n\n\tstmt.Value = p.parseExpression(LOWEST)\n\n\tif p.peekTokenIs(token.Semicolon) {\n\t\tp.nextToken()\n\t}\n\n\treturn stmt\n}",
    "func (p *Parser) parseReturnStatement() *ast.ReturnStatement {\n\tstmt := &ast.ReturnStatement{Token: p.curToken}\n\n\tp.nextToken()\n\n\tstmt.ReturnValue = p.parseExpression(LOWEST)\n\n\tif p.peekTokenIs(token.Semicolon) {\n\t\tp.nextToken()\n\t}\n\n\treturn stmt\n}",
    "func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {\n\tstmt := &ast.ExpressionStatement{Token: p.curToken}\n\n\tstmt.Expression = p.parseExpression(LOWEST)\n\n\tif p.peekTokenIs(token.Semicolon) {\n\t\tp.nextToken()\n\t}\n\n\treturn stmt\n}",
    "func (p *Parser) parseExpression(precedence int) ast.Expression {\n\tprefixFn := p.prefixParseFns[p.curToken.Type]\n\tif prefixFn == nil {\n\t\tmsg := fmt.Sprintf(\"no prefix parse function for %s found\", p.curToken.Type)\n\t\tp.errors = append(p.errors, msg)\n\t\treturn nil\n\t}\n\n\tleftExp := prefixFn()\n\n\tfor !p.peekTokenIs(token.Semicolon) && precedence < p.peekPrecedence() {\n\t\tinfixFn := p.infixParseFns[p.peekToken.Type]\n\t\tif infixFn == nil {\n\t\t\treturn leftExp\n\t\t}\n\n\t\tp.nextToken()\n\t\tleftExp = infixFn(leftExp)\n\t}\n\n\treturn leftExp\n}",
    "func (p *Parser) parseIntegerLiteral() ast.Expression {\n\tlit := &ast.IntegerLiteral{Token: p.curToken}\n\tvalue, err := strconv.ParseInt(p.curToken.Literal, 0, 64)\n\n\tif err != nil {\n\t\tmsg := fmt.Sprintf(\"could not parse %q as integer\", p.curToken.Literal)\n\t\tp.errors = append(p.errors, msg)\n\t\treturn nil\n\t}\n\n\tlit.Value = value\n\treturn lit\n}",
    "func (p *Parser) parseBoolean() ast.Expression {\n\treturn &ast.Boolean{Token: p.curToken, Value: p.curTokenIs(token.True)}\n}",
    "func (p *Parser) parseGroupedExpression() ast.Expression {\n\tp.nextToken()\n\texp := p.parseExpression(LOWEST)\n\tif !p.expectPeek(token.RightParen) {\n\t\treturn nil\n\t}\n\treturn exp\n}",
    "func (p *Parser) parseIfExpression() ast.Expression {\n\texpression := &ast.IfExpression{Token: p.curToken}\n\tif !p.expectPeek(token.LeftParen) {\n\t\treturn nil\n\t}\n\n\tp.nextToken()\n\n\texpression.Condition = p.parseExpression(LOWEST)\n\tif !p.expectPeek(token.RightParen) {\n\t\treturn nil\n\t}\n\tif !p.expectPeek(token.LeftBrace) {\n\t\treturn nil\n\t}\n\n\texpression.IfBody = p.parseBlockStatement()\n\n\tif p.peekTokenIs(token.Else) {\n\t\tp.nextToken()\n\t\tif !p.expectPeek(token.LeftBrace) {\n\t\t\treturn nil\n\t\t}\n\t\texpression.ElseBody = p.parseBlockStatement()\n\t}\n\n\treturn expression\n}",
    "func (p *Parser) parseFunctionLiteral() ast.Expression {\n\tliteral := &ast.FunctionLiteral{Token: p.curToken}\n\n\tif !p.expectPeek(token.LeftParen) {\n\t\treturn nil\n\t}\n\n\tliteral.Parameters = p.parseFunctionParameters()\n\n\tif !p.expectPeek(token.LeftBrace) {\n\t\treturn nil\n\t}\n\n\tliteral.Body = p.parseBlockStatement()\n\treturn literal\n}",
    "func (p *Parser) parseFunctionParameters() []*ast.Identifier {\n\tvar parameters []*ast.Identifier\n\n\tif p.peekTokenIs(token.RightParen) {\n\t\tp.nextToken()\n\t\treturn parameters\n\t}\n\n\tp.nextToken()\n\n\tparameter := &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}\n\tparameters = append(parameters, parameter)\n\n\tfor p.peekTokenIs(token.Comma) {\n\t\tp.nextToken()\n\t\tp.nextToken()\n\t\tparameter = &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}\n\t\tparameters = append(parameters, parameter)\n\t}\n\tif !p.expectPeek(token.RightParen) {\n\t\treturn nil\n\t}\n\n\treturn parameters\n}",
    "func (p *Parser) parseBlockStatement() *ast.BlockStatement {\n\tblock := &ast.BlockStatement{Token: p.curToken}\n\tblock.Statements = []ast.Statement{}\n\n\tp.nextToken()\n\n\tfor !p.curTokenIs(token.RightBrace) && !p.curTokenIs(token.EOF) {\n\t\tstmt := p.parseStatement()\n\t\tif stmt != nil {\n\t\t\tblock.Statements = append(block.Statements, stmt)\n\t\t}\n\t\tp.nextToken()\n\t}\n\n\treturn block\n}",
    "func (p *Parser) parseFunctionCallExpression(function ast.Expression) ast.Expression {\n\texpression := &ast.FunctionCallExpression{Token: p.curToken, Function: function}\n\texpression.Arguments = p.parseFunctionCallArguments()\n\treturn expression\n}",
    "func (p *Parser) parseFunctionCallArguments() []ast.Expression {\n\targs := []ast.Expression{}\n\n\tif p.peekTokenIs(token.RightParen) {\n\t\tp.nextToken()\n\t\treturn args\n\t}\n\n\tp.nextToken()\n\n\tident := p.parseExpression(LOWEST)\n\targs = append(args, ident)\n\n\tfor p.peekTokenIs(token.Comma) {\n\t\tp.nextToken()\n\t\tp.nextToken()\n\t\tident = p.parseExpression(LOWEST)\n\t\targs = append(args, ident)\n\t}\n\n\tif !p.expectPeek(token.RightParen) {\n\t\treturn nil\n\t}\n\n\treturn args\n}",
    "func (p *Parser) parsePrefixExpression() ast.Expression {\n\texpression := &ast.PrefixExpression{\n\t\tToken:    p.curToken,\n\t\tOperator: p.curToken.Literal,\n\t}\n\n\tp.nextToken()\n\texpression.Right = p.parseExpression(PREFIX)\n\treturn expression\n}",
    "func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {\n\texpression := &ast.InfixExpression{\n\t\tToken:    p.curToken,\n\t\tOperator: p.curToken.Literal,\n\t\tLeft:     left,\n\t}\n\n\tprecedence := p.curPrecedence()\n\tp.nextToken()\n\texpression.Right = p.parseExpression(precedence)\n\n\treturn expression\n}",
    "func (p *Parser) parseIdentifier() ast.Expression {\n\treturn &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}\n}",
    "func (p *Parser) curTokenIs(t token.TokenType) bool {\n\treturn p.curToken.Type == t\n}",
    "func (p *Parser) peekTokenIs(t token.TokenType) bool {\n\treturn p.peekToken.Type == t\n}",
    "func (p *Parser) expectPeek(t token.TokenType) bool {\n\tif p.peekTokenIs(t) {\n\t\tp.nextToken()\n\t\treturn true\n\t} else {\n\t\tp.peekError(t)\n\t\treturn false\n\t}\n}",
    "func (p *Parser) peekPrecedence() int {\n\tif p, ok := precedences[p.peekToken.Type]; ok {\n\t\treturn p\n\t}\n\treturn LOWEST\n}",
    "func (p *Parser) curPrecedence() int {\n\tif p, ok := precedences[p.curToken.Type]; ok {\n\t\treturn p\n\t}\n\treturn LOWEST\n}",
    "func TestLetStatements(t *testing.T) {\n\tinput := `\n\t\tlet x = 5;\n\t\tlet y = 10;\n\t\tlet foobar = 838383;\n    `\n\n\tl := lexer.New(input)\n\tp := New(l)\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tif program == nil {\n\t\tt.Fatalf(\"ParseProgram() returned nil\")\n\t}\n\tif len(program.Statements) != 3 {\n\t\tt.Fatalf(\"program.Statements does not contain 3 statements. got=%d\", len(program.Statements))\n\t}\n\n\ttests := []struct {\n\t\texpectedIdentifier string\n\t}{\n\t\t{\"x\"},\n\t\t{\"y\"},\n\t\t{\"foobar\"},\n\t}\n\tfor i, tt := range tests {\n\t\tstmt := program.Statements[i]\n\t\tif !testLetStatement(t, stmt, tt.expectedIdentifier) {\n\t\t\treturn\n\t\t}\n\t}\n}",
    "func testLetStatement(t *testing.T, s ast.Statement, name string) bool {\n\tif s.TokenLiteral() != \"let\" {\n\t\tt.Errorf(\"s.TokenLiteral not 'let'. got=%q\", s.TokenLiteral())\n\t\treturn false\n\t}\n\tletStmt, ok := s.(*ast.LetStatement)\n\tif !ok {\n\t\tt.Errorf(\"s not *ast.LetStatement. got=%T\", s)\n\t\treturn false\n\t}\n\tif letStmt.Name.Value != name {\n\t\tt.Errorf(\"letStmt.Name.Value not '%s'. got=%s\", name, letStmt.Name.Value)\n\t\treturn false\n\t}\n\tif letStmt.Name.TokenLiteral() != name {\n\t\tt.Errorf(\"s.Name not '%s'. got=%s\", name, letStmt.Name)\n\t\treturn false\n\t}\n\treturn true\n}",
    "func TestReturnStatements(t *testing.T) {\n\tinput := `\n\t\treturn 5;\n\t\treturn 10;\n\t\treturn 993322;\n\t`\n\n\tl := lexer.New(input)\n\tp := New(l)\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tif len(program.Statements) != 3 {\n\t\tt.Fatalf(\"program.Statements does not contain 3 statements. got=%d\", len(program.Statements))\n\t}\n\n\tfor _, stmt := range program.Statements {\n\t\treturnStmt, ok := stmt.(*ast.ReturnStatement)\n\n\t\tif !ok {\n\t\t\tt.Errorf(\"stmt not *ast.returnStatement. got=%T\", stmt)\n\t\t\tcontinue\n\t\t}\n\t\tif returnStmt.TokenLiteral() != \"return\" {\n\t\t\tt.Errorf(\"returnStmt.TokenLiteral not 'return', got %q\", returnStmt.TokenLiteral())\n\t\t}\n\t}\n}",
    "func TestIdentifierExpression(t *testing.T) {\n\tinput := \"foobar;\"\n\tl := lexer.New(input)\n\tp := New(l)\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tif len(program.Statements) != 1 {\n\t\tt.Fatalf(\"program doesn't have enough statements. got=%d\", len(program.Statements))\n\t}\n\n\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\", program.Statements[0])\n\t}\n\n\tident, ok := stmt.Expression.(*ast.Identifier)\n\tif !ok {\n\t\tt.Fatalf(\"exp not *ast.Identifier. got=%T\", stmt.Expression)\n\t}\n\tif ident.Value != \"foobar\" {\n\t\tt.Errorf(\"ident.Value not %s. got=%s\", \"foobar\", ident.Value)\n\t}\n\tif ident.TokenLiteral() != \"foobar\" {\n\t\tt.Errorf(\"ident.TokenLiteral not %s. got=%s\", \"foobar\", ident.TokenLiteral())\n\t}\n}",
    "func TestIntegerLiteralExpression(t *testing.T) {\n\tinput := \"5;\"\n\tl := lexer.New(input)\n\tp := New(l)\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tif len(program.Statements) != 1 {\n\t\tt.Fatalf(\"program has not enough statements. got=%d\", len(program.Statements))\n\t}\n\n\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",\n\t\t\tprogram.Statements[0])\n\t}\n\n\tliteral, ok := stmt.Expression.(*ast.IntegerLiteral)\n\tif !ok {\n\t\tt.Fatalf(\"exp not *ast.IntegerLiteral. got=%T\", stmt.Expression)\n\t}\n\tif literal.Value != 5 {\n\t\tt.Errorf(\"literal.Value not %d. got=%d\", 5, literal.Value)\n\t}\n\tif literal.TokenLiteral() != \"5\" {\n\t\tt.Errorf(\"literal.TokenLiteral not %s. got=%s\", \"5\", literal.TokenLiteral())\n\t}\n}",
    "func TestParsingPrefixExpressions(t *testing.T) {\n\tprefixTests := []struct {\n\t\tinput        string\n\t\toperator     string\n\t\tintegerValue int64\n\t}{\n\t\t{\"!5;\", \"!\", 5},\n\t\t{\"-15;\", \"-\", 15},\n\t}\n\n\tfor _, tt := range prefixTests {\n\t\tl := lexer.New(tt.input)\n\t\tp := New(l)\n\t\tprogram := p.ParseProgram()\n\t\tcheckParserErrors(t, p)\n\n\t\tif len(program.Statements) != 1 {\n\t\t\tt.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\", 1, len(program.Statements))\n\t\t}\n\n\t\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",\n\t\t\t\tprogram.Statements[0])\n\t\t}\n\n\t\texp, ok := stmt.Expression.(*ast.PrefixExpression)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"stmt is not ast.PrefixExpression. got=%T\", stmt.Expression)\n\t\t}\n\t\tif exp.Operator != tt.operator {\n\t\t\tt.Fatalf(\"exp.Operator is not '%s'. got=%s\", tt.operator, exp.Operator)\n\t\t}\n\t\tif !testIntegerLiteral(t, exp.Right, tt.integerValue) {\n\t\t\treturn\n\t\t}\n\t}\n}",
    "func TestParsingInfixExpressions(t *testing.T) {\n\tinfixTests := []struct {\n\t\tinput      string\n\t\tleftValue  int64\n\t\toperator   string\n\t\trightValue int64\n\t}{\n\t\t{\"5 + 5;\", 5, \"+\", 5},\n\t\t{\"5 - 5;\", 5, \"-\", 5},\n\t\t{\"5 * 5;\", 5, \"*\", 5},\n\t\t{\"5 / 5;\", 5, \"/\", 5},\n\t\t{\"5 > 5;\", 5, \">\", 5},\n\t\t{\"5 < 5;\", 5, \"<\", 5},\n\t\t{\"5 == 5;\", 5, \"==\", 5},\n\t\t{\"5 != 5;\", 5, \"!=\", 5},\n\t}\n\n\tfor _, tt := range infixTests {\n\t\tl := lexer.New(tt.input)\n\t\tp := New(l)\n\t\tprogram := p.ParseProgram()\n\t\tcheckParserErrors(t, p)\n\n\t\tif len(program.Statements) != 1 {\n\t\t\tt.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\",\n\t\t\t\t1, len(program.Statements))\n\t\t}\n\n\t\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",\n\t\t\t\tprogram.Statements[0])\n\t\t}\n\n\t\texp, ok := stmt.Expression.(*ast.InfixExpression)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"exp is not ast.InfixExpression. got=%T\", stmt.Expression)\n\t\t}\n\t\tif !testIntegerLiteral(t, exp.Left, tt.leftValue) {\n\t\t\treturn\n\t\t}\n\t\tif exp.Operator != tt.operator {\n\t\t\tt.Fatalf(\"exp.Operator is not '%s'. got=%s\",\n\t\t\t\ttt.operator, exp.Operator)\n\t\t}\n\t\tif !testIntegerLiteral(t, exp.Right, tt.rightValue) {\n\t\t\treturn\n\t\t}\n\t}\n}",
    "func testLiteralExpression(\n\tt *testing.T,\n\texp ast.Expression,\n\texpected interface{},\n) bool {\n\tswitch v := expected.(type) {\n\tcase int:\n\t\treturn testIntegerLiteral(t, exp, int64(v))\n\tcase int64:\n\t\treturn testIntegerLiteral(t, exp, v)\n\tcase string:\n\t\treturn testIdentifier(t, exp, v)\n\tcase bool:\n\t\treturn testBooleanLiteral(t, exp, v)\n\t}\n\tt.Errorf(\"type of exp not handled. got=%T\", exp)\n\treturn false\n}",
    "func testIntegerLiteral(t *testing.T, il ast.Expression, value int64) bool {\n\tinteg, ok := il.(*ast.IntegerLiteral)\n\tif !ok {\n\t\tt.Errorf(\"il not *ast.IntegerLiteral. got=%T\", il)\n\t\treturn false\n\t}\n\tif integ.Value != value {\n\t\tt.Errorf(\"integ.Value not %d. got=%d\", value, integ.Value)\n\t\treturn false\n\t}\n\tif integ.TokenLiteral() != fmt.Sprintf(\"%d\", value) {\n\t\tt.Errorf(\"integ.TokenLiteral not %d. got=%s\", value, integ.TokenLiteral())\n\t\treturn false\n\t}\n\treturn true\n}",
    "func testBooleanLiteral(t *testing.T, exp ast.Expression, value bool) bool {\n\tbo, ok := exp.(*ast.Boolean)\n\tif !ok {\n\t\tt.Errorf(\"exp not *ast.Boolean. got=%T\", exp)\n\t\treturn false\n\t}\n\tif bo.Value != value {\n\t\tt.Errorf(\"bo.Value not %t. got=%t\", value, bo.Value)\n\t\treturn false\n\t}\n\tif bo.TokenLiteral() != fmt.Sprintf(\"%t\", value) {\n\t\tt.Errorf(\"bo.TokenLiteral not %t. got=%s\",\n\t\t\tvalue, bo.TokenLiteral())\n\t\treturn false\n\t}\n\treturn true\n}",
    "func testIdentifier(t *testing.T, exp ast.Expression, value string) bool {\n\tident, ok := exp.(*ast.Identifier)\n\tif !ok {\n\t\tt.Errorf(\"exp not *ast.Identifier. got=%T\", exp)\n\t\treturn false\n\t}\n\tif ident.Value != value {\n\t\tt.Errorf(\"ident.Value not %s. got=%s\", value, ident.Value)\n\t\treturn false\n\t}\n\tif ident.TokenLiteral() != value {\n\t\tt.Errorf(\"ident.TokenLiteral not %s. got=%s\", value,\n\t\t\tident.TokenLiteral())\n\t\treturn false\n\t}\n\treturn true\n}",
    "func testInfixExpression(t *testing.T, exp ast.Expression, left interface{},\n\toperator string, right interface{}) bool {\n\topExp, ok := exp.(*ast.InfixExpression)\n\tif !ok {\n\t\tt.Errorf(\"exp is not ast.OperatorExpression. got=%T(%s)\", exp, exp)\n\t\treturn false\n\t}\n\tif !testLiteralExpression(t, opExp.Left, left) {\n\t\treturn false\n\t}\n\tif opExp.Operator != operator {\n\t\tt.Errorf(\"exp.Operator is not '%s'. got=%q\", operator, opExp.Operator)\n\t\treturn false\n\t}\n\tif !testLiteralExpression(t, opExp.Right, right) {\n\t\treturn false\n\t}\n\treturn true\n}",
    "func TestOperatorPrecedenceParsing(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"a + b + c\",\n\t\t\t\"((a + b) + c)\",\n\t\t},\n\t\t{\n\t\t\t\"-a * b\",\n\t\t\t\"((-a) * b)\",\n\t\t},\n\t\t{\n\t\t\t\"!-a\",\n\t\t\t\"(!(-a))\",\n\t\t},\n\t\t{\n\t\t\t\"a + b - c\",\n\t\t\t\"((a + b) - c)\",\n\t\t},\n\t\t{\n\t\t\t\"a * b * c\",\n\t\t\t\"((a * b) * c)\",\n\t\t},\n\t\t{\n\t\t\t\"a * b / c\",\n\t\t\t\"((a * b) / c)\",\n\t\t},\n\t\t{\n\t\t\t\"a + b / c\",\n\t\t\t\"(a + (b / c))\",\n\t\t},\n\t\t{\n\t\t\t\"a + b * c + d / e - f\",\n\t\t\t\"(((a + (b * c)) + (d / e)) - f)\",\n\t\t},\n\t\t{\n\t\t\t\"3 + 4; -5 * 5\",\n\t\t\t\"(3 + 4)((-5) * 5)\",\n\t\t},\n\t\t{\n\t\t\t\"5 > 4 == 3 < 4\",\n\t\t\t\"((5 > 4) == (3 < 4))\",\n\t\t},\n\t\t{\n\t\t\t\"5 < 4 != 3 > 4\",\n\t\t\t\"((5 < 4) != (3 > 4))\",\n\t\t},\n\t\t{\n\t\t\t\"3 + 4 * 5 == 3 * 1 + 4 * 5\",\n\t\t\t\"((3 + (4 * 5)) == ((3 * 1) + (4 * 5)))\",\n\t\t},\n\t\t{\n\t\t\t\"3 + 4 * 5 == 3 * 1 + 4 * 5\",\n\t\t\t\"((3 + (4 * 5)) == ((3 * 1) + (4 * 5)))\",\n\t\t},\n\t\t{\n\t\t\t\"true\",\n\t\t\t\"true\",\n\t\t},\n\t\t{\n\t\t\t\"false\",\n\t\t\t\"false\",\n\t\t},\n\t\t{\n\t\t\t\"3 > 5 == false\",\n\t\t\t\"((3 > 5) == false)\",\n\t\t},\n\t\t{\n\t\t\t\"3 < 5 == true\",\n\t\t\t\"((3 < 5) == true)\",\n\t\t},\n\t\t{\n\t\t\t\"1 + (2 + 3) + 4\",\n\t\t\t\"((1 + (2 + 3)) + 4)\",\n\t\t},\n\t\t{\n\t\t\t\"(5 + 5) * 2\",\n\t\t\t\"((5 + 5) * 2)\",\n\t\t},\n\t\t{\n\t\t\t\"2 / (5 + 5)\",\n\t\t\t\"(2 / (5 + 5))\",\n\t\t},\n\t\t{\n\t\t\t\"-(5 + 5)\",\n\t\t\t\"(-(5 + 5))\",\n\t\t},\n\t\t{\n\t\t\t\"!(true == true)\",\n\t\t\t\"(!(true == true))\",\n\t\t},\n\t\t{\n\t\t\t\"a + add(b * c) + d\",\n\t\t\t\"((a + add((b * c))) + d)\",\n\t\t},\n\t\t{\n\t\t\t\"add(a, b, 1, 2 * 3, 4 + 5, add(6, 7 * 8))\",\n\t\t\t\"add(a, b, 1, (2 * 3), (4 + 5), add(6, (7 * 8)))\",\n\t\t},\n\t\t{\n\t\t\t\"add(a + b + c * d / f + g)\",\n\t\t\t\"add((((a + b) + ((c * d) / f)) + g))\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tl := lexer.New(tt.input)\n\t\tp := New(l)\n\t\tprogram := p.ParseProgram()\n\t\tcheckParserErrors(t, p)\n\t\tactual := program.String()\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"expected=%q, got=%q\", tt.expected, actual)\n\t\t}\n\t}\n}",
    "func TestIfExpression(t *testing.T) {\n\tinput := `if (x < y) { x }`\n\n\tp := New(lexer.New(input))\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tif len(program.Statements) != 1 {\n\t\tt.Fatalf(\"program.Body does not contain %d statements. got=%d\\n\", 1, len(program.Statements))\n\t}\n\n\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",\n\t\t\tprogram.Statements[0])\n\t}\n\n\texp, ok := stmt.Expression.(*ast.IfExpression)\n\tif !ok {\n\t\tt.Fatalf(\"stmt.Expression is not ast.IfExpression. got=%T\", stmt.Expression)\n\t}\n\tif !testInfixExpression(t, exp.Condition, \"x\", \"<\", \"y\") {\n\t\treturn\n\t}\n\tif len(exp.IfBody.Statements) != 1 {\n\t\tt.Errorf(\"consequence is not 1 statements. got=%d\\n\", len(exp.IfBody.Statements))\n\t}\n\n\tconsequence, ok := exp.IfBody.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"Statements[0] is not ast.ExpressionStatement. got=%T\", exp.IfBody.Statements[0])\n\t}\n\tif !testIdentifier(t, consequence.Expression, \"x\") {\n\t\treturn\n\t}\n\tif exp.ElseBody != nil {\n\t\tt.Errorf(\"exp.Alternative.Statements was not nil. got=%+v\", exp.ElseBody)\n\t}\n}",
    "func TestIfElseExpression(t *testing.T) {\n\tinput := \"if (x < y) { x } else { y }\"\n\n\tp := New(lexer.New(input))\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tl := len(program.Statements)\n\tif l != 1 {\n\t\tt.Fatalf(\"program.Body does not contain %d statements. got=%d\", 1, l)\n\t}\n\n\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"program.Statements[0] is not *ast.ExpressionStatement. got=%T\", program.Statements[0])\n\t}\n\n\texpr, ok := stmt.Expression.(*ast.IfExpression)\n\tif !ok {\n\t\tt.Errorf(\"stmt.Expression is not ast.Expression. got=%T\", stmt.Expression)\n\t}\n\n\ttestInfixExpression(t, expr.Condition, \"x\", \"<\", \"y\")\n\n\tl = len(expr.IfBody.Statements)\n\tif l != 1 {\n\t\tt.Errorf(\"consequence is not %d statements. got=%d\\n\", 1, l)\n\t}\n\n\tconsequence, ok := expr.IfBody.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"Statements[0] is not *ast.ExpressionStatement. got=%T\", expr.IfBody.Statements[0])\n\t}\n\n\ttestIdentifier(t, consequence.Expression, \"x\")\n\n\talternative, ok := expr.ElseBody.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"Statements[0] is not *ast.ExpressionStatement. got=%T\", expr.ElseBody.Statements[0])\n\t}\n\n\ttestIdentifier(t, alternative.Expression, \"y\")\n}",
    "func TestFunctionLiteralParsing(t *testing.T) {\n\tinput := `fn(x, y) { x + y; }`\n\n\tp := New(lexer.New(input))\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tif len(program.Statements) != 1 {\n\t\tt.Fatalf(\"program.Body does not contain %d statements. got=%d\\n\", 1, len(program.Statements))\n\t}\n\n\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\", program.Statements[0])\n\t}\n\n\tfunction, ok := stmt.Expression.(*ast.FunctionLiteral)\n\tif !ok {\n\t\tt.Fatalf(\"stmt.Expression is not ast.FunctionLiteral. got=%T\", stmt.Expression)\n\t}\n\tif len(function.Parameters) != 2 {\n\t\tt.Fatalf(\"function literal parameters wrong. want 2, got=%d\\n\", len(function.Parameters))\n\t}\n\n\ttestLiteralExpression(t, function.Parameters[0], \"x\")\n\ttestLiteralExpression(t, function.Parameters[1], \"y\")\n\n\tif len(function.Body.Statements) != 1 {\n\t\tt.Fatalf(\"function.Body.Statements has not 1 statements. got=%d\\n\", len(function.Body.Statements))\n\t}\n\n\tbodyStmt, ok := function.Body.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"function body stmt is not ast.ExpressionStatement. got=%T\", function.Body.Statements[0])\n\t}\n\n\ttestInfixExpression(t, bodyStmt.Expression, \"x\", \"+\", \"y\")\n}",
    "func TestFunctionParameterParsing(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedParams []string\n\t}{\n\t\t{input: \"fn() {};\", expectedParams: []string{}},\n\t\t{input: \"fn(x) {};\", expectedParams: []string{\"x\"}},\n\t\t{input: \"fn(x, y, z) {};\", expectedParams: []string{\"x\", \"y\", \"z\"}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tp := New(lexer.New(tt.input))\n\t\tprogram := p.ParseProgram()\n\t\tcheckParserErrors(t, p)\n\n\t\tstmt := program.Statements[0].(*ast.ExpressionStatement)\n\t\tfunction := stmt.Expression.(*ast.FunctionLiteral)\n\n\t\tif len(function.Parameters) != len(tt.expectedParams) {\n\t\t\tt.Errorf(\"length parameters wrong. want %d, got=%d\\n\", len(tt.expectedParams), len(function.Parameters))\n\t\t}\n\t\tfor i, ident := range tt.expectedParams {\n\t\t\ttestLiteralExpression(t, function.Parameters[i], ident)\n\t\t}\n\t}\n}",
    "func TestFunctionCallExpressionParsing(t *testing.T) {\n\tinput := \"add(1, 2 * 3, 4 + 5);\"\n\n\tp := New(lexer.New(input))\n\tprogram := p.ParseProgram()\n\tcheckParserErrors(t, p)\n\n\tif len(program.Statements) != 1 {\n\t\tt.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\", 1, len(program.Statements))\n\t}\n\n\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\tif !ok {\n\t\tt.Fatalf(\"stmt is not ast.ExpressionStatement. got=%T\", program.Statements[0])\n\t}\n\n\texp, ok := stmt.Expression.(*ast.FunctionCallExpression)\n\tif !ok {\n\t\tt.Fatalf(\"stmt.Expression is not ast.CallExpression. got=%T\", stmt.Expression)\n\t}\n\n\tif !testIdentifier(t, exp.Function, \"add\") {\n\t\treturn\n\t}\n\n\tif len(exp.Arguments) != 3 {\n\t\tt.Fatalf(\"wrong length of arguments. got=%d\", len(exp.Arguments))\n\t}\n\n\ttestLiteralExpression(t, exp.Arguments[0], 1)\n\ttestInfixExpression(t, exp.Arguments[1], 2, \"*\", 3)\n\ttestInfixExpression(t, exp.Arguments[2], 4, \"+\", 5)\n}",
    "func checkParserErrors(t *testing.T, p *Parser) {\n\terrors := p.Errors()\n\tif len(errors) == 0 {\n\t\treturn\n\t}\n\n\tt.Errorf(\"parser has %d errors\", len(errors))\n\n\tfor _, msg := range errors {\n\t\tt.Errorf(\"parser error: %q\", msg)\n\t}\n\n\tt.FailNow()\n}",
    "func Start(in io.Reader, out io.Writer) {\n\tscanner := bufio.NewScanner(in)\n\n\tfor {\n\t\tfmt.Printf(Prompt)\n\n\t\tscanned := scanner.Scan()\n\t\tif !scanned {\n\t\t\treturn\n\t\t}\n\n\t\tline := scanner.Text()\n\t\tl := lexer.New(line)\n\t\tp := parser.New(l)\n\t\tprogram := p.ParseProgram()\n\n\t\tif len(p.Errors()) != 0 {\n\t\t\tprintParserErrors(out, p.Errors())\n\t\t\tcontinue\n\t\t}\n\n\t\tio.WriteString(out, program.String())\n\t\tio.WriteString(out, \"\\n\")\n\t}\n}",
    "func printParserErrors(out io.Writer, errors []string) {\n\tfor _, msg := range errors {\n\t\tio.WriteString(out, \"\\t\"+msg+\"\\n\")\n\t}\n}",
    "func LookupIdentifier(ident string) TokenType {\n\tif tok, ok := keywords[ident]; ok {\n\t\treturn tok\n\t}\n\n\treturn Identifier\n}",
    "func verticalTraversal(root *TreeNode) [][]int {\n    verticalValues := make(map[int][]int)\n    curLevel := []NodeInfo { NodeInfo { root, 0 } }\n\n    for len(curLevel) > 0 {\n        nextLevel := []NodeInfo {}\n        levelValues := make(map[int][]int)\n\n        for _, nodeInfo := range curLevel {\n            if nodeInfo.Node == nil {\n                continue\n            }\n\n            vertical := nodeInfo.Vertical\n            levelValues[vertical] = append(levelValues[vertical], nodeInfo.Node.Val)\n\n            nextLevel = append(nextLevel,\n                NodeInfo{Node: nodeInfo.Node.Left, Vertical: vertical - 1},\n                NodeInfo{Node: nodeInfo.Node.Right, Vertical: vertical + 1})\n        }\n\n        for col, vals := range levelValues {\n            sort.Ints(vals)\n            verticalValues[col] = append(verticalValues[col], vals...)\n        }\n\n        curLevel = nextLevel\n    }\n\n    keys := make([]int, 0, len(verticalValues))\n    for k := range verticalValues {\n        keys = append(keys, k)\n    }\n    sort.Ints(keys)\n\n    res := make([][]int, 0, len(keys))\n\n    for _, k := range keys {\n        res = append(res, verticalValues[k])\n    }\n\n    return res\n}",
    "func minDominoRotations(tops []int, bottoms []int) int {\n    n := len(tops)\n    minRotations := 20001\n    values := []int {tops[0], bottoms[0]}\n\n    for _, value := range values {\n        canMatchValues := true\n        topRotations, bottomRotations := 0, 0\n\n        for i := 0; i < n; i++ {\n            if tops[i] != value && bottoms[i] != value {\n                canMatchValues = false\n                break\n            }\n\n            if tops[i] != value {\n                topRotations += 1\n            }\n            if bottoms[i] != value {\n                bottomRotations += 1\n            }\n        }\n\n        if canMatchValues {\n            minRotations = min(minRotations, min(topRotations, bottomRotations))\n        }\n    }\n\n    if minRotations == 20001 {\n        return -1\n    }\n\n    return minRotations\n}",
    "func buildTree(preorder []int, inorder []int) *TreeNode {\n    var valueToIndex map[int]int = make(map[int]int)\n    var buildSubtree func(int, int, int, int) *TreeNode\n    var n = len(preorder)\n\n    for i, val := range inorder {\n        valueToIndex[val] = i\n    }\n\n    buildSubtree = func(pStart int, pEnd int, iStart int, iEnd int) *TreeNode {\n        if pStart > pEnd {\n            return nil\n        }\n\n        var subtreeRootVal = preorder[pStart]\n        var subtreeRoot = &TreeNode { Val: subtreeRootVal }\n        var inorderNodeIndex = valueToIndex[subtreeRootVal]\n        var leftSubtreeSize = inorderNodeIndex - iStart\n\n        subtreeRoot.Left = buildSubtree(pStart + 1, pStart + leftSubtreeSize, iStart, inorderNodeIndex - 1)\n        subtreeRoot.Right = buildSubtree(pStart + leftSubtreeSize + 1, pEnd, inorderNodeIndex + 1, iEnd)\n\n        return subtreeRoot\n    }\n\n    return buildSubtree(0, n - 1, 0, n - 1)\n}",
    "func numPairsDivisibleBy60(time []int) int {\n    remainderFreq := make(map[int]int)\n    res := 0\n\n    for _, duration := range time {\n        remainderFreq[duration % 60] += 1\n    }\n\n    for durationRemainder, freq := range remainderFreq {\n        if durationRemainder == 30 || durationRemainder == 0 {\n            res += freq * (freq - 1)\n        } else {\n            res += freq * remainderFreq[60 - durationRemainder]\n        }\n\n        \n    }\n\n    return res >> 1\n}",
    "func levelOrderBottom(root *TreeNode) [][]int {\n    if root == nil {\n        return [][]int{}\n    }\n\n    queue := []*TreeNode{root}\n    levels := [][]int{}\n\n    for len(queue) > 0 {\n        size := len(queue)\n        levels = append(levels, []int{})\n        curLevelI := len(levels) - 1\n\n        for i := 0; i < size; i++ {\n            node := queue[0]\n            queue = queue[1:] // O(1). In Go slices we trust!\n            levels[curLevelI] = append(levels[curLevelI], node.Val)\n\n            if node.Left != nil {\n                queue = append(queue, node.Left)\n            }\n            if node.Right != nil {\n                queue = append(queue, node.Right)\n            }\n        }\n    }\n\n    slices.Reverse(levels)\n    return levels\n}",
    "func nextLargerNodes(head *ListNode) []int {\n    var monoStack []*Pair\n    idxToAnswerMap := make(map[int]int)\n    idx := 0\n\n    for head != nil {\n        pair := Pair{Index: idx, Value: head.Val}\n\n        for len(monoStack) > 0 && pair.Value > monoStack[len(monoStack)-1].Value {\n            poppedPair := monoStack[len(monoStack)-1]\n            monoStack = monoStack[:len(monoStack)-1]\n            idxToAnswerMap[poppedPair.Index] = pair.Value\n        }\n\n        monoStack = append(monoStack, &pair)\n        head = head.Next\n        idx += 1\n    }\n\n    res := make([]int, idx)\n\n    for numI, answer := range idxToAnswerMap {\n        res[numI] = answer\n    }\n\n    return res\n}",
    "func sortedListToBST(head *ListNode) *TreeNode {\n    if head == nil {\n        return nil\n    }\n    if head.Next == nil {\n        return &TreeNode{Val: head.Val}\n    }\n\n    slow, fast := head, head\n    temp := head\n\n    for fast != nil && fast.Next != nil {\n        temp = slow\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    temp.Next = nil\n    \n    root := &TreeNode{Val: slow.Val}\n    root.Left = sortedListToBST(head)\n    root.Right = sortedListToBST(slow.Next)\n\n    return root\n}",
    "func maxAncestorDiff(root *TreeNode) int {\n    var dfs func(*TreeNode, int, int)\n    maxDiff := 0\n\n    dfs = func(node *TreeNode, maxVal int, minVal int) {\n        if node == nil {\n            return\n        }\n\n        maxDiff = max(maxDiff, abs(maxVal - node.Val), abs(minVal - node.Val))\n        newMaxVal := max(maxVal, node.Val)\n        newMinVal := min(minVal, node.Val)\n\n        dfs(node.Left, newMaxVal, newMinVal)\n        dfs(node.Right, newMaxVal, newMinVal)\n    }\n\n    dfs(root, root.Val, root.Val)\n    return maxDiff\n}",
    "func abs(num int) int {\n    if num < 0 {\n        return -num\n    }\n\n    return num\n}",
    "func maxSumAfterPartitioning(arr []int, k int) int {\n    memo := make([]int, len(arr))\n    var solve func(int) int\n\n    solve = func(i int) int {\n        if i == len(arr) {\n            return 0\n        }\n\n        if memo[i] != 0 {\n            return memo[i]\n        }\n\n        maxNum := 0\n        ans := 0\n\n        for j := i; j < len(arr) && j < i + k; j++ {\n            maxNum = max(maxNum, arr[j])\n            curCnt := j - i + 1\n\n            ans = max(ans, maxNum * curCnt + solve(j + 1))\n        }\n\n        memo[i] = ans\n        return ans\n    }\n\n    return solve(0)\n}",
    "func carPooling(trips [][]int, capacity int) bool {\n    changes := make([]int, 1001)\n\n    for _, trip := range trips {\n        passengerCnt, from, to := trip[0], trip[1], trip[2]\n        changes[from] += passengerCnt\n        changes[to] -= passengerCnt\n    }\n\n    curPassengers := 0\n\n    for _, change := range changes {\n        curPassengers += change\n        if curPassengers > capacity {\n            return false\n        }\n    }\n\n    return true\n}",
    "func (e ErrOffsetOutOfRange) GRPCStatus() *status.Status {\n\tst := status.New(404, fmt.Sprintf(\"offset out of range: %d\", e.Offset))\n\tmsg := fmt.Sprintf(\n\t\t\"The requested offset is outside of the log: %d\",\n\t\te.Offset,\n\t)\n\td := &errdetails.LocalizedMessage{\n\t\tLocale:  \"en-US\",\n\t\tMessage: msg,\n\t}\n\tstd, err := st.WithDetails(d)\n\tif err != nil {\n\t\treturn st\n\t}\n\treturn std\n}",
    "func (e ErrOffsetOutOfRange) Error() string {\n\treturn e.GRPCStatus().Err().Error()\n}",
    "func (x *ProduceRequest) Reset() {\n\t*x = ProduceRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *ProduceRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*ProduceRequest) ProtoMessage() {}",
    "func (x *ProduceRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[0]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ProduceRequest.ProtoReflect.Descriptor instead.",
    "func (*ProduceRequest) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{0}\n}",
    "func (x *ProduceRequest) GetRecord() *Record {\n\tif x != nil {\n\t\treturn x.Record\n\t}\n\treturn nil\n}\n\ntype ProduceResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tOffset uint64 `protobuf:\"varint,1,opt,name=offset,proto3\" json:\"offset,omitempty\"`\n}",
    "func (x *ProduceResponse) Reset() {\n\t*x = ProduceResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[1]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *ProduceResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*ProduceResponse) ProtoMessage() {}",
    "func (x *ProduceResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[1]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ProduceResponse.ProtoReflect.Descriptor instead.",
    "func (*ProduceResponse) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{1}\n}",
    "func (x *ProduceResponse) GetOffset() uint64 {\n\tif x != nil {\n\t\treturn x.Offset\n\t}\n\treturn 0\n}\n\ntype ConsumeRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tOffset uint64 `protobuf:\"varint,1,opt,name=offset,proto3\" json:\"offset,omitempty\"`\n}",
    "func (x *ConsumeRequest) Reset() {\n\t*x = ConsumeRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[2]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *ConsumeRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*ConsumeRequest) ProtoMessage() {}",
    "func (x *ConsumeRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[2]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ConsumeRequest.ProtoReflect.Descriptor instead.",
    "func (*ConsumeRequest) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{2}\n}",
    "func (x *ConsumeRequest) GetOffset() uint64 {\n\tif x != nil {\n\t\treturn x.Offset\n\t}\n\treturn 0\n}\n\ntype ConsumeResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tRecord *Record `protobuf:\"bytes,2,opt,name=record,proto3\" json:\"record,omitempty\"`\n}",
    "func (x *ConsumeResponse) Reset() {\n\t*x = ConsumeResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *ConsumeResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*ConsumeResponse) ProtoMessage() {}",
    "func (x *ConsumeResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[3]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ConsumeResponse.ProtoReflect.Descriptor instead.",
    "func (*ConsumeResponse) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{3}\n}",
    "func (x *ConsumeResponse) GetRecord() *Record {\n\tif x != nil {\n\t\treturn x.Record\n\t}\n\treturn nil\n}\n\ntype Record struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tValue  []byte `protobuf:\"bytes,1,opt,name=value,proto3\" json:\"value,omitempty\"`\n\tOffset uint64 `protobuf:\"varint,2,opt,name=offset,proto3\" json:\"offset,omitempty\"`\n\tTerm   uint64 `protobuf:\"varint,3,opt,name=term,proto3\" json:\"term,omitempty\"`\n\tType   uint32 `protobuf:\"varint,4,opt,name=type,proto3\" json:\"type,omitempty\"`\n}",
    "func (x *Record) Reset() {\n\t*x = Record{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[4]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *Record) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*Record) ProtoMessage() {}",
    "func (x *Record) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[4]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Record.ProtoReflect.Descriptor instead.",
    "func (*Record) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{4}\n}",
    "func (x *Record) GetValue() []byte {\n\tif x != nil {\n\t\treturn x.Value\n\t}\n\treturn nil\n}",
    "func (x *Record) GetOffset() uint64 {\n\tif x != nil {\n\t\treturn x.Offset\n\t}\n\treturn 0\n}",
    "func (x *Record) GetTerm() uint64 {\n\tif x != nil {\n\t\treturn x.Term\n\t}\n\treturn 0\n}",
    "func (x *Record) GetType() uint32 {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn 0\n}\n\n// START: get_servers\ntype GetServersRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n}",
    "func (x *GetServersRequest) Reset() {\n\t*x = GetServersRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[5]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *GetServersRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*GetServersRequest) ProtoMessage() {}",
    "func (x *GetServersRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[5]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use GetServersRequest.ProtoReflect.Descriptor instead.",
    "func (*GetServersRequest) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{5}\n}\n\ntype GetServersResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tServers []*Server `protobuf:\"bytes,1,rep,name=servers,proto3\" json:\"servers,omitempty\"`\n}",
    "func (x *GetServersResponse) Reset() {\n\t*x = GetServersResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[6]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *GetServersResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*GetServersResponse) ProtoMessage() {}",
    "func (x *GetServersResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[6]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use GetServersResponse.ProtoReflect.Descriptor instead.",
    "func (*GetServersResponse) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{6}\n}",
    "func (x *GetServersResponse) GetServers() []*Server {\n\tif x != nil {\n\t\treturn x.Servers\n\t}\n\treturn nil\n}\n\ntype Server struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tId       string `protobuf:\"bytes,1,opt,name=id,proto3\" json:\"id,omitempty\"`\n\tRpcAddr  string `protobuf:\"bytes,2,opt,name=rpc_addr,json=rpcAddr,proto3\" json:\"rpc_addr,omitempty\"`\n\tIsLeader bool   `protobuf:\"varint,3,opt,name=is_leader,json=isLeader,proto3\" json:\"is_leader,omitempty\"`\n}",
    "func (x *Server) Reset() {\n\t*x = Server{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_api_v1_log_proto_msgTypes[7]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}",
    "func (x *Server) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}",
    "func (*Server) ProtoMessage() {}",
    "func (x *Server) ProtoReflect() protoreflect.Message {\n\tmi := &file_api_v1_log_proto_msgTypes[7]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Server.ProtoReflect.Descriptor instead.",
    "func (*Server) Descriptor() ([]byte, []int) {\n\treturn file_api_v1_log_proto_rawDescGZIP(), []int{7}\n}",
    "func (x *Server) GetId() string {\n\tif x != nil {\n\t\treturn x.Id\n\t}\n\treturn \"\"\n}",
    "func (x *Server) GetRpcAddr() string {\n\tif x != nil {\n\t\treturn x.RpcAddr\n\t}\n\treturn \"\"\n}",
    "func (x *Server) GetIsLeader() bool {\n\tif x != nil {\n\t\treturn x.IsLeader\n\t}\n\treturn false\n}\n\nvar File_api_v1_log_proto protoreflect.FileDescriptor\n\nvar file_api_v1_log_proto_rawDesc = []byte{\n\t0x0a, 0x10, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6c, 0x6f, 0x67, 0x2e, 0x70, 0x72, 0x6f,\n\t0x74, 0x6f, 0x12, 0x06, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x22, 0x38, 0x0a, 0x0e, 0x50, 0x72,\n\t0x6f, 0x64, 0x75, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x26, 0x0a, 0x06,\n\t0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6c,\n\t0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x06, 0x72, 0x65,\n\t0x63, 0x6f, 0x72, 0x64, 0x22, 0x29, 0x0a, 0x0f, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x52,\n\t0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65,\n\t0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22,\n\t0x28, 0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,\n\t0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,\n\t0x04, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x39, 0x0a, 0x0f, 0x43, 0x6f, 0x6e,\n\t0x73, 0x75, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26, 0x0a, 0x06,\n\t0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6c,\n\t0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x06, 0x72, 0x65,\n\t0x63, 0x6f, 0x72, 0x64, 0x22, 0x5e, 0x0a, 0x06, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x14,\n\t0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x76,\n\t0x61, 0x6c, 0x75, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02,\n\t0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04,\n\t0x74, 0x65, 0x72, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x74, 0x65, 0x72, 0x6d,\n\t0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04,\n\t0x74, 0x79, 0x70, 0x65, 0x22, 0x13, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65,\n\t0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x3e, 0x0a, 0x12, 0x47, 0x65, 0x74,\n\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,\n\t0x28, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,\n\t0x32, 0x0e, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,\n\t0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x22, 0x50, 0x0a, 0x06, 0x53, 0x65, 0x72,\n\t0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x02, 0x69, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x70, 0x63, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x18,\n\t0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x70, 0x63, 0x41, 0x64, 0x64, 0x72, 0x12, 0x1b,\n\t0x0a, 0x09, 0x69, 0x73, 0x5f, 0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28,\n\t0x08, 0x52, 0x08, 0x69, 0x73, 0x4c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x32, 0xd6, 0x02, 0x0a, 0x03,\n\t0x4c, 0x6f, 0x67, 0x12, 0x3c, 0x0a, 0x07, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x12, 0x16,\n\t0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x52,\n\t0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e,\n\t0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,\n\t0x00, 0x12, 0x3c, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x12, 0x16, 0x2e, 0x6c,\n\t0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x52, 0x65, 0x71,\n\t0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f,\n\t0x6e, 0x73, 0x75, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,\n\t0x44, 0x0a, 0x0d, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,\n\t0x12, 0x16, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d,\n\t0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76,\n\t0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,\n\t0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x46, 0x0a, 0x0d, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65,\n\t0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12, 0x16, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e,\n\t0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17,\n\t0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x52,\n\t0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x28, 0x01, 0x30, 0x01, 0x12, 0x45, 0x0a,\n\t0x0a, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x12, 0x19, 0x2e, 0x6c, 0x6f,\n\t0x67, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x52,\n\t0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x76, 0x31, 0x2e,\n\t0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,\n\t0x73, 0x65, 0x22, 0x00, 0x42, 0x25, 0x5a, 0x23, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,\n\t0x6f, 0x6d, 0x2f, 0x74, 0x72, 0x61, 0x76, 0x69, 0x73, 0x6a, 0x65, 0x66, 0x66, 0x65, 0x72, 0x79,\n\t0x2f, 0x61, 0x70, 0x69, 0x2f, 0x6c, 0x6f, 0x67, 0x5f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,\n\t0x74, 0x6f, 0x33,\n}\n\nvar (\n\tfile_api_v1_log_proto_rawDescOnce sync.Once\n\tfile_api_v1_log_proto_rawDescData = file_api_v1_log_proto_rawDesc\n)",
    "func file_api_v1_log_proto_rawDescGZIP() []byte {\n\tfile_api_v1_log_proto_rawDescOnce.Do(func() {\n\t\tfile_api_v1_log_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_v1_log_proto_rawDescData)\n\t})\n\treturn file_api_v1_log_proto_rawDescData\n}\n\nvar file_api_v1_log_proto_msgTypes = make([]protoimpl.MessageInfo, 8)\nvar file_api_v1_log_proto_goTypes = []interface{}{\n\t(*ProduceRequest)(nil),     // 0: log.v1.ProduceRequest\n\t(*ProduceResponse)(nil),    // 1: log.v1.ProduceResponse\n\t(*ConsumeRequest)(nil),     // 2: log.v1.ConsumeRequest\n\t(*ConsumeResponse)(nil),    // 3: log.v1.ConsumeResponse\n\t(*Record)(nil),             // 4: log.v1.Record\n\t(*GetServersRequest)(nil),  // 5: log.v1.GetServersRequest\n\t(*GetServersResponse)(nil), // 6: log.v1.GetServersResponse\n\t(*Server)(nil),             // 7: log.v1.Server\n}\nvar file_api_v1_log_proto_depIdxs = []int32{\n\t4, // 0: log.v1.ProduceRequest.record:type_name -> log.v1.Record\n\t4, // 1: log.v1.ConsumeResponse.record:type_name -> log.v1.Record\n\t7, // 2: log.v1.GetServersResponse.servers:type_name -> log.v1.Server\n\t0, // 3: log.v1.Log.Produce:input_type -> log.v1.ProduceRequest\n\t2, // 4: log.v1.Log.Consume:input_type -> log.v1.ConsumeRequest\n\t2, // 5: log.v1.Log.ConsumeStream:input_type -> log.v1.ConsumeRequest\n\t0, // 6: log.v1.Log.ProduceStream:input_type -> log.v1.ProduceRequest\n\t5, // 7: log.v1.Log.GetServers:input_type -> log.v1.GetServersRequest\n\t1, // 8: log.v1.Log.Produce:output_type -> log.v1.ProduceResponse\n\t3, // 9: log.v1.Log.Consume:output_type -> log.v1.ConsumeResponse\n\t3, // 10: log.v1.Log.ConsumeStream:output_type -> log.v1.ConsumeResponse\n\t1, // 11: log.v1.Log.ProduceStream:output_type -> log.v1.ProduceResponse\n\t6, // 12: log.v1.Log.GetServers:output_type -> log.v1.GetServersResponse\n\t8, // [8:13] is the sub-list for method output_type\n\t3, // [3:8] is the sub-list for method input_type\n\t3, // [3:3] is the sub-list for extension type_name\n\t3, // [3:3] is the sub-list for extension extendee\n\t0, // [0:3] is the sub-list for field type_name\n}",
    "func init() { file_api_v1_log_proto_init() }",
    "func file_api_v1_log_proto_init() {\n\tif File_api_v1_log_proto != nil {\n\t\treturn\n\t}\n\tif !protoimpl.UnsafeEnabled {\n\t\tfile_api_v1_log_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ProduceRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_api_v1_log_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ProduceResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_api_v1_log_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ConsumeRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_api_v1_log_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ConsumeResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_api_v1_log_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*Record); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_api_v1_log_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*GetServersRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_api_v1_log_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*GetServersResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_api_v1_log_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*Server); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: file_api_v1_log_proto_rawDesc,\n\t\t\tNumEnums:      0,\n\t\t\tNumMessages:   8,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   1,\n\t\t},\n\t\tGoTypes:           file_api_v1_log_proto_goTypes,\n\t\tDependencyIndexes: file_api_v1_log_proto_depIdxs,\n\t\tMessageInfos:      file_api_v1_log_proto_msgTypes,\n\t}.Build()\n\tFile_api_v1_log_proto = out.File\n\tfile_api_v1_log_proto_rawDesc = nil\n\tfile_api_v1_log_proto_goTypes = nil\n\tfile_api_v1_log_proto_depIdxs = nil\n}",
    "func NewLogClient(cc grpc.ClientConnInterface) LogClient {\n\treturn &logClient{cc}\n}\n\nvar logProduceStreamDesc = &grpc.StreamDesc{\n\tStreamName: \"Produce\",\n}",
    "func (c *logClient) Produce(ctx context.Context, in *ProduceRequest, opts ...grpc.CallOption) (*ProduceResponse, error) {\n\tout := new(ProduceResponse)\n\terr := c.cc.Invoke(ctx, \"/log.v1.Log/Produce\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nvar logConsumeStreamDesc = &grpc.StreamDesc{\n\tStreamName: \"Consume\",\n}",
    "func (c *logClient) Consume(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (*ConsumeResponse, error) {\n\tout := new(ConsumeResponse)\n\terr := c.cc.Invoke(ctx, \"/log.v1.Log/Consume\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nvar logConsumeStreamStreamDesc = &grpc.StreamDesc{\n\tStreamName:    \"ConsumeStream\",\n\tServerStreams: true,\n}",
    "func (c *logClient) ConsumeStream(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (Log_ConsumeStreamClient, error) {\n\tstream, err := c.cc.NewStream(ctx, logConsumeStreamStreamDesc, \"/log.v1.Log/ConsumeStream\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &logConsumeStreamClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n\ntype Log_ConsumeStreamClient interface {\n\tRecv() (*ConsumeResponse, error)\n\tgrpc.ClientStream\n}\n\ntype logConsumeStreamClient struct {\n\tgrpc.ClientStream\n}",
    "func (x *logConsumeStreamClient) Recv() (*ConsumeResponse, error) {\n\tm := new(ConsumeResponse)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n\nvar logProduceStreamStreamDesc = &grpc.StreamDesc{\n\tStreamName:    \"ProduceStream\",\n\tServerStreams: true,\n\tClientStreams: true,\n}",
    "func (c *logClient) ProduceStream(ctx context.Context, opts ...grpc.CallOption) (Log_ProduceStreamClient, error) {\n\tstream, err := c.cc.NewStream(ctx, logProduceStreamStreamDesc, \"/log.v1.Log/ProduceStream\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &logProduceStreamClient{stream}\n\treturn x, nil\n}\n\ntype Log_ProduceStreamClient interface {\n\tSend(*ProduceRequest) error\n\tRecv() (*ProduceResponse, error)\n\tgrpc.ClientStream\n}\n\ntype logProduceStreamClient struct {\n\tgrpc.ClientStream\n}",
    "func (x *logProduceStreamClient) Send(m *ProduceRequest) error {\n\treturn x.ClientStream.SendMsg(m)\n}",
    "func (x *logProduceStreamClient) Recv() (*ProduceResponse, error) {\n\tm := new(ProduceResponse)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n\nvar logGetServersStreamDesc = &grpc.StreamDesc{\n\tStreamName: \"GetServers\",\n}",
    "func (c *logClient) GetServers(ctx context.Context, in *GetServersRequest, opts ...grpc.CallOption) (*GetServersResponse, error) {\n\tout := new(GetServersResponse)\n\terr := c.cc.Invoke(ctx, \"/log.v1.Log/GetServers\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// LogService is the service API for Log service.\n// Fields should be assigned to their respective handler implementations only before\n// RegisterLogService is called.  Any unassigned fields will result in the\n// handler for that method returning an Unimplemented error.\ntype LogService struct {\n\tProduce       func(context.Context, *ProduceRequest) (*ProduceResponse, error)\n\tConsume       func(context.Context, *ConsumeRequest) (*ConsumeResponse, error)\n\tConsumeStream func(*ConsumeRequest, Log_ConsumeStreamServer) error\n\tProduceStream func(Log_ProduceStreamServer) error\n\tGetServers    func(context.Context, *GetServersRequest) (*GetServersResponse, error)\n}",
    "func (s *LogService) produce(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ProduceRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn s.Produce(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     s,\n\t\tFullMethod: \"/log.v1.Log/Produce\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn s.Produce(ctx, req.(*ProduceRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}",
    "func (s *LogService) consume(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ConsumeRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn s.Consume(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     s,\n\t\tFullMethod: \"/log.v1.Log/Consume\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn s.Consume(ctx, req.(*ConsumeRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}",
    "func (s *LogService) consumeStream(_ interface{}, stream grpc.ServerStream) error {\n\tm := new(ConsumeRequest)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn s.ConsumeStream(m, &logConsumeStreamServer{stream})\n}",
    "func (s *LogService) produceStream(_ interface{}, stream grpc.ServerStream) error {\n\treturn s.ProduceStream(&logProduceStreamServer{stream})\n}",
    "func (s *LogService) getServers(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(GetServersRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn s.GetServers(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     s,\n\t\tFullMethod: \"/log.v1.Log/GetServers\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn s.GetServers(ctx, req.(*GetServersRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\ntype Log_ConsumeStreamServer interface {\n\tSend(*ConsumeResponse) error\n\tgrpc.ServerStream\n}\n\ntype logConsumeStreamServer struct {\n\tgrpc.ServerStream\n}",
    "func (x *logConsumeStreamServer) Send(m *ConsumeResponse) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n\ntype Log_ProduceStreamServer interface {\n\tSend(*ProduceResponse) error\n\tRecv() (*ProduceRequest, error)\n\tgrpc.ServerStream\n}\n\ntype logProduceStreamServer struct {\n\tgrpc.ServerStream\n}",
    "func (x *logProduceStreamServer) Send(m *ProduceResponse) error {\n\treturn x.ServerStream.SendMsg(m)\n}",
    "func (x *logProduceStreamServer) Recv() (*ProduceRequest, error) {\n\tm := new(ProduceRequest)\n\tif err := x.ServerStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n\n// RegisterLogService registers a service implementation with a gRPC server.",
    "func RegisterLogService(s grpc.ServiceRegistrar, srv *LogService) {\n\tsrvCopy := *srv\n\tif srvCopy.Produce == nil {\n\t\tsrvCopy.Produce = func(context.Context, *ProduceRequest) (*ProduceResponse, error) {\n\t\t\treturn nil, status.Errorf(codes.Unimplemented, \"method Produce not implemented\")\n\t\t}\n\t}\n\tif srvCopy.Consume == nil {\n\t\tsrvCopy.Consume = func(context.Context, *ConsumeRequest) (*ConsumeResponse, error) {\n\t\t\treturn nil, status.Errorf(codes.Unimplemented, \"method Consume not implemented\")\n\t\t}\n\t}\n\tif srvCopy.ConsumeStream == nil {\n\t\tsrvCopy.ConsumeStream = func(*ConsumeRequest, Log_ConsumeStreamServer) error {\n\t\t\treturn status.Errorf(codes.Unimplemented, \"method ConsumeStream not implemented\")\n\t\t}\n\t}\n\tif srvCopy.ProduceStream == nil {\n\t\tsrvCopy.ProduceStream = func(Log_ProduceStreamServer) error {\n\t\t\treturn status.Errorf(codes.Unimplemented, \"method ProduceStream not implemented\")\n\t\t}\n\t}\n\tif srvCopy.GetServers == nil {\n\t\tsrvCopy.GetServers = func(context.Context, *GetServersRequest) (*GetServersResponse, error) {\n\t\t\treturn nil, status.Errorf(codes.Unimplemented, \"method GetServers not implemented\")\n\t\t}\n\t}\n\tsd := grpc.ServiceDesc{\n\t\tServiceName: \"log.v1.Log\",\n\t\tMethods: []grpc.MethodDesc{\n\t\t\t{\n\t\t\t\tMethodName: \"Produce\",\n\t\t\t\tHandler:    srvCopy.produce,\n\t\t\t},\n\t\t\t{\n\t\t\t\tMethodName: \"Consume\",\n\t\t\t\tHandler:    srvCopy.consume,\n\t\t\t},\n\t\t\t{\n\t\t\t\tMethodName: \"GetServers\",\n\t\t\t\tHandler:    srvCopy.getServers,\n\t\t\t},\n\t\t},\n\t\tStreams: []grpc.StreamDesc{\n\t\t\t{\n\t\t\t\tStreamName:    \"ConsumeStream\",\n\t\t\t\tHandler:       srvCopy.consumeStream,\n\t\t\t\tServerStreams: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tStreamName:    \"ProduceStream\",\n\t\t\t\tHandler:       srvCopy.produceStream,\n\t\t\t\tServerStreams: true,\n\t\t\t\tClientStreams: true,\n\t\t\t},\n\t\t},\n\t\tMetadata: \"api/v1/log.proto\",\n\t}\n\n\ts.RegisterService(&sd, nil)\n}",
    "func main() {\n\t\n}",
    "func (c Config) RPCAddr() (string, error) {\n\thost, _, err := net.SplitHostPort(c.BindAddr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fmt.Sprintf(\"%s:%d\", host, c.RPCPort), nil\n}\n\n// START: agent\ntype Agent struct {\n\tConfig Config\n\n\tmux        cmux.CMux\n\tlog        *log.DistributedLog\n\tserver     *grpc.Server\n\tmembership *discovery.Membership\n\n\tshutdown     bool\n\tshutdowns    chan struct{}\n\tshutdownLock sync.Mutex\n}\n\n// END: agent",
    "func New(config Config) (*Agent, error) {\n\ta := &Agent{\n\t\tConfig:    config,\n\t\tshutdowns: make(chan struct{}),\n\t}\n\t// START: add_setup_mux\n\tsetup := []func() error{\n\t\t// START_HIGHLIGHT\n\t\ta.setupMux,\n\t\t// END_HIGHLIGHT\n\t\ta.setupLog,\n\t\ta.setupServer,\n\t\ta.setupMembership,\n\t}\n\t// END: add_setup_mux\n\tfor _, fn := range setup {\n\t\tif err := fn(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// START: new_serve\n\tgo a.serve()\n\t// END: new_serve\n\treturn a, nil\n}\n\n// START: setup_mux",
    "func (a *Agent) setupMux() error {\n\trpcAddr := fmt.Sprintf(\n\t\t\":%d\",\n\t\ta.Config.RPCPort,\n\t)\n\tln, err := net.Listen(\"tcp\", rpcAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\ta.mux = cmux.New(ln)\n\treturn nil\n}\n\n// END: setup_mux\n\n// START: setup_log_start",
    "func (a *Agent) setupLog() error {\n\traftLn := a.mux.Match(func(reader io.Reader) bool {\n\t\tb := make([]byte, 1)\n\t\tif _, err := reader.Read(b); err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn bytes.Compare(b, []byte{byte(log.RaftRPC)}) == 0\n\t})\n\t// END: setup_log_start\n\t// START: setup_log_end\n\tlogConfig := log.Config{}\n\tlogConfig.Raft.StreamLayer = log.NewStreamLayer(\n\t\traftLn,\n\t\ta.Config.ServerTLSConfig,\n\t\ta.Config.PeerTLSConfig,\n\t)\n\tlogConfig.Raft.LocalID = raft.ServerID(a.Config.NodeName)\n\tlogConfig.Raft.Bootstrap = a.Config.Bootstrap\n\tvar err error\n\ta.log, err = log.NewDistributedLog(\n\t\ta.Config.DataDir,\n\t\tlogConfig,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif a.Config.Bootstrap {\n\t\treturn a.log.WaitForLeader(3 * time.Second)\n\t}\n\treturn nil\n}\n\n// END: setup_log_end",
    "func (a *Agent) setupServer() error {\n\tauthorizer := auth.New(\n\t\ta.Config.ACLModelFile,\n\t\ta.Config.ACLPolicyFile,\n\t)\n\tserverConfig := &server.Config{\n\t\tCommitLog:   a.log,\n\t\tAuthorizer:  authorizer,\n\t\tGetServerer: a.log,\n\t}\n\tvar opts []grpc.ServerOption\n\tif a.Config.ServerTLSConfig != nil {\n\t\tcreds := credentials.NewTLS(a.Config.ServerTLSConfig)\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\tvar err error\n\ta.server, err = server.NewGRPCServer(serverConfig, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// START: setup_server\n\tgrpcLn := a.mux.Match(cmux.Any())\n\tgo func() {\n\t\tif err := a.server.Serve(grpcLn); err != nil {\n\t\t\t_ = a.Shutdown()\n\t\t}\n\t}()\n\treturn err\n\t// END: setup_server\n}\n\n// START: setup_membership",
    "func (a *Agent) setupMembership() error {\n\trpcAddr, err := a.Config.RPCAddr()\n\tif err != nil {\n\t\treturn err\n\t}\n\ta.membership, err = discovery.New(a.log, discovery.Config{\n\t\tNodeName: a.Config.NodeName,\n\t\tBindAddr: a.Config.BindAddr,\n\t\tTags: map[string]string{\n\t\t\t\"rpc_addr\": rpcAddr,\n\t\t},\n\t\tStartJoinAddrs: a.Config.StartJoinAddrs,\n\t})\n\treturn err\n}\n\n// END: setup_membership\n\n// START: serve",
    "func (a *Agent) serve() error {\n\tif err := a.mux.Serve(); err != nil {\n\t\t_ = a.Shutdown()\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// END: serve",
    "func (a *Agent) Shutdown() error {\n\ta.shutdownLock.Lock()\n\tdefer a.shutdownLock.Unlock()\n\tif a.shutdown {\n\t\treturn nil\n\t}\n\ta.shutdown = true\n\tclose(a.shutdowns)\n\n\tshutdown := []func() error{\n\t\ta.membership.Leave,\n\t\tfunc() error {\n\t\t\ta.server.GracefulStop()\n\t\t\treturn nil\n\t\t},\n\t\ta.log.Close,\n\t}\n\tfor _, fn := range shutdown {\n\t\tif err := fn(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "func TestAgent(t *testing.T) {\n\tvar agents []*agent.Agent\n\n\tserverTLSConfig, err := config.SetupTLSConfig(config.TLSConfig{\n\t\tCertFile:      config.ServerCertFile,\n\t\tKeyFile:       config.ServerKeyFile,\n\t\tCAFile:        config.CAFile,\n\t\tServer:        true,\n\t\tServerAddress: \"127.0.0.1\",\n\t})\n\trequire.NoError(t, err)\n\n\tpeerTLSConfig, err := config.SetupTLSConfig(config.TLSConfig{\n\t\tCertFile:      config.RootClientCertFile,\n\t\tKeyFile:       config.RootClientKeyFile,\n\t\tCAFile:        config.CAFile,\n\t\tServer:        false,\n\t\tServerAddress: \"127.0.0.1\",\n\t})\n\trequire.NoError(t, err)\n\n\tfor i := 0; i < 3; i++ {\n\t\tports := dynaport.Get(2)\n\t\tbindAddr := fmt.Sprintf(\"%s:%d\", \"127.0.0.1\", ports[0])\n\t\trpcPort := ports[1]\n\n\t\tdataDir, err := ioutil.TempDir(\"\", \"agent-test-log\")\n\t\trequire.NoError(t, err)\n\n\t\tvar startJoinAddrs []string\n\t\tif i != 0 {\n\t\t\tstartJoinAddrs = append(startJoinAddrs, agents[0].Config.BindAddr)\n\t\t}\n\n\t\tagent, err := agent.New(agent.Config{\n\t\t\tNodeName:        fmt.Sprintf(\"%d\", i),\n\t\t\tBootstrap:       i == 0,\n\t\t\tStartJoinAddrs:  startJoinAddrs,\n\t\t\tBindAddr:        bindAddr,\n\t\t\tRPCPort:         rpcPort,\n\t\t\tDataDir:         dataDir,\n\t\t\tACLModelFile:    config.ACLModelFile,\n\t\t\tACLPolicyFile:   config.ACLPolicyFile,\n\t\t\tServerTLSConfig: serverTLSConfig,\n\t\t\tPeerTLSConfig:   peerTLSConfig,\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\tagents = append(agents, agent)\n\t}\n\tdefer func() {\n\t\tfor _, agent := range agents {\n\t\t\t_ = agent.Shutdown()\n\t\t\trequire.NoError(\n\t\t\t\tt,\n\t\t\t\tos.RemoveAll(agent.Config.DataDir),\n\t\t\t)\n\t\t}\n\t}()\n\n\t// wait until agents have joined the cluster\n\ttime.Sleep(3 * time.Second)\n\n\tleaderClient := client(t, agents[0], peerTLSConfig)\n\tproduceResponse, err := leaderClient.Produce(\n\t\tcontext.Background(),\n\t\t&api.ProduceRequest{\n\t\t\tRecord: &api.Record{\n\t\t\t\tValue: []byte(\"foo\"),\n\t\t\t},\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\n\t// START: test_change\n\t// wait until replication has finished\n\ttime.Sleep(3 * time.Second)\n\n\t//START: leader_check\n\tconsumeResponse, err := leaderClient.Consume( // <label id=\"produce\" />\n\t\tcontext.Background(),\n\t\t&api.ConsumeRequest{\n\t\t\tOffset: produceResponse.Offset,\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(t, consumeResponse.Record.Value, []byte(\"foo\"))\n\n\tfollowerClient := client(t, agents[1], peerTLSConfig)\n\tconsumeResponse, err = followerClient.Consume( // <label id=\"follower\" />\n\t\tcontext.Background(),\n\t\t&api.ConsumeRequest{\n\t\t\tOffset: produceResponse.Offset,\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(t, consumeResponse.Record.Value, []byte(\"foo\"))\n\t// END: test_change\n}\n\n// START: client",
    "func client(\n\tt *testing.T,\n\tagent *agent.Agent,\n\ttlsConfig *tls.Config,\n) api.LogClient {\n\ttlsCreds := credentials.NewTLS(tlsConfig)\n\topts := []grpc.DialOption{\n\t\tgrpc.WithTransportCredentials(tlsCreds),\n\t}\n\trpcAddr, err := agent.Config.RPCAddr()\n\trequire.NoError(t, err)\n\t// START_HIGHLIGHT\n\tconn, err := grpc.Dial(fmt.Sprintf(\n\t\t\"%s:///%s\",\n\t\tloadbalance.Name,\n\t\trpcAddr,\n\t), opts...)\n\t// END_HIGHLIGHT\n\trequire.NoError(t, err)\n\tclient := api.NewLogClient(conn)\n\treturn client\n}\n\n// END: client",
    "func New(model, policy string) *Authorizer {\n\tenforcer := casbin.NewEnforcer(model, policy)\n\treturn &Authorizer{\n\t\tenforcer: enforcer,\n\t}\n}\n\ntype Authorizer struct {\n\tenforcer *casbin.Enforcer\n}",
    "func (a *Authorizer) Authorize(subject, object, action string) error {\n\tif !a.enforcer.Enforce(subject, object, action) {\n\t\tmsg := fmt.Sprintf(\n\t\t\t\"%s not permitted to %s to %s\",\n\t\t\tsubject,\n\t\t\taction,\n\t\t\tobject,\n\t\t)\n\t\tst := status.New(codes.PermissionDenied, msg)\n\t\treturn st.Err()\n\t}\n\treturn nil\n}",
    "func configFile(filename string) string {\n\tif dir := os.Getenv(\"CONFIG_DIR\"); dir != \"\" {\n\t\treturn filepath.Join(dir, filename)\n\t}\n\thomeDir, err := os.UserHomeDir()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn filepath.Join(homeDir, \".proglog\", filename)\n}\n\n// END: begin",
    "func SetupTLSConfig(cfg TLSConfig) (*tls.Config, error) {\n\tvar err error\n\ttlsConfig := &tls.Config{}\n\tif cfg.CertFile != \"\" && cfg.KeyFile != \"\" {\n\t\ttlsConfig.Certificates = make([]tls.Certificate, 1)\n\t\ttlsConfig.Certificates[0], err = tls.LoadX509KeyPair(\n\t\t\tcfg.CertFile,\n\t\t\tcfg.KeyFile,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif cfg.CAFile != \"\" {\n\t\tb, err := ioutil.ReadFile(cfg.CAFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tca := x509.NewCertPool()\n\t\tok := ca.AppendCertsFromPEM([]byte(b))\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\"failed to parse root certificate: %q\",\n\t\t\t\tcfg.CAFile,\n\t\t\t)\n\t\t}\n\t\tif cfg.Server {\n\t\t\ttlsConfig.ClientCAs = ca\n\t\t\ttlsConfig.ClientAuth = tls.RequireAndVerifyClientCert\n\t\t} else {\n\t\t\ttlsConfig.RootCAs = ca\n\t\t}\n\t\ttlsConfig.ServerName = cfg.ServerAddress\n\t}\n\treturn tlsConfig, nil\n}\n\n// END: func\n\n// START: type\ntype TLSConfig struct {\n\tCertFile      string\n\tKeyFile       string\n\tCAFile        string\n\tServerAddress string\n\tServer        bool\n}\n\n// END: type",
    "func New(handler Handler, config Config) (*Membership, error) {\n\tc := &Membership{\n\t\tConfig:  config,\n\t\thandler: handler,\n\t\tlogger:  zap.L().Named(\"membership\"),\n\t}\n\tif err := c.setupSerf(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n// END: start\n// START: setup\ntype Config struct {\n\tNodeName       string\n\tBindAddr       string\n\tTags           map[string]string\n\tStartJoinAddrs []string\n}",
    "func (m *Membership) setupSerf() (err error) {\n\taddr, err := net.ResolveTCPAddr(\"tcp\", m.BindAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconfig := serf.DefaultConfig()\n\tconfig.Init()\n\tconfig.MemberlistConfig.BindAddr = addr.IP.String()\n\tconfig.MemberlistConfig.BindPort = addr.Port\n\tm.events = make(chan serf.Event)\n\tconfig.EventCh = m.events\n\tconfig.Tags = m.Tags\n\tconfig.NodeName = m.Config.NodeName\n\tm.serf, err = serf.Create(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo m.eventHandler() //<label id=\"handlergoroutine\" />\n\tif m.StartJoinAddrs != nil {\n\t\t_, err = m.serf.Join(m.StartJoinAddrs, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// END: setup\n\n// START: handler\ntype Handler interface {\n\tJoin(name, addr string) error\n\tLeave(name string) error\n}\n\n// END: handler\n\n// START: event_handler",
    "func (m *Membership) eventHandler() {\n\tfor e := range m.events {\n\t\tswitch e.EventType() {\n\t\tcase serf.EventMemberJoin:\n\t\t\tfor _, member := range e.(serf.MemberEvent).Members {\n\t\t\t\tif m.isLocal(member) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tm.handleJoin(member)\n\t\t\t}\n\t\tcase serf.EventMemberLeave, serf.EventMemberFailed:\n\t\t\tfor _, member := range e.(serf.MemberEvent).Members {\n\t\t\t\tif m.isLocal(member) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tm.handleLeave(member)\n\t\t\t}\n\t\t}\n\t}\n}",
    "func (m *Membership) handleJoin(member serf.Member) {\n\tif err := m.handler.Join(\n\t\tmember.Name,\n\t\tmember.Tags[\"rpc_addr\"],\n\t); err != nil {\n\t\tm.logError(err, \"failed to join\", member)\n\t}\n}",
    "func (m *Membership) handleLeave(member serf.Member) {\n\tif err := m.handler.Leave(\n\t\tmember.Name,\n\t); err != nil {\n\t\tm.logError(err, \"failed to leave\", member)\n\t}\n}\n\n// END: event_handler\n\n// START: rest",
    "func (m *Membership) isLocal(member serf.Member) bool {\n\treturn m.serf.LocalMember().Name == member.Name\n}",
    "func (m *Membership) Members() []serf.Member {\n\treturn m.serf.Members()\n}",
    "func (m *Membership) Leave() error {\n\treturn m.serf.Leave()\n}\n\n// END: rest\n\n// START: log_error",
    "func (m *Membership) logError(err error, msg string, member serf.Member) {\n\tlog := m.logger.Error\n\tif err == raft.ErrNotLeader {\n\t\tlog = m.logger.Debug\n\t}\n\tlog(\n\t\tmsg,\n\t\tzap.Error(err),\n\t\tzap.String(\"name\", member.Name),\n\t\tzap.String(\"rpc_addr\", member.Tags[\"rpc_addr\"]),\n\t)\n}\n\n// END: log_error\n\n// END: rest",
    "func NewEncoder(w io.Writer) *Encoder {\n\tenc := &Encoder{}\n\tenc.gob = gob.NewEncoder(w)\n\treturn enc\n}",
    "func (enc *Encoder) Encode(e interface{}) error {\n\tcheckValue(e)\n\treturn enc.gob.Encode(e)\n}",
    "func (enc *Encoder) EncodeValue(value reflect.Value) error {\n\tcheckValue(value.Interface())\n\treturn enc.gob.EncodeValue(value)\n}\n\ntype Decoder struct {\n\tgob *gob.Decoder\n}",
    "func NewDecoder(r io.Reader) *Decoder {\n\tdec := &Decoder{}\n\tdec.gob = gob.NewDecoder(r)\n\treturn dec\n}",
    "func (dec *Decoder) Decode(e interface{}) error {\n\tcheckValue(e)\n\tcheckDefault(e)\n\treturn dec.gob.Decode(e)\n}",
    "func Register(value interface{}) {\n\tcheckValue(value)\n\tgob.Register(value)\n}",
    "func RegisterName(name string, value interface{}) {\n\tcheckValue(value)\n\tgob.RegisterName(name, value)\n}",
    "func checkValue(value interface{}) {\n\tcheckType(reflect.TypeOf(value))\n}",
    "func checkType(t reflect.Type) {\n\tkind := t.Kind()\n\n\tmu.Lock()\n\t// only complain once, and avoid recursion\n\tif checked == nil {\n\t\tchecked = map[reflect.Type]bool{}\n\t}\n\tif checked[t] {\n\t\tmu.Unlock()\n\t\treturn\n\t}\n\tchecked[t] = true\n\tmu.Unlock()\n\n\tswitch kind {\n\tcase reflect.Struct:\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\tf := t.Field(i)\n\t\t\truneCharacter, _ := utf8.DecodeRuneInString(f.Name)\n\t\t\tif unicode.IsUpper(runeCharacter) == false {\n\t\t\t\tfmt.Printf(\"mygob error: lower-case field %v of %v in RPC or persist/snapshot will break your Raft\\n\", f.Name, t.Name())\n\t\t\t\tmu.Lock()\n\t\t\t\terrorCount += 1\n\t\t\t\tmu.Unlock()\n\t\t\t}\n\t\t\tcheckType(f.Type)\n\t\t}\n\t\treturn\n\tcase reflect.Slice, reflect.Array, reflect.Ptr:\n\t\tcheckType(t.Elem())\n\t\treturn\n\tcase reflect.Map:\n\t\tcheckType(t.Elem())\n\t\tcheckType(t.Key())\n\t\treturn\n\tdefault:\n\t\treturn\n\t}\n}\n\n// warn if the value contains non-default values, as it would if one sent an RPC but the reply struct was already modified.\n// if the RPC reply contains default values, GOB won't overwrite the non-default value.",
    "func checkDefault(value interface{}) {\n\tif value == nil {\n\t\treturn\n\t}\n\tcheckDefault1(reflect.ValueOf(value), 1, \"\")\n}",
    "func checkDefault1(value reflect.Value, depth int, name string) {\n\tif depth > 3 {\n\t\treturn\n\t}\n\n\tt := value.Type()\n\tkind := t.Kind()\n\n\tswitch kind {\n\tcase reflect.Struct:\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\tvv := value.Field(i)\n\t\t\tname1 := t.Field(i).Name\n\t\t\tif name != \"\" {\n\t\t\t\tname1 = name + \".\" + name1\n\t\t\t}\n\t\t\tcheckDefault1(vv, depth+1, name1)\n\t\t}\n\t\treturn\n\tcase reflect.Ptr:\n\t\tif value.IsNil() {\n\t\t\treturn\n\t\t}\n\t\tcheckDefault1(value.Elem(), depth+1, name)\n\t\treturn\n\tcase reflect.Bool,\n\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\treflect.Uintptr, reflect.Float32, reflect.Float64,\n\t\treflect.String:\n\t\tif reflect.DeepEqual(reflect.Zero(t).Interface(), value.Interface()) == false {\n\t\t\tmu.Lock()\n\t\t\tif errorCount < 1 {\n\t\t\t\twhat := name\n\t\t\t\tif what == \"\" {\n\t\t\t\t\twhat = t.Name()\n\t\t\t\t}\n\t\t\t\t// this warning typically arises if code reuses the same RPC reply variable for multiple RPC calls,\n\t\t\t\t// or if code restores persisted state into variable that already have non-default values.\n\t\t\t\tfmt.Printf(\"mygob warning: Decoding into a non-default variable/field %v may not work\\n\",\n\t\t\t\t\twhat)\n\t\t\t}\n\t\t\terrorCount += 1\n\t\t\tmu.Unlock()\n\t\t}\n\t\treturn\n\t}\n}",
    "func (e *ClientEnd) Call(svcMeth string, args interface{}, reply interface{}) bool {\n\treq := reqMsg{}\n\treq.endname = e.endname\n\treq.svcMeth = svcMeth\n\treq.argsType = reflect.TypeOf(args)\n\treq.replyCh = make(chan replyMsg)\n\n\tqb := new(bytes.Buffer)\n\tqe := mygob.NewEncoder(qb)\n\tqe.Encode(args)\n\treq.args = qb.Bytes()\n\n\t// send the request\n\tselect {\n\tcase e.ch <- req:\n\t\t// the request has been sent\n\tcase <-e.done:\n\t\t// entire Network has been destroyed\n\t\treturn false\n\t}\n\n\t// wait for the reply\n\trep := <-req.replyCh\n\tif rep.ok {\n\t\trb := bytes.NewBuffer(rep.reply)\n\t\trd := mygob.NewDecoder(rb)\n\t\tif err := rd.Decode(reply); err != nil {\n\t\t\tlog.Fatalf(\"ClientEnd.Call(): decode reply: %v\\n\", err)\n\t\t}\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\ntype Network struct {\n\tmu             sync.Mutex\n\treliable       bool\n\tlongDelays     bool                        // pause a long time on send on disabled connection\n\tlongReordering bool                        // sometimes delay replies a long time\n\tends           map[interface{}]*ClientEnd  // ends, by name\n\tenabled        map[interface{}]bool        // by end name\n\tservers        map[interface{}]*Server     // servers, by name\n\tconnections    map[interface{}]interface{} // endname -> servername\n\tendCh          chan reqMsg\n\tdone           chan struct{} // closed when Network is cleaned up\n\tcount          int32         // total RPC count, for statistics\n\tbytes          int64         // total bytes send, for statistics\n}",
    "func MakeNetwork() *Network {\n\trn := &Network{}\n\trn.reliable = true\n\trn.ends = map[interface{}]*ClientEnd{}\n\trn.enabled = map[interface{}]bool{}\n\trn.servers = map[interface{}]*Server{}\n\trn.connections = map[interface{}](interface{}){}\n\trn.endCh = make(chan reqMsg)\n\trn.done = make(chan struct{})\n\n\t// single goroutine to handle all ClientEnd.Call()s\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase xreq := <-rn.endCh:\n\t\t\t\tatomic.AddInt32(&rn.count, 1)\n\t\t\t\tatomic.AddInt64(&rn.bytes, int64(len(xreq.args)))\n\t\t\t\tgo rn.processReq(xreq)\n\t\t\tcase <-rn.done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn rn\n}",
    "func (rn *Network) Cleanup() {\n\tclose(rn.done)\n}",
    "func (rn *Network) Reliable(yes bool) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\trn.reliable = yes\n}",
    "func (rn *Network) LongReordering(yes bool) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\trn.longReordering = yes\n}",
    "func (rn *Network) LongDelays(yes bool) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\trn.longDelays = yes\n}",
    "func (rn *Network) readEndnameInfo(endname interface{}) (enabled bool,\n\tservername interface{}, server *Server, reliable bool, longreordering bool,\n) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\tenabled = rn.enabled[endname]\n\tservername = rn.connections[endname]\n\tif servername != nil {\n\t\tserver = rn.servers[servername]\n\t}\n\treliable = rn.reliable\n\tlongreordering = rn.longReordering\n\treturn\n}",
    "func (rn *Network) isServerDead(endname interface{}, servername interface{}, server *Server) bool {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\tif rn.enabled[endname] == false || rn.servers[servername] != server {\n\t\treturn true\n\t}\n\treturn false\n}",
    "func (rn *Network) processReq(req reqMsg) {\n\tenabled, servername, server, reliable, longReordering := rn.readEndnameInfo(req.endname)\n\n\tif enabled && servername != nil && server != nil {\n\t\tif reliable == false {\n\t\t\t// short delay\n\t\t\tms := (rand.Int() % 27)\n\t\t\ttime.Sleep(time.Duration(ms) * time.Millisecond)\n\t\t}\n\n\t\tif reliable == false && (rand.Int()%1000) < 100 {\n\t\t\t// drop the request, return as if timeout\n\t\t\treq.replyCh <- replyMsg{false, nil}\n\t\t\treturn\n\t\t}\n\n\t\t// execute the request (call the RPC handler).\n\t\t// in a separate thread so that we can periodically check\n\t\t// if the server has been killed and the RPC should get a failure reply.\n\t\tech := make(chan replyMsg)\n\t\tgo func() {\n\t\t\tr := server.dispatch(req)\n\t\t\tech <- r\n\t\t}()\n\n\t\t// wait for handler to return,\n\t\t// but stop waiting if DeleteServer() has been called, and return an error.\n\t\tvar reply replyMsg\n\t\treplyOK := false\n\t\tserverDead := false\n\t\tfor replyOK == false && serverDead == false {\n\t\t\tselect {\n\t\t\tcase reply = <-ech:\n\t\t\t\treplyOK = true\n\t\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\t\tserverDead = rn.isServerDead(req.endname, servername, server)\n\t\t\t\tif serverDead {\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\t<-ech // drain channel to let the goroutine created earlier terminate\n\t\t\t\t\t}()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// do not reply if DeleteServer() has been called, i.e.\n\t\t// the server has been killed. this is needed to avoid situation in which a client gets a positive reply\n\t\t// to an Append, but the server persisted the update into the old Persister.\n\t\t// config.go is careful to call DeleteServer() before superseding the Persister.\n\t\tserverDead = rn.isServerDead(req.endname, servername, server)\n\n\t\tif replyOK == false || serverDead == true {\n\t\t\t// server was killed while we were waiting; return error.\n\t\t\treq.replyCh <- replyMsg{false, nil}\n\t\t} else if reliable == false && (rand.Int()%1000) < 100 {\n\t\t\t// drop the reply, return as if timeout\n\t\t\treq.replyCh <- replyMsg{false, nil}\n\t\t} else if longReordering == true && rand.Intn(900) < 600 {\n\t\t\t// delay the response for a while\n\t\t\tms := 200 + rand.Intn(1+rand.Intn(2000))\n\t\t\t// Russ points out that this timer arrangement will decrease the number of goroutines,\n\t\t\t// so that the race detector is less likely to get upset.\n\t\t\ttime.AfterFunc(time.Duration(ms)*time.Millisecond, func() {\n\t\t\t\tatomic.AddInt64(&rn.bytes, int64(len(reply.reply)))\n\t\t\t\treq.replyCh <- reply\n\t\t\t})\n\t\t} else {\n\t\t\tatomic.AddInt64(&rn.bytes, int64(len(reply.reply)))\n\t\t\treq.replyCh <- reply\n\t\t}\n\t} else {\n\t\t// simulate no reply and eventual timeout.\n\t\tms := 0\n\t\tif rn.longDelays {\n\t\t\tms = (rand.Int() % 7000)\n\t\t} else {\n\t\t\tms = (rand.Int() % 100)\n\t\t}\n\t\ttime.AfterFunc(time.Duration(ms)*time.Millisecond, func() {\n\t\t\treq.replyCh <- replyMsg{false, nil}\n\t\t})\n\t}\n\n}\n\n// create a client end-point.\n// start the thread that listens and delivers.",
    "func (rn *Network) MakeEnd(endname interface{}) *ClientEnd {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\tif _, ok := rn.ends[endname]; ok {\n\t\tlog.Fatalf(\"MakeEnd: %v already exists\\n\", endname)\n\t}\n\n\te := &ClientEnd{}\n\te.endname = endname\n\te.ch = rn.endCh\n\te.done = rn.done\n\trn.ends[endname] = e\n\trn.enabled[endname] = false\n\trn.connections[endname] = nil\n\n\treturn e\n}",
    "func (rn *Network) AddServer(servername interface{}, rs *Server) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\trn.servers[servername] = rs\n}",
    "func (rn *Network) DeleteServer(servername interface{}) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\trn.servers[servername] = nil\n}\n\n// connect a ClientEnd to a server.\n// a ClientEnd can only be connected once in its lifetime.",
    "func (rn *Network) Connect(endname interface{}, servername interface{}) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\trn.connections[endname] = servername\n}\n\n// enable/disable a ClientEnd.",
    "func (rn *Network) Enable(endname interface{}, enabled bool) {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\trn.enabled[endname] = enabled\n}\n\n// get a server's count of incoming RPCs.",
    "func (rn *Network) GetCount(servername interface{}) int {\n\trn.mu.Lock()\n\tdefer rn.mu.Unlock()\n\n\tsvr := rn.servers[servername]\n\treturn svr.GetCount()\n}",
    "func (rn *Network) GetTotalCount() int {\n\tx := atomic.LoadInt32(&rn.count)\n\treturn int(x)\n}",
    "func (rn *Network) GetTotalBytes() int64 {\n\tx := atomic.LoadInt64(&rn.bytes)\n\treturn x\n}\n\n// a server is a collection of services, all sharing the same myrpc dispatcher.\n// so that e.g. both a Raft and a k/v server can listen to the same myrpc endpoint.\ntype Server struct {\n\tmu       sync.Mutex\n\tservices map[string]*Service\n\tcount    int // incoming RPCs\n}",
    "func MakeServer() *Server {\n\trs := &Server{}\n\trs.services = map[string]*Service{}\n\treturn rs\n}",
    "func (rs *Server) AddService(svc *Service) {\n\trs.mu.Lock()\n\tdefer rs.mu.Unlock()\n\trs.services[svc.name] = svc\n}",
    "func (rs *Server) dispatch(req reqMsg) replyMsg {\n\trs.mu.Lock()\n\n\trs.count += 1\n\n\t// split Raft.AppendEntries into service and method\n\tdot := strings.LastIndex(req.svcMeth, \".\")\n\tserviceName := req.svcMeth[:dot]\n\tmethodName := req.svcMeth[dot+1:]\n\n\tservice, ok := rs.services[serviceName]\n\n\trs.mu.Unlock()\n\n\tif ok {\n\t\treturn service.dispatch(methodName, req)\n\t} else {\n\t\tchoices := []string{}\n\t\tfor k, _ := range rs.services {\n\t\t\tchoices = append(choices, k)\n\t\t}\n\t\tlog.Fatalf(\"myrpc.Server.dispatch(): unknown service %v in %v.%v; expecting one of %v\\n\",\n\t\t\tserviceName, serviceName, methodName, choices)\n\t\treturn replyMsg{false, nil}\n\t}\n}",
    "func (rs *Server) GetCount() int {\n\trs.mu.Lock()\n\tdefer rs.mu.Unlock()\n\treturn rs.count\n}\n\n// an object with methods that can be called via RPC.\n// a single server may have more than one Service.\ntype Service struct {\n\tname    string\n\trcvr    reflect.Value\n\ttyp     reflect.Type\n\tmethods map[string]reflect.Method\n}",
    "func MakeService(rcvr interface{}) *Service {\n\tsvc := &Service{}\n\tsvc.typ = reflect.TypeOf(rcvr)\n\tsvc.rcvr = reflect.ValueOf(rcvr)\n\tsvc.name = reflect.Indirect(svc.rcvr).Type().Name()\n\tsvc.methods = map[string]reflect.Method{}\n\n\tfor m := 0; m < svc.typ.NumMethod(); m++ {\n\t\tmethod := svc.typ.Method(m)\n\t\tmtype := method.Type\n\t\tmname := method.Name\n\n\t\tif method.PkgPath != \"\" ||\n\t\t\tmtype.NumIn() != 3 ||\n\t\t\tmtype.In(2).Kind() != reflect.Ptr ||\n\t\t\tmtype.NumOut() != 0 {\n\t\t} else {\n\t\t\tsvc.methods[mname] = method\n\t\t}\n\t}\n\n\treturn svc\n}",
    "func (svc *Service) dispatch(methname string, req reqMsg) replyMsg {\n\tif method, ok := svc.methods[methname]; ok {\n\t\targs := reflect.New(req.argsType)\n\n\t\t// decode the argument\n\t\tab := bytes.NewBuffer(req.args)\n\t\tad := gob.NewDecoder(ab)\n\t\tad.Decode(args.Interface())\n\n\t\t// allocate space for the reply\n\t\treplyType := method.Type.In(2)\n\t\treplyType = replyType.Elem()\n\t\treplyv := reflect.New(replyType)\n\n\t\t// call the method\n\t\tfunction := method.Func\n\t\tfunction.Call([]reflect.Value{svc.rcvr, args.Elem(), replyv})\n\n\t\t// encode the reply\n\t\trb := new(bytes.Buffer)\n\t\tre := gob.NewEncoder(rb)\n\t\tre.EncodeValue(replyv)\n\n\t\treturn replyMsg{true, rb.Bytes()}\n\t} else {\n\t\tchoices := []string{}\n\t\tfor k, _ := range svc.methods {\n\t\t\tchoices = append(choices, k)\n\t\t}\n\t\tlog.Fatalf(\"myrpc.Service.dispatch(): unknown method %v in %v; expecting one of %v\\n\",\n\t\t\tmethname, req.svcMeth, choices)\n\t\treturn replyMsg{false, nil}\n\t}\n}",
    "func (rf *Raft) broadcastAppendEntries() {\n\tif rf.state != leader {\n\t\treturn\n\t}\n\n\tfor peerIdx := range rf.peers {\n\t\tif peerIdx == rf.me {\n\t\t\tcontinue\n\t\t}\n\n\t\tgo rf.broadcastAppendEntryToServer(peerIdx)\n\t}\n}",
    "func (rf *Raft) broadcastAppendEntryToServer(server int) {\n\trf.mu.Lock()\n\n\tif rf.state != leader {\n\t\trf.mu.Unlock()\n\t\treturn\n\t}\n\n\tfollowerNextIdx := rf.nextIndex[server]\n\tif followerNextIdx < 1 {\n\t\tfollowerNextIdx = 1\n\t}\n\n\targs := &AppendEntriesArgs{\n\t\tTerm:         rf.currentTerm,\n\t\tLeaderId:     rf.me,\n\t\tPrevLogIndex: followerNextIdx - 1,\n\t\tPrevLogTerm:  rf.logs[followerNextIdx-1].Term,\n\t\tLeaderCommit: rf.commitIndex,\n\t}\n\n\tentries := make([]LogEntry, len(rf.logs[followerNextIdx:]))\n\tcopy(entries, rf.logs[followerNextIdx:])\n\targs.Entries = entries\n\n\trf.mu.Unlock()\n\n\trf.sendAppendEntries(server, args, &AppendEntriesReply{})\n}",
    "func (rf *Raft) sendAppendEntries(server int, args *AppendEntriesArgs, reply *AppendEntriesReply) {\n\tok := rf.peers[server].Call(\"Raft.AppendEntries\", args, reply)\n\n\tif !ok {\n\t\treturn\n\t}\n\n\trf.mu.Lock()\n\n\tdoRetry := false\n\n\t// if server is no longer a leader or term has already changed, return\n\tif rf.state != leader || rf.currentTerm != args.Term || rf.currentTerm > reply.Term {\n\t\trf.mu.Unlock()\n\t\treturn\n\t}\n\n\t// receiving server's term was higher, so step down to follower, update term and return\n\tif reply.Term > rf.currentTerm {\n\t\trf.state = follower\n\t\trf.updateTerm(reply.Term)\n\t\trf.setElectionTimer()\n\t\trf.sendToChannel(rf.stepDownCh, true)\n\t\trf.mu.Unlock()\n\t\treturn\n\t}\n\n\tif reply.Success {\n\t\trf.matchIndex[server] = max(rf.matchIndex[server], args.PrevLogIndex+len(args.Entries))\n\t\trf.nextIndex[server] = rf.matchIndex[server] + 1\n\t} else {\n\t\tif rf.nextIndex[server] > 1 {\n\t\t\trf.nextIndex[server] -= 1\n\t\t}\n\t\tdoRetry = true\n\t}\n\n\t// if there exists an N such that N > commitIndex, a majority of matchIndex[i] \u2265 N, and log[N].term == currentTerm:\n\t// set commitIndex = N\n\tfor N := rf.getLastLogIndex(); N > rf.commitIndex; N-- {\n\t\tif rf.logs[N].Term != rf.currentTerm {\n\t\t\tcontinue\n\t\t}\n\n\t\tcount := 1\n\t\tfor i := 0; i < len(rf.peers); i++ {\n\t\t\tif i != rf.me && rf.matchIndex[i] >= N {\n\t\t\t\tcount += 1\n\t\t\t}\n\t\t}\n\n\t\tif count > len(rf.peers)/2 {\n\t\t\trf.commitIndex = N\n\t\t\tgo rf.applyLogs()\n\t\t\tbreak\n\t\t}\n\t}\n\n\trf.persist()\n\trf.mu.Unlock()\n\n\tif doRetry {\n\t\trf.broadcastAppendEntryToServer(server)\n\t}\n}",
    "func randstring(n int) string {\n\tb := make([]byte, 2*n)\n\tcrand.Read(b)\n\ts := base64.URLEncoding.EncodeToString(b)\n\treturn s[0:n]\n}",
    "func makeSeed() int64 {\n\tmax := big.NewInt(int64(1) << 62)\n\tbigx, _ := crand.Int(crand.Reader, max)\n\tx := bigx.Int64()\n\treturn x\n}\n\ntype config struct {\n\tmu        sync.Mutex\n\tt         *testing.T\n\tnet       *myrpc.Network\n\tn         int\n\trafts     []*Raft\n\tapplyErr  []string // from apply channel readers\n\tconnected []bool   // whether each server is on the net\n\tsaved     []*Persister\n\tendnames  [][]string            // the port file names each sends to\n\tlogs      []map[int]interface{} // copy of each server's committed entries\n\tstart     time.Time             // time at which make_config() was called\n\t// begin()/end() statistics\n\tt0        time.Time // time at which test_test.go called cfg.begin()\n\trpcs0     int       // rpcTotal() at start of test\n\tcmds0     int       // number of agreements\n\tbytes0    int64\n\tmaxIndex  int\n\tmaxIndex0 int\n}\n\nvar ncpu_once sync.Once",
    "func make_config(t *testing.T, n int, unreliable bool) *config {\n\tncpu_once.Do(func() {\n\t\tif runtime.NumCPU() < 2 {\n\t\t\tfmt.Printf(\"warning: only one CPU, which may conceal locking bugs\\n\")\n\t\t}\n\t\trand.Seed(makeSeed())\n\t})\n\truntime.GOMAXPROCS(4)\n\tcfg := &config{}\n\tcfg.t = t\n\tcfg.net = myrpc.MakeNetwork()\n\tcfg.n = n\n\tcfg.applyErr = make([]string, cfg.n)\n\tcfg.rafts = make([]*Raft, cfg.n)\n\tcfg.connected = make([]bool, cfg.n)\n\tcfg.saved = make([]*Persister, cfg.n)\n\tcfg.endnames = make([][]string, cfg.n)\n\tcfg.logs = make([]map[int]interface{}, cfg.n)\n\tcfg.start = time.Now()\n\n\tcfg.setunreliable(unreliable)\n\n\tcfg.net.LongDelays(true)\n\n\t// create a full set of Rafts.\n\tfor i := 0; i < cfg.n; i++ {\n\t\tcfg.logs[i] = map[int]interface{}{}\n\t\tcfg.start1(i)\n\t}\n\n\t// connect everyone\n\tfor i := 0; i < cfg.n; i++ {\n\t\tcfg.connect(i)\n\t}\n\n\treturn cfg\n}\n\n// shut down a Raft server but save its persistent state.",
    "func (cfg *config) crash1(i int) {\n\tcfg.disconnect(i)\n\tcfg.net.DeleteServer(i) // disable client connections to the server.\n\n\tcfg.mu.Lock()\n\tdefer cfg.mu.Unlock()\n\n\tif cfg.saved[i] != nil {\n\t\tcfg.saved[i] = cfg.saved[i].Copy()\n\t}\n\n\trf := cfg.rafts[i]\n\tif rf != nil {\n\t\tcfg.mu.Unlock()\n\t\trf.Kill()\n\t\tcfg.mu.Lock()\n\t\tcfg.rafts[i] = nil\n\t}\n\n\tif cfg.saved[i] != nil {\n\t\traftlog := cfg.saved[i].ReadRaftState()\n\t\tcfg.saved[i] = &Persister{}\n\t\tcfg.saved[i].SaveRaftState(raftlog)\n\t}\n}\n\n// start or re-start a Raft.\n// if one already exists, \"kill\" it first.\n// allocate new outgoing port file names, and a new\n// state persister, to isolate previous instance of\n// this server. since we cannot really kill it.",
    "func (cfg *config) start1(i int) {\n\tcfg.crash1(i)\n\n\t// a fresh set of outgoing ClientEnd names.\n\t// so that old crashed instance's ClientEnds can't send.\n\tcfg.endnames[i] = make([]string, cfg.n)\n\tfor j := 0; j < cfg.n; j++ {\n\t\tcfg.endnames[i][j] = randstring(20)\n\t}\n\n\t// a fresh set of ClientEnds.\n\tends := make([]*myrpc.ClientEnd, cfg.n)\n\tfor j := 0; j < cfg.n; j++ {\n\t\tends[j] = cfg.net.MakeEnd(cfg.endnames[i][j])\n\t\tcfg.net.Connect(cfg.endnames[i][j], j)\n\t}\n\n\tcfg.mu.Lock()\n\n\tif cfg.saved[i] != nil {\n\t\tcfg.saved[i] = cfg.saved[i].Copy()\n\t} else {\n\t\tcfg.saved[i] = MakePersister()\n\t}\n\n\tcfg.mu.Unlock()\n\n\t// listen to messages from Raft indicating newly committed messages.\n\tapplyCh := make(chan ApplyMsg)\n\tgo func() {\n\t\tfor m := range applyCh {\n\t\t\terr_msg := \"\"\n\t\t\tif m.CommandValid == false {\n\t\t\t\t// ignore other types of ApplyMsg\n\t\t\t} else {\n\t\t\t\tv := m.Command\n\t\t\t\tcfg.mu.Lock()\n\t\t\t\tfor j := 0; j < len(cfg.logs); j++ {\n\t\t\t\t\tif old, oldok := cfg.logs[j][m.CommandIndex]; oldok && old != v {\n\t\t\t\t\t\t// some server has already committed a different value for this entry!\n\t\t\t\t\t\terr_msg = fmt.Sprintf(\"commit index=%v server=%v %v != server=%v %v\",\n\t\t\t\t\t\t\tm.CommandIndex, i, m.Command, j, old)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_, prevok := cfg.logs[i][m.CommandIndex-1]\n\t\t\t\tcfg.logs[i][m.CommandIndex] = v\n\t\t\t\tif m.CommandIndex > cfg.maxIndex {\n\t\t\t\t\tcfg.maxIndex = m.CommandIndex\n\t\t\t\t}\n\t\t\t\tcfg.mu.Unlock()\n\n\t\t\t\tif m.CommandIndex > 1 && prevok == false {\n\t\t\t\t\terr_msg = fmt.Sprintf(\"server %v apply out of order %v\", i, m.CommandIndex)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err_msg != \"\" {\n\t\t\t\tlog.Fatalf(\"apply error: %v\\n\", err_msg)\n\t\t\t\tcfg.applyErr[i] = err_msg\n\t\t\t}\n\t\t}\n\t}()\n\n\trf := Make(ends, i, cfg.saved[i], applyCh)\n\n\tcfg.mu.Lock()\n\tcfg.rafts[i] = rf\n\tcfg.mu.Unlock()\n\n\tsvc := myrpc.MakeService(rf)\n\tsrv := myrpc.MakeServer()\n\tsrv.AddService(svc)\n\tcfg.net.AddServer(i, srv)\n}",
    "func (cfg *config) checkTimeout() {\n\tif !cfg.t.Failed() && time.Since(cfg.start) > 120*time.Second {\n\t\tcfg.t.Fatal(\"test took longer than 120 seconds\")\n\t}\n}",
    "func (cfg *config) cleanup() {\n\tfor i := 0; i < len(cfg.rafts); i++ {\n\t\tif cfg.rafts[i] != nil {\n\t\t\tcfg.rafts[i].Kill()\n\t\t}\n\t}\n\tcfg.net.Cleanup()\n\tcfg.checkTimeout()\n}\n\n// attach server i to the net.",
    "func (cfg *config) connect(i int) {\n\tcfg.connected[i] = true\n\n\t// outgoing ClientEnds\n\tfor j := 0; j < cfg.n; j++ {\n\t\tif cfg.connected[j] {\n\t\t\tendname := cfg.endnames[i][j]\n\t\t\tcfg.net.Enable(endname, true)\n\t\t}\n\t}\n\n\t// incoming ClientEnds\n\tfor j := 0; j < cfg.n; j++ {\n\t\tif cfg.connected[j] {\n\t\t\tendname := cfg.endnames[j][i]\n\t\t\tcfg.net.Enable(endname, true)\n\t\t}\n\t}\n}\n\n// detach server i from the net.",
    "func (cfg *config) disconnect(i int) {\n\tcfg.connected[i] = false\n\n\t// outgoing ClientEnds\n\tfor j := 0; j < cfg.n; j++ {\n\t\tif cfg.endnames[i] != nil {\n\t\t\tendname := cfg.endnames[i][j]\n\t\t\tcfg.net.Enable(endname, false)\n\t\t}\n\t}\n\n\t// incoming ClientEnds\n\tfor j := 0; j < cfg.n; j++ {\n\t\tif cfg.endnames[j] != nil {\n\t\t\tendname := cfg.endnames[j][i]\n\t\t\tcfg.net.Enable(endname, false)\n\t\t}\n\t}\n}",
    "func (cfg *config) rpcCount(server int) int {\n\treturn cfg.net.GetCount(server)\n}",
    "func (cfg *config) rpcTotal() int {\n\treturn cfg.net.GetTotalCount()\n}",
    "func (cfg *config) setunreliable(unrel bool) {\n\tcfg.net.Reliable(!unrel)\n}",
    "func (cfg *config) bytesTotal() int64 {\n\treturn cfg.net.GetTotalBytes()\n}",
    "func (cfg *config) setlongreordering(longrel bool) {\n\tcfg.net.LongReordering(longrel)\n}\n\n// check that there's exactly one leader.\n// try a few times in case re-elections are needed.",
    "func (cfg *config) checkOneLeader() int {\n\tfor iters := 0; iters < 10; iters++ {\n\t\tms := 450 + (rand.Int63() % 100)\n\t\ttime.Sleep(time.Duration(ms) * time.Millisecond)\n\n\t\tleaders := make(map[int][]int)\n\t\tfor i := 0; i < cfg.n; i++ {\n\t\t\tif cfg.connected[i] {\n\t\t\t\tif term, leader := cfg.rafts[i].GetState(); leader {\n\t\t\t\t\tleaders[term] = append(leaders[term], i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlastTermWithLeader := -1\n\t\tfor term, leaders := range leaders {\n\t\t\tif len(leaders) > 1 {\n\t\t\t\tcfg.t.Fatalf(\"term %d has %d (>1) leaders\", term, len(leaders))\n\t\t\t}\n\t\t\tif term > lastTermWithLeader {\n\t\t\t\tlastTermWithLeader = term\n\t\t\t}\n\t\t}\n\n\t\tif len(leaders) != 0 {\n\t\t\treturn leaders[lastTermWithLeader][0]\n\t\t}\n\t}\n\tcfg.t.Fatalf(\"expected one leader, got none\")\n\treturn -1\n}\n\n// check that everyone agrees on the term.",
    "func (cfg *config) checkTerms() int {\n\tterm := -1\n\tfor i := 0; i < cfg.n; i++ {\n\t\tif cfg.connected[i] {\n\t\t\txterm, _ := cfg.rafts[i].GetState()\n\t\t\tif term == -1 {\n\t\t\t\tterm = xterm\n\t\t\t} else if term != xterm {\n\t\t\t\tcfg.t.Fatalf(\"servers disagree on term\")\n\t\t\t}\n\t\t}\n\t}\n\treturn term\n}\n\n// check that there's no leader",
    "func (cfg *config) checkNoLeader() {\n\tfor i := 0; i < cfg.n; i++ {\n\t\tif cfg.connected[i] {\n\t\t\t_, is_leader := cfg.rafts[i].GetState()\n\t\t\tif is_leader {\n\t\t\t\tcfg.t.Fatalf(\"expected no leader, but %v claims to be leader\", i)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// how many servers think a log entry is committed?",
    "func (cfg *config) nCommitted(index int) (int, interface{}) {\n\tcount := 0\n\tvar cmd interface{} = nil\n\tfor i := 0; i < len(cfg.rafts); i++ {\n\t\tif cfg.applyErr[i] != \"\" {\n\t\t\tcfg.t.Fatal(cfg.applyErr[i])\n\t\t}\n\n\t\tcfg.mu.Lock()\n\t\tcmd1, ok := cfg.logs[i][index]\n\t\tcfg.mu.Unlock()\n\n\t\tif ok {\n\t\t\tif count > 0 && cmd != cmd1 {\n\t\t\t\tcfg.t.Fatalf(\"committed values do not match: index %v, %v, %v\\n\",\n\t\t\t\t\tindex, cmd, cmd1)\n\t\t\t}\n\t\t\tcount += 1\n\t\t\tcmd = cmd1\n\t\t}\n\t}\n\treturn count, cmd\n}\n\n// wait for at least n servers to commit.\n// but don't wait forever.",
    "func (cfg *config) wait(index int, n int, startTerm int) interface{} {\n\tto := 10 * time.Millisecond\n\tfor iters := 0; iters < 30; iters++ {\n\t\tnd, _ := cfg.nCommitted(index)\n\t\tif nd >= n {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(to)\n\t\tif to < time.Second {\n\t\t\tto *= 2\n\t\t}\n\t\tif startTerm > -1 {\n\t\t\tfor _, r := range cfg.rafts {\n\t\t\t\tif t, _ := r.GetState(); t > startTerm {\n\t\t\t\t\t// someone has moved on\n\t\t\t\t\t// can no longer guarantee that we'll \"win\"\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnd, cmd := cfg.nCommitted(index)\n\tif nd < n {\n\t\tcfg.t.Fatalf(\"only %d decided for index %d; wanted %d\\n\",\n\t\t\tnd, index, n)\n\t}\n\treturn cmd\n}\n\n// do a complete agreement.\n// it might choose the wrong leader initially,\n// and have to re-submit after giving up.\n// entirely gives up after about 10 seconds.\n// indirectly checks that the servers agree on the\n// same value, since nCommitted() checks this,\n// as do the threads that read from applyCh.\n// returns index.\n// if retry==true, may submit the command multiple\n// times, in case a leader fails just after Start().\n// if retry==false, calls Start() only once, in order\n// to simplify the early Lab 2B tests.",
    "func (cfg *config) one(cmd interface{}, expectedServers int, retry bool) int {\n\tt0 := time.Now()\n\tstarts := 0\n\n\tfor time.Since(t0).Seconds() < 10 {\n\t\t// try all the servers, maybe one is the leader.\n\t\tindex := -1\n\t\tfor si := 0; si < cfg.n; si++ {\n\t\t\tstarts = (starts + 1) % cfg.n\n\t\t\tvar rf *Raft\n\t\t\tcfg.mu.Lock()\n\t\t\tif cfg.connected[starts] {\n\t\t\t\trf = cfg.rafts[starts]\n\t\t\t}\n\t\t\tcfg.mu.Unlock()\n\t\t\tif rf != nil {\n\t\t\t\tindex1, _, ok := rf.Start(cmd)\n\t\t\t\tif ok {\n\t\t\t\t\tindex = index1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif index != -1 {\n\t\t\t// somebody claimed to be the leader and to have\n\t\t\t// submitted our command; wait a while for agreement.\n\t\t\tt1 := time.Now()\n\t\t\tfor time.Since(t1).Seconds() < 2 {\n\t\t\t\tnd, cmd1 := cfg.nCommitted(index)\n\t\t\t\t//fmt.Println(\"servers commited:\", nd)\n\t\t\t\t//fmt.Println(\"value\", cmd1)\n\t\t\t\tif nd > 0 && nd >= expectedServers {\n\t\t\t\t\t// committed\n\t\t\t\t\tif cmd1 == cmd {\n\t\t\t\t\t\t// and it was the command we submitted.\n\t\t\t\t\t\treturn index\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t}\n\t\t\tif retry == false {\n\t\t\t\tcfg.t.Fatalf(\"one(%v) failed to reach agreement\", cmd)\n\t\t\t}\n\t\t} else {\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n\tcfg.t.Fatalf(\"one(%v) failed to reach agreement\", cmd)\n\treturn -1\n}\n\n// start a Test.\n// print the Test message.\n// e.g. cfg.begin(\"Test (2B): RPC counts aren't too high\")",
    "func (cfg *config) begin(description string) {\n\tfmt.Printf(\"%s ...\\n\", description)\n\tcfg.t0 = time.Now()\n\tcfg.rpcs0 = cfg.rpcTotal()\n\tcfg.bytes0 = cfg.bytesTotal()\n\tcfg.cmds0 = 0\n\tcfg.maxIndex0 = cfg.maxIndex\n}\n\n// end a Test -- the fact that we got here means there\n// was no failure.\n// print the Passed message,\n// and some performance numbers.",
    "func (cfg *config) end() {\n\tcfg.checkTimeout()\n\tif cfg.t.Failed() == false {\n\t\tcfg.mu.Lock()\n\t\tt := time.Since(cfg.t0).Seconds()       // real time\n\t\tnpeers := cfg.n                         // number of Raft peers\n\t\tnrpc := cfg.rpcTotal() - cfg.rpcs0      // number of RPC sends\n\t\tnbytes := cfg.bytesTotal() - cfg.bytes0 // number of bytes\n\t\tncmds := cfg.maxIndex - cfg.maxIndex0   // number of Raft agreements reported\n\t\tcfg.mu.Unlock()\n\n\t\tfmt.Println(\"\\n... \u2705Passed ...\")\n\t\tfmt.Printf(\"t=%.1f  peers=%d  rpcs=%d  bytes=%d  cmds=%d\\n\",\n\t\t\tt, npeers, nrpc, nbytes, ncmds)\n\t}\n}",
    "func (rf *Raft) startElection() {\n\tif rf.state != candidate {\n\t\treturn\n\t}\n\n\targs := &RequestVoteArgs{\n\t\tTerm:         rf.currentTerm,\n\t\tCandidateId:  rf.me,\n\t\tLastLogIndex: rf.getLastLogIndex(),\n\t\tLastLogTerm:  rf.getLastLogTerm(),\n\t}\n\n\tfor peerIdx := range rf.peers {\n\t\tif peerIdx != rf.me {\n\t\t\tgo rf.sendRequestVote(peerIdx, args, &RequestVoteReply{})\n\t\t}\n\t}\n}\n\n// Example code to send a RequestVote RPC to a server.\n// server is the index of the target server in rf.peers[].\n// args is the RequestVoteArgs argument.\n// reply is passed by caller and filled by the receiving server.\n\n// The myrpc package simulates a lossy network, in which servers may be unreachable, and in which requests and replies may be lost.\n// Call() sends a request and waits for a reply. If a reply arrives within a timeout interval, Call() returns true;\n// Otherwise Call() returns false.\n// Thus Call() may not return for a while.\n// A false return can be caused by a dead server, a live server that can't be reached, a lost request, or a lost reply.\n//\n// Call() is guaranteed to return (perhaps after a delay) *except* if the handler function on the server side does not return.\n// Thus, there is no need to implement your own timeouts around Call().\n//\n// Look at the comments in ../myrpc/rpc.go for more details.",
    "func (rf *Raft) sendRequestVote(server int, args *RequestVoteArgs, reply *RequestVoteReply) {\n\tok := rf.peers[server].Call(\"Raft.RequestVote\", args, reply)\n\n\tif !ok {\n\t\treturn\n\t}\n\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\n\t// if server is no longer a candidate or term has already changed, return\n\tif rf.state != candidate || rf.currentTerm != args.Term || rf.currentTerm > reply.Term {\n\t\treturn\n\t}\n\n\t// receiving server's term was higher, so step down to follower, update term and return\n\tif reply.Term > rf.currentTerm {\n\t\trf.state = follower\n\t\trf.updateTerm(reply.Term)\n\t\trf.setElectionTimer()\n\t\trf.sendToChannel(rf.stepDownCh, true)\n\t\treturn\n\t}\n\n\tif reply.VoteGranted {\n\t\trf.voteCount += 1\n\t\tif rf.voteCount == len(rf.peers)/2+1 { // only send when exactly majority votes received\n\t\t\trf.sendToChannel(rf.winElectionCh, true)\n\t\t}\n\t}\n}",
    "func (rf *Raft) setElectionTimer() {\n\trf.electionTimeout = rand.Intn(electionTimeoutMax-electionTimeoutMin) + electionTimeoutMin\n}",
    "func MakePersister() *Persister {\n\treturn &Persister{}\n}",
    "func (ps *Persister) Copy() *Persister {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\tnp := MakePersister()\n\tnp.raftstate = ps.raftstate\n\tnp.snapshot = ps.snapshot\n\treturn np\n}",
    "func (ps *Persister) SaveRaftState(state []byte) {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\tps.raftstate = state\n}",
    "func (ps *Persister) ReadRaftState() []byte {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\treturn ps.raftstate\n}",
    "func (ps *Persister) RaftStateSize() int {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\treturn len(ps.raftstate)\n}",
    "func (ps *Persister) SaveStateAndSnapshot(state []byte, snapshot []byte) {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\tps.raftstate = state\n\tps.snapshot = snapshot\n}",
    "func (ps *Persister) ReadSnapshot() []byte {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\treturn ps.snapshot\n}",
    "func (ps *Persister) SnapshotSize() int {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\treturn len(ps.snapshot)\n}",
    "func (rf *Raft) GetState() (int, bool) {\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\n\treturn rf.currentTerm, rf.state == leader\n}\n\n// Save Raft's persistent state to stable storage, where it can later be retrieved after a crash and restart.\n// See paper's Figure 2 for a description of what should be persistent.",
    "func (rf *Raft) persist() {\n\twriter := new(bytes.Buffer)\n\tencoder := mygob.NewEncoder(writer)\n\n\t// persist non-volatile state\n\tif encoder.Encode(rf.currentTerm) != nil || encoder.Encode(rf.votedFor) != nil || encoder.Encode(rf.logs) != nil {\n\t\tpanic(\"raft: failed to persist server state\")\n\t}\n\n\tdata := writer.Bytes()\n\trf.persister.SaveRaftState(data)\n}\n\n// Restore previously persisted state.",
    "func (rf *Raft) readPersist(data []byte) {\n\tif data == nil || len(data) == 0 {\n\t\treturn\n\t}\n\n\treader := bytes.NewBuffer(data)\n\tdecoder := mygob.NewDecoder(reader)\n\n\tif decoder.Decode(&rf.currentTerm) != nil || decoder.Decode(&rf.votedFor) != nil || decoder.Decode(&rf.logs) != nil {\n\t\tpanic(\"raft: failed to read server state\")\n\t}\n}\n\n// RequestVoteArgs struct -\n// RequestVote RPC arguments structure.\ntype RequestVoteArgs struct {\n\tTerm         int\n\tCandidateId  int\n\tLastLogIndex int\n\tLastLogTerm  int\n}\n\n// RequestVoteReply struct -\n// RequestVote RPC reply structure.\ntype RequestVoteReply struct {\n\tTerm        int\n\tVoteGranted bool\n}\n\n// RequestVote RPC handler.",
    "func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\tdefer rf.persist()\n\n\treply.VoteGranted = false\n\n\t// candidate's term is lower than ours, reply false\n\tif args.Term < rf.currentTerm {\n\t\treply.Term = rf.currentTerm\n\t\treturn\n\t}\n\n\t// candidate's term is higher than ours, so step down to follower and update term\n\tif args.Term > rf.currentTerm {\n\t\trf.state = follower\n\t\trf.updateTerm(args.Term)\n\t\trf.setElectionTimer()\n\t\trf.sendToChannel(rf.stepDownCh, true)\n\t}\n\n\treply.Term = rf.currentTerm\n\n\tif (rf.votedFor == -1 || rf.votedFor == args.CandidateId) && rf.isCandidateUpToDate(args.LastLogIndex, args.LastLogTerm) {\n\t\treply.VoteGranted = true\n\t\trf.votedFor = args.CandidateId\n\t\trf.setElectionTimer()\n\t\trf.sendToChannel(rf.grantVoteCh, true)\n\t}\n}\n\n// AppendEntries RPC handler.",
    "func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) {\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\tdefer rf.persist()\n\n\treply.Term = rf.currentTerm\n\treply.Success = false\n\n\tif args.Term < rf.currentTerm {\n\t\treturn\n\t}\n\n\tif args.Term > rf.currentTerm {\n\t\trf.state = follower\n\t\trf.updateTerm(args.Term)\n\t\trf.setElectionTimer()\n\t\trf.sendToChannel(rf.stepDownCh, true)\n\t}\n\n\tif args.PrevLogIndex > rf.getLastLogIndex() {\n\t\treturn\n\t}\n\n\tif rf.logs[args.PrevLogIndex].Term != args.PrevLogTerm {\n\t\treturn\n\t}\n\n\trf.sendToChannel(rf.heartbeatCh, true)\n\n\tif len(args.Entries) > 0 {\n\t\trf.logs = rf.logs[:args.PrevLogIndex+1]\n\t\trf.logs = append(rf.logs, args.Entries...)\n\t}\n\treply.Success = true\n\n\tif args.LeaderCommit > rf.commitIndex {\n\t\trf.commitIndex = min(args.LeaderCommit, rf.getLastLogIndex())\n\t\tgo rf.applyLogs()\n\t}\n}",
    "func (rf *Raft) applyLogs() {\n\tfor i := rf.lastApplied + 1; i <= rf.commitIndex; i++ {\n\t\trf.applyCh <- ApplyMsg{\n\t\t\tCommandValid: true,\n\t\t\tCommand:      rf.logs[i].Command,\n\t\t\tCommandIndex: i,\n\t\t}\n\t\trf.lastApplied = i\n\t}\n}\n\n// Start method -\n// The service using Raft (e.g. a k/v server) wants to start agreement on the next command to be appended to Raft's log.\n// If this server isn't the leader, returns false.\n// Otherwise, start the agreement and return immediately.\n// There is no guarantee that this command will ever be committed to the Raft log, since the leader may fail or lose an election.\n// Even if the Raft instance has been killed, this function should return gracefully.\n//\n// The first return value is the index that the command will appear at if it's ever committed.\n// The second return value is the current term.\n// The third return value is true if this server believes it is the leader.",
    "func (rf *Raft) Start(command interface{}) (int, int, bool) {\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\n\tif rf.state != leader {\n\t\treturn -1, rf.currentTerm, false\n\t}\n\n\tterm := rf.currentTerm\n\trf.logs = append(rf.logs, LogEntry{Term: term, Command: command})\n\trf.persist()\n\n\tgo rf.broadcastAppendEntries()\n\n\treturn rf.getLastLogIndex(), term, true\n}\n\n// Kill method -\n// The tester doesn't halt goroutines created by Raft after each test, but it does call the Kill() method.\n// Code can use killed() to check whether Kill() has been called.\n// The use of atomic avoids the need for a lock.\n//\n// The issue is that long-running goroutines use memory and may chew up CPU time, perhaps causing later tests to fail and generating confusing debug output.\n// Any goroutine with a long-running loop should call killed() to check whether it should stop.",
    "func (rf *Raft) Kill() {\n\tatomic.StoreInt32(&rf.dead, 1)\n}",
    "func (rf *Raft) killed() bool {\n\tz := atomic.LoadInt32(&rf.dead)\n\treturn z == 1\n}\n\n// The run goroutine manages the server. It is the main method which is always running and waiting for events.",
    "func (rf *Raft) run() {\n\tfor rf.killed() == false {\n\t\trf.mu.Lock()\n\t\tstate := rf.state\n\t\trf.mu.Unlock()\n\n\t\tswitch state {\n\t\tcase follower:\n\t\t\tselect {\n\t\t\tcase <-rf.grantVoteCh:\n\t\t\tcase <-rf.heartbeatCh:\n\t\t\tcase <-time.After(time.Duration(rf.electionTimeout) * time.Millisecond):\n\t\t\t\trf.becomeCandidate(follower)\n\t\t\t}\n\t\tcase candidate:\n\t\t\tselect {\n\t\t\tcase <-rf.stepDownCh:\n\t\t\t\t// already follower\n\t\t\tcase <-rf.winElectionCh:\n\t\t\t\trf.becomeLeader()\n\t\t\tcase <-time.After(time.Duration(rf.electionTimeout) * time.Millisecond): // restart election\n\t\t\t\trf.becomeCandidate(candidate)\n\t\t\t}\n\t\tcase leader:\n\t\t\tselect {\n\t\t\tcase <-rf.stepDownCh:\n\t\t\t\t// already follower\n\t\t\tcase <-time.After(heartbeatTimeout * time.Millisecond):\n\t\t\t\trf.mu.Lock()\n\t\t\t\trf.broadcastAppendEntries()\n\t\t\t\trf.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Make creates the Raft server.\n// The ports of all the Raft servers (including this one) are in peers[].\n// This server's port is peers[me].\n// All the servers' peers[] arrays have the same order.\n// Persister is a place for this server to  save its persistent state, and also initially holds the most recent saved state, if any.\n// applyCh is a channel on which the tester or service expects Raft to send ApplyMsg messages.\n// Make() must return quickly, so it should start goroutines for any long-running work.",
    "func Make(peers []*myrpc.ClientEnd, me int, persister *Persister, applyCh chan ApplyMsg) *Raft {\n\trf := &Raft{}\n\trf.peers = peers\n\trf.persister = persister\n\trf.me = me\n\n\trf.currentTerm = 0\n\trf.votedFor = -1 // no vote yet\n\trf.logs = make([]LogEntry, 0)\n\n\trf.commitIndex = 0\n\trf.lastApplied = 0\n\n\trf.nextIndex = make([]int, len(rf.peers))\n\trf.matchIndex = make([]int, len(rf.peers))\n\n\trf.state = follower\n\trf.setElectionTimer()\n\trf.voteCount = 0\n\trf.applyCh = applyCh\n\trf.heartbeatCh = make(chan bool)\n\trf.grantVoteCh = make(chan bool)\n\trf.winElectionCh = make(chan bool)\n\trf.stepDownCh = make(chan bool)\n\n\trf.logs = append(rf.logs, LogEntry{Term: 0}) // dummy log\n\n\t// initialize from state persisted before a crash\n\trf.readPersist(persister.ReadRaftState())\n\n\t// start run goroutine to start election\n\tgo rf.run()\n\n\treturn rf\n}",
    "func (rf *Raft) isCandidateUpToDate(candidateLastLogIndex int, candidateLastLogTerm int) bool {\n\tmyLastLogIndex := rf.getLastLogIndex()\n\tmyLastLogTerm := rf.getLastLogTerm()\n\n\tif candidateLastLogTerm < myLastLogTerm {\n\t\treturn false\n\t} else if candidateLastLogTerm > myLastLogTerm {\n\t\treturn true\n\t}\n\n\treturn candidateLastLogIndex >= myLastLogIndex\n}",
    "func (rf *Raft) becomeCandidate(fromState ServerState) {\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\n\tif rf.state != fromState {\n\t\treturn\n\t}\n\n\trf.state = candidate\n\trf.currentTerm += 1\n\trf.votedFor = rf.me\n\trf.voteCount = 1\n\trf.persist()\n\n\trf.setElectionTimer()\n\trf.startElection()\n}",
    "func (rf *Raft) becomeLeader() {\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\n\tif rf.state != candidate {\n\t\treturn\n\t}\n\n\trf.state = leader\n\trf.nextIndex = make([]int, len(rf.peers))\n\trf.matchIndex = make([]int, len(rf.peers))\n\n\tlastIndex := rf.getLastLogIndex()\n\tfor i := range rf.peers {\n\t\trf.nextIndex[i] = lastIndex + 1\n\t}\n\trf.matchIndex[rf.me] = lastIndex\n\n\trf.broadcastAppendEntries()\n}",
    "func (rf *Raft) getLastLogIndex() int {\n\treturn len(rf.logs) - 1\n}",
    "func (rf *Raft) getLastLogTerm() int {\n\treturn rf.logs[rf.getLastLogIndex()].Term\n}",
    "func (rf *Raft) updateTerm(term int) {\n\trf.currentTerm = term\n\trf.votedFor = -1\n\trf.persist()\n}",
    "func (rf *Raft) sendToChannel(ch chan bool, value bool) {\n\tselect {\n\tcase ch <- value:\n\tdefault:\n\t}\n}",
    "func TestInitialElection2A(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2A): initial election\")\n\n\t// is a leader elected?\n\tcfg.checkOneLeader()\n\n\t// sleep a bit to avoid racing with followers learning of the election, then check that all peers agree on the term\n\ttime.Sleep(50 * time.Millisecond)\n\tterm1 := cfg.checkTerms()\n\tif term1 < 1 {\n\t\tt.Fatalf(\"term is %v, but should be at least 1\", term1)\n\t}\n\n\t// does the leader + term stay the same if there is no network failure?\n\ttime.Sleep(2 * RaftElectionTimeout)\n\tterm2 := cfg.checkTerms()\n\n\tif term1 != term2 {\n\t\tfmt.Printf(\"warning: term changed even though there were no failures\")\n\t}\n\n\t// there should still be a leader\n\tcfg.checkOneLeader()\n\n\tcfg.end()\n}",
    "func TestReElection2A(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2A): election after network failure\")\n\n\tleader1 := cfg.checkOneLeader()\n\n\t// if the leader disconnects, a new one should be elected\n\tcfg.disconnect(leader1)\n\tcfg.checkOneLeader()\n\n\t// if the old leader rejoins, that shouldn't disturb the new leader\n\tcfg.connect(leader1)\n\tleader2 := cfg.checkOneLeader()\n\n\t// if there's no quorum, no leader should be elected.\n\tcfg.disconnect(leader2)\n\tcfg.disconnect((leader2 + 1) % servers)\n\ttime.Sleep(2 * RaftElectionTimeout)\n\tcfg.checkNoLeader()\n\n\t// if a quorum arises, it should elect a leader\n\tcfg.connect((leader2 + 1) % servers)\n\tcfg.checkOneLeader()\n\n\t// re-join of last node shouldn't prevent leader from existing\n\tcfg.connect(leader2)\n\tcfg.checkOneLeader()\n\n\tcfg.end()\n}",
    "func TestBasicAgree2B(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): basic agreement\")\n\n\titerations := 3\n\tfor index := 1; index < iterations+1; index++ {\n\t\tnd, _ := cfg.nCommitted(index)\n\n\t\tif nd > 0 {\n\t\t\tt.Fatalf(\"some have committed before Start()\")\n\t\t}\n\n\t\txindex := cfg.one(index*100, servers, false)\n\t\tif xindex != index {\n\t\t\tt.Fatalf(\"got index %v but expected %v\", xindex, index)\n\t\t}\n\t}\n\n\tcfg.end()\n}\n\n// check based on counting bytes of RPCs, that each command is sent to each peer just once.",
    "func TestRPCBytes2B(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): RPC byte count\")\n\n\tcfg.one(99, servers, false)\n\tbytes0 := cfg.bytesTotal()\n\n\titers := 10\n\tvar sent int64 = 0\n\tfor index := 2; index < iters+2; index++ {\n\t\tcmd := randstring(5000)\n\t\txindex := cfg.one(cmd, servers, false)\n\t\tif xindex != index {\n\t\t\tt.Fatalf(\"got index %v but expected %v\", xindex, index)\n\t\t}\n\t\tsent += int64(len(cmd))\n\t}\n\n\tbytes1 := cfg.bytesTotal()\n\tgot := bytes1 - bytes0\n\texpected := int64(servers) * sent\n\tif got > expected+50000 {\n\t\tt.Fatalf(\"too many RPC bytes; got %v, expected %v\", got, expected)\n\t}\n\n\tcfg.end()\n}",
    "func TestFailAgree2B(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): agreement despite follower disconnection\")\n\n\tcfg.one(101, servers, false)\n\n\t// disconnect one follower from the network.\n\tleader := cfg.checkOneLeader()\n\tcfg.disconnect((leader + 1) % servers)\n\n\t// the leader and remaining follower should be able to agree despite the disconnected follower\n\tcfg.one(102, servers-1, false)\n\tcfg.one(103, servers-1, false)\n\ttime.Sleep(RaftElectionTimeout)\n\tcfg.one(104, servers-1, false)\n\tcfg.one(105, servers-1, false)\n\n\t// re-connect\n\tcfg.connect((leader + 1) % servers)\n\n\t// the full set of servers should preserve previous agreements, and be able to agree on new commands\n\tcfg.one(106, servers, true)\n\ttime.Sleep(RaftElectionTimeout)\n\tcfg.one(107, servers, true)\n\n\tcfg.end()\n}",
    "func TestFailNoAgree2B(t *testing.T) {\n\tservers := 5\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): no agreement if too many followers disconnect\")\n\n\tcfg.one(10, servers, false)\n\n\t// 3 of 5 followers disconnect\n\tleader := cfg.checkOneLeader()\n\tcfg.disconnect((leader + 1) % servers)\n\tcfg.disconnect((leader + 2) % servers)\n\tcfg.disconnect((leader + 3) % servers)\n\n\tindex, _, ok := cfg.rafts[leader].Start(20)\n\tif ok != true {\n\t\tt.Fatalf(\"leader rejected Start()\")\n\t}\n\tif index != 2 {\n\t\tt.Fatalf(\"expected index 2, got %v\", index)\n\t}\n\n\ttime.Sleep(2 * RaftElectionTimeout)\n\n\tn, _ := cfg.nCommitted(index)\n\tif n > 0 {\n\t\tt.Fatalf(\"%v committed but no majority\", n)\n\t}\n\n\t// repair\n\tcfg.connect((leader + 1) % servers)\n\tcfg.connect((leader + 2) % servers)\n\tcfg.connect((leader + 3) % servers)\n\n\t// the disconnected majority may have chosen a leader from among their own ranks, forgetting index 2\n\tleader2 := cfg.checkOneLeader()\n\tindex2, _, ok2 := cfg.rafts[leader2].Start(30)\n\tif ok2 == false {\n\t\tt.Fatalf(\"leader2 rejected Start()\")\n\t}\n\tif index2 < 2 || index2 > 3 {\n\t\tt.Fatalf(\"unexpected index %v\", index2)\n\t}\n\n\tcfg.one(1000, servers, true)\n\n\tcfg.end()\n}",
    "func TestConcurrentStarts2B(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): concurrent Start()s\")\n\n\tvar success bool\nloop:\n\tfor try := 0; try < 5; try++ {\n\t\tif try > 0 {\n\t\t\t// give solution some time to settle\n\t\t\ttime.Sleep(3 * time.Second)\n\t\t}\n\n\t\tleader := cfg.checkOneLeader()\n\t\t_, term, ok := cfg.rafts[leader].Start(1)\n\t\tif !ok {\n\t\t\t// leader moved on really quickly\n\t\t\tcontinue\n\t\t}\n\n\t\titerations := 5\n\t\tvar wg sync.WaitGroup\n\t\tis := make(chan int, iterations)\n\t\tfor ii := 0; ii < iterations; ii++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(i int) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\ti, term1, ok := cfg.rafts[leader].Start(100 + i)\n\t\t\t\tif term1 != term {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif ok != true {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tis <- i\n\t\t\t}(ii)\n\t\t}\n\n\t\twg.Wait()\n\t\tclose(is)\n\n\t\tfor j := 0; j < servers; j++ {\n\t\t\tif t, _ := cfg.rafts[j].GetState(); t != term {\n\t\t\t\t// term changed -- can't expect low RPC counts\n\t\t\t\tcontinue loop\n\t\t\t}\n\t\t}\n\n\t\tfailed := false\n\t\tvar cmds []int\n\t\tfor index := range is {\n\t\t\tcmd := cfg.wait(index, servers, term)\n\t\t\tif ix, ok := cmd.(int); ok {\n\t\t\t\tif ix == -1 {\n\t\t\t\t\t// peers have moved on to later terms so we can't expect all Start()s to have succeeded\n\t\t\t\t\tfailed = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcmds = append(cmds, ix)\n\t\t\t} else {\n\t\t\t\tt.Fatalf(\"value %v is not an int\", cmd)\n\t\t\t}\n\t\t}\n\n\t\tif failed {\n\t\t\t// avoid leaking goroutines\n\t\t\tgo func() {\n\t\t\t\tfor range is {\n\t\t\t\t}\n\t\t\t}()\n\t\t\tcontinue\n\t\t}\n\n\t\tfor ii := 0; ii < iterations; ii++ {\n\t\t\tx := 100 + ii\n\t\t\tok := false\n\t\t\tfor j := 0; j < len(cmds); j++ {\n\t\t\t\tif cmds[j] == x {\n\t\t\t\t\tok = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ok == false {\n\t\t\t\tt.Fatalf(\"cmd %v missing in %v\", x, cmds)\n\t\t\t}\n\t\t}\n\n\t\tsuccess = true\n\t\tbreak\n\t}\n\n\tif !success {\n\t\tt.Fatalf(\"term changed too often\")\n\t}\n\n\tcfg.end()\n}",
    "func TestRejoin2B(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): rejoin of partitioned leader\")\n\n\tcfg.one(101, servers, true)\n\n\t// leader network failure\n\tleader1 := cfg.checkOneLeader()\n\tcfg.disconnect(leader1)\n\n\t// make old leader try to agree on some entries\n\tcfg.rafts[leader1].Start(102)\n\tcfg.rafts[leader1].Start(103)\n\tcfg.rafts[leader1].Start(104)\n\n\t// new leader commits, also for index = 2\n\tcfg.one(103, 2, true)\n\n\t// new leader network failure\n\tleader2 := cfg.checkOneLeader()\n\tcfg.disconnect(leader2)\n\n\t// old leader connected again\n\tcfg.connect(leader1)\n\n\tcfg.one(104, 2, true)\n\n\t// all together now\n\tcfg.connect(leader2)\n\n\tcfg.one(105, servers, true)\n\n\tcfg.end()\n}",
    "func TestBackup2B(t *testing.T) {\n\tservers := 5\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): leader backs up quickly over incorrect follower logs\")\n\n\tcfg.one(rand.Int(), servers, true)\n\n\t// put leader and one follower in a partition\n\tleader1 := cfg.checkOneLeader()\n\tcfg.disconnect((leader1 + 2) % servers)\n\tcfg.disconnect((leader1 + 3) % servers)\n\tcfg.disconnect((leader1 + 4) % servers)\n\n\t// submit lots of commands that won't commit\n\tfor i := 0; i < 50; i++ {\n\t\tcfg.rafts[leader1].Start(rand.Int())\n\t}\n\n\ttime.Sleep(RaftElectionTimeout / 2)\n\n\tcfg.disconnect((leader1 + 0) % servers)\n\tcfg.disconnect((leader1 + 1) % servers)\n\n\t// allow other partition to recover\n\tcfg.connect((leader1 + 2) % servers)\n\tcfg.connect((leader1 + 3) % servers)\n\tcfg.connect((leader1 + 4) % servers)\n\n\t// lots of successful commands to new group.\n\tfor i := 0; i < 50; i++ {\n\t\tcfg.one(rand.Int(), 3, true)\n\t}\n\n\t// now another partitioned leader and one follower\n\tleader2 := cfg.checkOneLeader()\n\tother := (leader1 + 2) % servers\n\tif leader2 == other {\n\t\tother = (leader2 + 1) % servers\n\t}\n\tcfg.disconnect(other)\n\n\t// lots more commands that won't commit\n\tfor i := 0; i < 50; i++ {\n\t\tcfg.rafts[leader2].Start(rand.Int())\n\t}\n\n\ttime.Sleep(RaftElectionTimeout / 2)\n\n\t// bring original leader back to life,\n\tfor i := 0; i < servers; i++ {\n\t\tcfg.disconnect(i)\n\t}\n\tcfg.connect((leader1 + 0) % servers)\n\tcfg.connect((leader1 + 1) % servers)\n\tcfg.connect(other)\n\n\t// lots of successful commands to new group.\n\tfor i := 0; i < 50; i++ {\n\t\tcfg.one(rand.Int(), 3, true)\n\t}\n\n\t// now everyone\n\tfor i := 0; i < servers; i++ {\n\t\tcfg.connect(i)\n\t}\n\tcfg.one(rand.Int(), servers, true)\n\n\tcfg.end()\n}",
    "func TestCount2B(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2B): RPC counts aren't too high\")\n\n\trpcs := func() (n int) {\n\t\tfor j := 0; j < servers; j++ {\n\t\t\tn += cfg.rpcCount(j)\n\t\t}\n\t\treturn\n\t}\n\n\tleader := cfg.checkOneLeader()\n\n\ttotal1 := rpcs()\n\n\tif total1 > 30 || total1 < 1 {\n\t\tt.Fatalf(\"too many or few RPCs (%v) to elect initial leader\\n\", total1)\n\t}\n\n\tvar total2 int\n\tvar success bool\nloop:\n\tfor try := 0; try < 5; try++ {\n\t\tif try > 0 {\n\t\t\t// give solution some time to settle\n\t\t\ttime.Sleep(3 * time.Second)\n\t\t}\n\n\t\tleader = cfg.checkOneLeader()\n\t\ttotal1 = rpcs()\n\n\t\titers := 10\n\t\tstarti, term, ok := cfg.rafts[leader].Start(1)\n\t\tif !ok {\n\t\t\t// leader moved on really quickly\n\t\t\tcontinue\n\t\t}\n\t\tcmds := []int{}\n\t\tfor i := 1; i < iters+2; i++ {\n\t\t\tx := int(rand.Int31())\n\t\t\tcmds = append(cmds, x)\n\t\t\tindex1, term1, ok := cfg.rafts[leader].Start(x)\n\t\t\tif term1 != term {\n\t\t\t\t// Term changed while starting\n\t\t\t\tcontinue loop\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\t// No longer the leader, so term has changed\n\t\t\t\tcontinue loop\n\t\t\t}\n\t\t\tif starti+i != index1 {\n\t\t\t\tt.Fatalf(\"Start() failed\")\n\t\t\t}\n\t\t}\n\n\t\tfor i := 1; i < iters+1; i++ {\n\t\t\tcmd := cfg.wait(starti+i, servers, term)\n\t\t\tif ix, ok := cmd.(int); ok == false || ix != cmds[i-1] {\n\t\t\t\tif ix == -1 {\n\t\t\t\t\t// term changed -- try again\n\t\t\t\t\tcontinue loop\n\t\t\t\t}\n\t\t\t\tt.Fatalf(\"wrong value %v committed for index %v; expected %v\\n\", cmd, starti+i, cmds)\n\t\t\t}\n\t\t}\n\n\t\tfailed := false\n\t\ttotal2 = 0\n\t\tfor j := 0; j < servers; j++ {\n\t\t\tif t, _ := cfg.rafts[j].GetState(); t != term {\n\t\t\t\t// term changed -- can't expect low RPC counts\n\t\t\t\t// need to keep going to update total2\n\t\t\t\tfailed = true\n\t\t\t}\n\t\t\ttotal2 += cfg.rpcCount(j)\n\t\t}\n\n\t\tif failed {\n\t\t\tcontinue loop\n\t\t}\n\n\t\tif total2-total1 > (iters+1+3)*3 {\n\t\t\tt.Fatalf(\"too many RPCs (%v) for %v entries\\n\", total2-total1, iters)\n\t\t}\n\n\t\tsuccess = true\n\t\tbreak\n\t}\n\n\tif !success {\n\t\tt.Fatalf(\"term changed too often\")\n\t}\n\n\ttime.Sleep(RaftElectionTimeout)\n\n\ttotal3 := 0\n\tfor j := 0; j < servers; j++ {\n\t\ttotal3 += cfg.rpcCount(j)\n\t}\n\n\tif total3-total2 > 3*20 {\n\t\tt.Fatalf(\"too many RPCs (%v) for 1 second of idleness\\n\", total3-total2)\n\t}\n\n\tcfg.end()\n}",
    "func TestPersist12C(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2C): basic persistence\")\n\n\tcfg.one(11, servers, true)\n\n\t// crash and re-start all\n\tfor i := 0; i < servers; i++ {\n\t\tcfg.start1(i)\n\t}\n\tfor i := 0; i < servers; i++ {\n\t\tcfg.disconnect(i)\n\t\tcfg.connect(i)\n\t}\n\n\tcfg.one(12, servers, true)\n\n\tleader1 := cfg.checkOneLeader()\n\tcfg.disconnect(leader1)\n\tcfg.start1(leader1)\n\tcfg.connect(leader1)\n\n\tcfg.one(13, servers, true)\n\n\tleader2 := cfg.checkOneLeader()\n\tcfg.disconnect(leader2)\n\tcfg.one(14, servers-1, true)\n\tcfg.start1(leader2)\n\tcfg.connect(leader2)\n\n\tcfg.wait(4, servers, -1) // wait for leader2 to join before killing i3\n\n\ti3 := (cfg.checkOneLeader() + 1) % servers\n\tcfg.disconnect(i3)\n\tcfg.one(15, servers-1, true)\n\tcfg.start1(i3)\n\tcfg.connect(i3)\n\n\tcfg.one(16, servers, true)\n\n\tcfg.end()\n}",
    "func TestPersist22C(t *testing.T) {\n\tservers := 5\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2C): more persistence\")\n\n\tindex := 1\n\tfor iters := 0; iters < 5; iters++ {\n\t\tcfg.one(10+index, servers, true)\n\t\tindex++\n\n\t\tleader1 := cfg.checkOneLeader()\n\n\t\tcfg.disconnect((leader1 + 1) % servers)\n\t\tcfg.disconnect((leader1 + 2) % servers)\n\n\t\tcfg.one(10+index, servers-2, true)\n\t\tindex++\n\n\t\tcfg.disconnect((leader1 + 0) % servers)\n\t\tcfg.disconnect((leader1 + 3) % servers)\n\t\tcfg.disconnect((leader1 + 4) % servers)\n\n\t\tcfg.start1((leader1 + 1) % servers)\n\t\tcfg.start1((leader1 + 2) % servers)\n\t\tcfg.connect((leader1 + 1) % servers)\n\t\tcfg.connect((leader1 + 2) % servers)\n\n\t\ttime.Sleep(RaftElectionTimeout)\n\n\t\tcfg.start1((leader1 + 3) % servers)\n\t\tcfg.connect((leader1 + 3) % servers)\n\n\t\tcfg.one(10+index, servers-2, true)\n\t\tindex++\n\n\t\tcfg.connect((leader1 + 4) % servers)\n\t\tcfg.connect((leader1 + 0) % servers)\n\t}\n\n\tcfg.one(1000, servers, true)\n\n\tcfg.end()\n}",
    "func TestPersist32C(t *testing.T) {\n\tservers := 3\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2C): partitioned leader and one follower crash, leader restarts\")\n\n\tcfg.one(101, 3, true)\n\n\tleader := cfg.checkOneLeader()\n\tcfg.disconnect((leader + 2) % servers)\n\n\tcfg.one(102, 2, true)\n\n\tcfg.crash1((leader + 0) % servers)\n\tcfg.crash1((leader + 1) % servers)\n\tcfg.connect((leader + 2) % servers)\n\tcfg.start1((leader + 0) % servers)\n\tcfg.connect((leader + 0) % servers)\n\n\tcfg.one(103, 2, true)\n\n\tcfg.start1((leader + 1) % servers)\n\tcfg.connect((leader + 1) % servers)\n\n\tcfg.one(104, servers, true)\n\n\tcfg.end()\n}\n\n// Test the scenarios described in Figure 8 of the extended Raft paper. Each\n// iteration asks a leader, if there is one, to insert a command in the Raft\n// log.  If there is a leader, that leader will fail quickly with a high\n// probability (perhaps without committing the command), or crash after a while\n// with low probability (most likely committing the command).  If the number of\n// alive servers isn't enough to form a majority, perhaps start a new server.\n// The leader in a new term may try to finish replicating log entries that\n// haven't been committed yet.",
    "func TestFigure82C(t *testing.T) {\n\tservers := 5\n\tcfg := make_config(t, servers, false)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2C): Figure 8\")\n\n\tcfg.one(rand.Int(), 1, true)\n\n\tnup := servers\n\tfor iters := 0; iters < 1000; iters++ {\n\t\tleader := -1\n\t\tfor i := 0; i < servers; i++ {\n\t\t\tif cfg.rafts[i] != nil {\n\t\t\t\t_, _, ok := cfg.rafts[i].Start(rand.Int())\n\t\t\t\tif ok {\n\t\t\t\t\tleader = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rand.Int() % 1000) < 100 {\n\t\t\tms := rand.Int63() % (int64(RaftElectionTimeout/time.Millisecond) / 2)\n\t\t\ttime.Sleep(time.Duration(ms) * time.Millisecond)\n\t\t} else {\n\t\t\tms := (rand.Int63() % 13)\n\t\t\ttime.Sleep(time.Duration(ms) * time.Millisecond)\n\t\t}\n\n\t\tif leader != -1 {\n\t\t\tcfg.crash1(leader)\n\t\t\tnup -= 1\n\t\t}\n\n\t\tif nup < 3 {\n\t\t\ts := rand.Int() % servers\n\t\t\tif cfg.rafts[s] == nil {\n\t\t\t\tcfg.start1(s)\n\t\t\t\tcfg.connect(s)\n\t\t\t\tnup += 1\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := 0; i < servers; i++ {\n\t\tif cfg.rafts[i] == nil {\n\t\t\tcfg.start1(i)\n\t\t\tcfg.connect(i)\n\t\t}\n\t}\n\n\tcfg.one(rand.Int(), servers, true)\n\n\tcfg.end()\n}",
    "func TestUnreliableAgree2C(t *testing.T) {\n\tservers := 5\n\tcfg := make_config(t, servers, true)\n\tdefer cfg.cleanup()\n\n\tcfg.begin(\"Test (2C): unreliable agreement\")\n\n\tvar wg sync.WaitGroup\n\n\tfor iters := 1; iters < 50; iters++ {\n\t\tfor j := 0; j < 4; j++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(iters, j int) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tcfg.one((100*iters)+j, 1, true)\n\t\t\t}(iters, j)\n\t\t}\n\t\tcfg.one(iters, 1, true)\n\t}\n\n\tcfg.setunreliable(false)\n\n\twg.Wait()\n\n\tcfg.one(100, servers, true)\n\n\tcfg.end()\n}"
  ]
}