method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
pure_embedding,top_k-10,neg_006,False,False,,[],,92.59200096130371
pure_embedding,top_k-10,neg_013,False,False,,[],,70.97196578979492
pure_embedding,top_k-10,neg_010,False,False,,[],,76.21026039123535
pure_embedding,top_k-10,neg_002,False,False,,[],,73.37117195129395
pure_embedding,top_k-10,pos_chunk_00006,True,True,,"[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.7675689217874861}]",,87.34655380249023
pure_embedding,top_k-10,pos_chunk_00005,True,False,,[],,94.11144256591797
pure_embedding,top_k-10,pos_chunk_00015,True,False,,[],,97.45526313781738
pure_embedding,top_k-10,neg_004,False,False,,[],,47.86992073059082
pure_embedding,top_k-10,neg_001,False,False,,[],,59.77582931518555
pure_embedding,top_k-10,pos_chunk_00014,True,False,,[],,64.27335739135742
pure_embedding,top_k-10,pos_chunk_00001,True,False,,[],,60.15181541442871
pure_embedding,top_k-10,neg_011,False,False,,[],,75.55103302001953
pure_embedding,top_k-10,pos_chunk_00002,True,True,,"[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7746990437782441}]",,130.05661964416504
pure_embedding,top_k-10,pos_chunk_00009,True,False,,[],,59.81588363647461
pure_embedding,top_k-10,neg_009,False,False,,[],,60.27698516845703
pure_embedding,top_k-10,pos_chunk_00012,True,False,,[],,69.81325149536133
pure_embedding,top_k-10,pos_chunk_00004,True,False,,[],,141.7088508605957
pure_embedding,top_k-10,neg_007,False,False,,[],,58.440446853637695
pure_embedding,top_k-10,neg_003,False,False,,[],,100.17871856689453
pure_embedding,top_k-10,pos_chunk_00007,True,False,,[],,42.19937324523926
pure_embedding,top_k-10,neg_008,False,False,,[],,47.3780632019043
pure_embedding,top_k-10,neg_005,False,False,,[],,50.4457950592041
pure_embedding,top_k-10,pos_chunk_00008,True,False,,[],,40.57192802429199
pure_embedding,top_k-10,pos_chunk_00010,True,False,,[],,55.361270904541016
pure_embedding,top_k-10,pos_chunk_00003,True,True,,"[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.865548941307772}]",,163.9845371246338
pure_embedding,top_k-10,neg_015,False,False,,[],,59.928178787231445
pure_embedding,top_k-10,neg_014,False,False,,[],,59.9210262298584
pure_embedding,top_k-10,pos_chunk_00013,True,False,,[],,54.91065979003906
pure_embedding,top_k-10,neg_012,False,False,,[],,54.888248443603516
pure_embedding,top_k-10,pos_chunk_00011,True,False,,[],,69.96464729309082
