method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
pure_embedding,top_k-10,pos_chunk_00007,True,False,,[],,43.1976318359375
pure_embedding,top_k-10,pos_chunk_00003,True,True,,"[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.8930104297027083}, {'chunk_id': 'chunk_00017', 'path': 'got\\download.go', 'text': 'func (d *Download) DownloadChunk(c *Chunk, dest io.Writer) error {\n\n\tvar (\n\t\terr error\n\t\treq *http.Request\n\t\tres *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, d.Header); err != nil {\n\t\treturn err\n\t}\n\n\tcontentRange := fmt.Sprintf(""bytes=%d-%d"", c.Start, c.End)\n\treq.Header.Set(""Range"", contentRange)\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify the length\n\tif res.ContentLength != int64(c.End-c.Start+1) {\n\t\treturn fmt.Errorf(\n\t\t\t""Range request returned invalid Content-Length: %d however the range was: %s"",\n\t\t\tres.ContentLength, contentRange,\n\t\t)\n\t}\n\n\tdefer res.Body.Close()\n\n\t_, err = io.CopyN(dest, io.TeeReader(res.Body, d), res.ContentLength)\n\n\treturn err\n}\n\n// NewDownload returns new *Download with context.', 'similarity': 0.6870860085706703}]",,96.75049781799316
pure_embedding,top_k-10,neg_013,False,False,,[],,26.433944702148438
pure_embedding,top_k-10,neg_008,False,True,,"[{'chunk_id': 'chunk_00187', 'path': 'leetcode-go\\125-valid-palindrome\\valid-palindrome.go', 'text': 'func isPalindrome(s string) bool {\n\tleft, right := 0, len(s) - 1\n\n\tfor left < right {\n\t\tif isNonAlphaNumeric(s[left]) {\n\t\t\tleft += 1\n\t\t\tcontinue\n\t\t}\n\t\tif isNonAlphaNumeric(s[right]) {\n\t\t\tright -= 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) {\n\t\t\treturn false\n\t\t}\n\n\t\tleft += 1\n\t\tright -= 1\n\t}\n\n\treturn true\n}', 'similarity': 0.7081730569137222}]",,34.26527976989746
pure_embedding,top_k-10,pos_chunk_00014,True,True,,"[{'chunk_id': 'chunk_00014', 'path': 'got\\download.go', 'text': 'func (d *Download) IsRangeable() bool {\n\treturn d.info.Rangeable\n}\n\n// Download chunks', 'similarity': 0.6977439521439567}]",,28.30791473388672
pure_embedding,top_k-10,pos_chunk_00005,True,False,,[],,51.89037322998047
pure_embedding,top_k-10,neg_010,False,False,,[],,37.276268005371094
pure_embedding,top_k-10,pos_chunk_00009,True,True,,"[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.6603642194183705}]",,30.575275421142578
pure_embedding,top_k-10,pos_chunk_00001,True,False,,[],,28.161287307739258
pure_embedding,top_k-10,neg_012,False,False,,[],,16.56794548034668
pure_embedding,top_k-10,neg_005,False,False,,[],,33.16974639892578
pure_embedding,top_k-10,pos_chunk_00012,True,True,,"[{'chunk_id': 'chunk_00012', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalCost() time.Duration {\n\treturn time.Now().Sub(d.startedAt)\n}\n\n// Write updates progress size.', 'similarity': 0.6702925201679462}]",,19.261598587036133
pure_embedding,top_k-10,pos_chunk_00010,True,False,,[],,33.77985954284668
pure_embedding,top_k-10,neg_002,False,False,,[],,33.9658260345459
pure_embedding,top_k-10,pos_chunk_00015,True,True,,"[{'chunk_id': 'chunk_00015', 'path': 'got\\download.go', 'text': 'func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts', 'similarity': 0.7078649120686312}]",,74.32007789611816
pure_embedding,top_k-10,pos_chunk_00006,True,True,,"[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.7366777084204204}]",,57.050228118896484
pure_embedding,top_k-10,pos_chunk_00002,True,True,,"[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7174153794182434}]",,104.26521301269531
pure_embedding,top_k-10,neg_006,False,False,,[],,32.501220703125
pure_embedding,top_k-10,pos_chunk_00011,True,True,,"[{'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.7222725103358505}, {'chunk_id': 'chunk_00010', 'path': 'got\\download.go', 'text': 'func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.', 'similarity': 0.6521745857090668}]",,33.186912536621094
pure_embedding,top_k-10,pos_chunk_00013,True,False,,[],,32.733917236328125
pure_embedding,top_k-10,pos_chunk_00004,True,True,,"[{'chunk_id': 'chunk_00004', 'path': 'got\\download.go', 'text': 'func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init', 'similarity': 0.749262425685441}]",,106.01425170898438
pure_embedding,top_k-10,neg_003,False,False,,[],,44.98481750488281
pure_embedding,top_k-10,neg_015,False,False,,[],,21.09670639038086
pure_embedding,top_k-10,neg_014,False,False,,[],,31.296730041503906
pure_embedding,top_k-10,neg_007,False,False,,[],,28.638839721679688
pure_embedding,top_k-10,neg_001,False,False,,[],,16.016721725463867
pure_embedding,top_k-10,neg_011,False,False,,[],,33.94436836242676
pure_embedding,top_k-10,neg_004,False,False,,[],,15.627145767211914
pure_embedding,top_k-10,pos_chunk_00008,True,False,,[],,34.597158432006836
pure_embedding,top_k-10,neg_009,False,False,,[],,36.67616844177246
