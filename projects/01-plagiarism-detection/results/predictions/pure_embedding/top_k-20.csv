method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
pure_embedding,top_k-20,neg_006,False,False,,[],,38.28167915344238
pure_embedding,top_k-20,neg_013,False,False,,[],,33.47373008728027
pure_embedding,top_k-20,neg_010,False,False,,[],,52.26469039916992
pure_embedding,top_k-20,neg_002,False,False,,[],,37.34755516052246
pure_embedding,top_k-20,pos_chunk_00006,True,True,,"[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.7675689217874861}]",,53.07412147521973
pure_embedding,top_k-20,pos_chunk_00005,True,False,,[],,43.509721755981445
pure_embedding,top_k-20,pos_chunk_00015,True,True,,"[{'chunk_id': 'chunk_00015', 'path': 'got\\download.go', 'text': 'func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts', 'similarity': 0.7422878679350746}]",,49.86429214477539
pure_embedding,top_k-20,neg_004,False,False,,[],,33.0958366394043
pure_embedding,top_k-20,neg_001,False,False,,[],,33.35428237915039
pure_embedding,top_k-20,pos_chunk_00014,True,False,,[],,41.764259338378906
pure_embedding,top_k-20,pos_chunk_00001,True,True,,"[{'chunk_id': 'chunk_00001', 'path': 'got\\chunk.go', 'text': 'func (dst *OffsetWriter) Write(b []byte) (n int, err error) {\n\tn, err = dst.WriteAt(b, dst.offset)\n\tdst.offset += int64(n)\n\treturn\n}\n\n// Chunk represents the partial content range\ntype Chunk struct {\n\tStart, End uint64\n}', 'similarity': 0.6525348046817768}]",,24.075984954833984
pure_embedding,top_k-20,neg_011,False,False,,[],,207.60273933410645
pure_embedding,top_k-20,pos_chunk_00002,True,True,,"[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7746990437782441}]",,719.0186977386475
pure_embedding,top_k-20,pos_chunk_00009,True,True,,"[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.6666778592823166}, {'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.6642737756230302}]",,104.74300384521484
pure_embedding,top_k-20,neg_009,False,False,,[],,70.69706916809082
pure_embedding,top_k-20,pos_chunk_00012,True,False,,[],,35.07113456726074
pure_embedding,top_k-20,pos_chunk_00004,True,True,,"[{'chunk_id': 'chunk_00004', 'path': 'got\\download.go', 'text': 'func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init', 'similarity': 0.6958946394984911}]",,128.59034538269043
pure_embedding,top_k-20,neg_007,False,False,,[],,65.46974182128906
pure_embedding,top_k-20,neg_003,False,False,,[],,63.712120056152344
pure_embedding,top_k-20,pos_chunk_00007,True,False,,[],,36.76128387451172
pure_embedding,top_k-20,neg_008,False,True,,"[{'chunk_id': 'chunk_00187', 'path': 'leetcode-go\\125-valid-palindrome\\valid-palindrome.go', 'text': 'func isPalindrome(s string) bool {\n\tleft, right := 0, len(s) - 1\n\n\tfor left < right {\n\t\tif isNonAlphaNumeric(s[left]) {\n\t\t\tleft += 1\n\t\t\tcontinue\n\t\t}\n\t\tif isNonAlphaNumeric(s[right]) {\n\t\t\tright -= 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) {\n\t\t\treturn false\n\t\t}\n\n\t\tleft += 1\n\t\tright -= 1\n\t}\n\n\treturn true\n}', 'similarity': 0.7081730569137222}]",,53.112030029296875
pure_embedding,top_k-20,neg_005,False,False,,[],,35.53295135498047
pure_embedding,top_k-20,pos_chunk_00008,True,True,,"[{'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.6703809992248383}, {'chunk_id': 'chunk_00007', 'path': 'got\\download.go', 'text': 'func (d *Download) Context() context.Context {\n\treturn d.ctx\n}\n\n// TotalSize returns file total size (0 if unknown).', 'similarity': 0.6541719878949522}]",,46.7991828918457
pure_embedding,top_k-20,pos_chunk_00010,True,False,,[],,51.310062408447266
pure_embedding,top_k-20,pos_chunk_00003,True,True,,"[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.865548941307772}, {'chunk_id': 'chunk_00017', 'path': 'got\\download.go', 'text': 'func (d *Download) DownloadChunk(c *Chunk, dest io.Writer) error {\n\n\tvar (\n\t\terr error\n\t\treq *http.Request\n\t\tres *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, d.Header); err != nil {\n\t\treturn err\n\t}\n\n\tcontentRange := fmt.Sprintf(""bytes=%d-%d"", c.Start, c.End)\n\treq.Header.Set(""Range"", contentRange)\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify the length\n\tif res.ContentLength != int64(c.End-c.Start+1) {\n\t\treturn fmt.Errorf(\n\t\t\t""Range request returned invalid Content-Length: %d however the range was: %s"",\n\t\t\tres.ContentLength, contentRange,\n\t\t)\n\t}\n\n\tdefer res.Body.Close()\n\n\t_, err = io.CopyN(dest, io.TeeReader(res.Body, d), res.ContentLength)\n\n\treturn err\n}\n\n// NewDownload returns new *Download with context.', 'similarity': 0.6945224669971536}]",,119.8112964630127
pure_embedding,top_k-20,neg_015,False,False,,[],,64.66531753540039
pure_embedding,top_k-20,neg_014,False,False,,[],,40.67373275756836
pure_embedding,top_k-20,pos_chunk_00013,True,False,,[],,39.568424224853516
pure_embedding,top_k-20,neg_012,False,False,,[],,40.17281532287598
pure_embedding,top_k-20,pos_chunk_00011,True,True,,"[{'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.7398795150144943}, {'chunk_id': 'chunk_00010', 'path': 'got\\download.go', 'text': 'func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.', 'similarity': 0.6672923205673673}]",,45.15886306762695
