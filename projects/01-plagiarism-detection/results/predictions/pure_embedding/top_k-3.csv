method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
pure_embedding,top_k-3,neg_006,False,False,,[],,85.95490455627441
pure_embedding,top_k-3,neg_013,False,False,,[],,69.08726692199707
pure_embedding,top_k-3,neg_010,False,False,,[],,69.9911117553711
pure_embedding,top_k-3,neg_002,False,False,,[],,71.72250747680664
pure_embedding,top_k-3,pos_chunk_00006,True,True,,"[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.7675689217874861}]",,92.9110050201416
pure_embedding,top_k-3,pos_chunk_00005,True,False,,[],,96.84634208679199
pure_embedding,top_k-3,pos_chunk_00015,True,False,,[],,88.49048614501953
pure_embedding,top_k-3,neg_004,False,False,,[],,46.77629470825195
pure_embedding,top_k-3,neg_001,False,False,,[],,53.420305252075195
pure_embedding,top_k-3,pos_chunk_00014,True,False,,[],,49.99566078186035
pure_embedding,top_k-3,pos_chunk_00001,True,False,,[],,69.71168518066406
pure_embedding,top_k-3,neg_011,False,False,,[],,60.788869857788086
pure_embedding,top_k-3,pos_chunk_00002,True,True,,"[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7746990437782441}]",,149.60169792175293
pure_embedding,top_k-3,pos_chunk_00009,True,False,,[],,59.7074031829834
pure_embedding,top_k-3,neg_009,False,False,,[],,70.32513618469238
pure_embedding,top_k-3,pos_chunk_00012,True,False,,[],,59.882164001464844
pure_embedding,top_k-3,pos_chunk_00004,True,False,,[],,155.92098236083984
pure_embedding,top_k-3,neg_007,False,False,,[],,53.74264717102051
pure_embedding,top_k-3,neg_003,False,False,,[],,111.90605163574219
pure_embedding,top_k-3,pos_chunk_00007,True,False,,[],,66.54763221740723
pure_embedding,top_k-3,neg_008,False,False,,[],,51.9864559173584
pure_embedding,top_k-3,neg_005,False,False,,[],,59.801340103149414
pure_embedding,top_k-3,pos_chunk_00008,True,False,,[],,59.88001823425293
pure_embedding,top_k-3,pos_chunk_00010,True,False,,[],,82.30924606323242
pure_embedding,top_k-3,pos_chunk_00003,True,True,,"[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.865548941307772}]",,137.93706893920898
pure_embedding,top_k-3,neg_015,False,False,,[],,59.62085723876953
pure_embedding,top_k-3,neg_014,False,False,,[],,50.168752670288086
pure_embedding,top_k-3,pos_chunk_00013,True,False,,[],,50.0950813293457
pure_embedding,top_k-3,neg_012,False,False,,[],,66.30492210388184
pure_embedding,top_k-3,pos_chunk_00011,True,False,,[],,53.53593826293945
