method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
pure_embedding,top_k-5,neg_006,False,False,,[],,90.03567695617676
pure_embedding,top_k-5,neg_013,False,False,,[],,59.6776008605957
pure_embedding,top_k-5,neg_010,False,False,,[],,82.0317268371582
pure_embedding,top_k-5,neg_002,False,False,,[],,68.2682991027832
pure_embedding,top_k-5,pos_chunk_00006,True,True,,"[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.7675689217874861}]",,92.35930442810059
pure_embedding,top_k-5,pos_chunk_00005,True,False,,[],,107.32460021972656
pure_embedding,top_k-5,pos_chunk_00015,True,False,,[],,92.3614501953125
pure_embedding,top_k-5,neg_004,False,False,,[],,47.86992073059082
pure_embedding,top_k-5,neg_001,False,False,,[],,59.77582931518555
pure_embedding,top_k-5,pos_chunk_00014,True,False,,[],,51.661014556884766
pure_embedding,top_k-5,pos_chunk_00001,True,False,,[],,58.333396911621094
pure_embedding,top_k-5,neg_011,False,False,,[],,72.04532623291016
pure_embedding,top_k-5,pos_chunk_00002,True,True,,"[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7746990437782441}]",,142.6100730895996
pure_embedding,top_k-5,pos_chunk_00009,True,False,,[],,45.39299011230469
pure_embedding,top_k-5,neg_009,False,False,,[],,60.254573822021484
pure_embedding,top_k-5,pos_chunk_00012,True,False,,[],,59.882164001464844
pure_embedding,top_k-5,pos_chunk_00004,True,False,,[],,159.93404388427734
pure_embedding,top_k-5,neg_007,False,False,,[],,49.72958564758301
pure_embedding,top_k-5,neg_003,False,False,,[],,111.90605163574219
pure_embedding,top_k-5,pos_chunk_00007,True,False,,[],,58.2575798034668
pure_embedding,top_k-5,neg_008,False,False,,[],,49.80802536010742
pure_embedding,top_k-5,neg_005,False,False,,[],,50.147056579589844
pure_embedding,top_k-5,pos_chunk_00008,True,False,,[],,54.90994453430176
pure_embedding,top_k-5,pos_chunk_00010,True,False,,[],,56.91361427307129
pure_embedding,top_k-5,pos_chunk_00003,True,True,,"[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.865548941307772}]",,151.2749195098877
pure_embedding,top_k-5,neg_015,False,False,,[],,61.90967559814453
pure_embedding,top_k-5,neg_014,False,False,,[],,49.97515678405762
pure_embedding,top_k-5,pos_chunk_00013,True,False,,[],,55.045366287231445
pure_embedding,top_k-5,neg_012,False,False,,[],,65.82331657409668
pure_embedding,top_k-5,pos_chunk_00011,True,False,,[],,74.10621643066406
