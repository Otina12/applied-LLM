method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
rag,top_k-1,neg_012,False,False,"The candidate snippet implements a different algorithm with a distinct purpose and structure, focusing on counting pairs of durations rather than calculating an average. The control flow and logic are not similar to the query code.",[],"['The query code calculates an average of numbers, while the candidate snippet counts pairs based on remainders.', 'The query code uses a simple loop to sum values, whereas the candidate snippet uses a map to track frequencies and involves conditional logic based on remainders.']",3507.1277618408203
rag,top_k-1,pos_chunk_00009,True,True,"The candidate snippet is identical to the query code, with no modifications in structure or logic.","[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.8433901530201564}]","[""The function definition is exactly the same: 'func (d *Download) Size() uint64 {'"", ""The return statement is identical: 'return atomic.LoadUint64(&d.size)'""]",1992.8598403930664
rag,top_k-1,neg_008,False,False,The candidate snippet does not share any structural or functional similarities with the query code. It serves a different purpose and has a different control flow.,[],[],1829.4126987457275
rag,top_k-1,pos_chunk_00014,True,True,"The candidate snippet is identical to the query code, with no changes in structure or logic.","[{'chunk_id': 'chunk_00014', 'path': 'got\\download.go', 'text': 'func (d *Download) IsRangeable() bool {\n\treturn d.info.Rangeable\n}\n\n// Download chunks', 'similarity': 0.884463238101745}]","[""The function signature is the same: 'func (d *Download) IsRangeable() bool'."", ""The return statement is identical: 'return d.info.Rangeable'."", 'The overall structure and control flow are unchanged.']",2382.152795791626
rag,top_k-1,neg_001,False,False,The candidate snippet implements a different algorithm with a distinct structure and control flow compared to the query code.,[],"['The query code calculates the sum of a slice of integers, while the candidate snippet solves a partitioning problem with dynamic programming.', 'The query code uses a simple loop to iterate through the slice, whereas the candidate snippet employs recursion and memoization.', 'The overall logic and purpose of the two snippets are fundamentally different.']",2979.3050289154053
rag,top_k-1,neg_014,False,False,"The candidate snippet does not share any structural or functional similarities with the query code. It defines a method for a Boolean type, which is unrelated to the Contains function that checks for the presence of a target in a slice of integers.",[],[],2345.0608253479004
rag,top_k-1,pos_chunk_00013,True,True,"The structure and logic of the function are identical, with only variable names changed.",[],"['Both functions have the same signature: `func (d *Download) Write(b []byte) (int, error)`', 'Both functions calculate the length of the byte slice and store it in a variable before using it in an atomic operation.', 'The atomic operation `atomic.AddUint64(&d.size, uint64(count))` is present in both snippets, with only the variable name differing.']",2564.547538757324
rag,top_k-1,pos_chunk_00003,True,True,"The candidate snippet has a very similar structure, control flow, and logic to the query code, with only minor variations in variable names and comments.","[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.8158486467308509}]","['The function signature is identical: `func (d *Download) GetInfoOrDownload() (*Info, error)`', 'The use of `defer` statements for closing resources is present in both snippets.', 'The error handling and return statements are structured in the same way, with similar conditions checked for HTTP response status and content range.', 'The logic for parsing the content range and creating the file is almost identical, with only slight differences in wording and comments.']",5611.802816390991
rag,top_k-1,pos_chunk_00004,True,True,"The candidate snippet has a very similar structure, control flow, and logic to the query code, with only minor differences in variable names and comments.","[{'chunk_id': 'chunk_00004', 'path': 'got\\download.go', 'text': 'func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init', 'similarity': 0.7920164336219275}]","['Both snippets define a method `Init` for a `Download` struct.', 'Both snippets initialize `d.startedAt` with the current time.', 'Both snippets check if `d.Client` is nil and set it to `DefaultClient` if so.', 'Both snippets check if `d.ctx` is nil and set it to `context.Background()` if so.', 'Both snippets retrieve information using `d.GetInfoOrDownload()` and handle errors in the same way.', 'Both snippets check if `d.info.Rangeable` is false and return early if so.', 'Both snippets set `d.Concurrency` to a default value if it is zero.', 'Both snippets calculate `chunksLen` based on `d.info.Size` and `d.ChunkSize`.', 'Both snippets create a loop to initialize chunks and set their start and end values in a similar manner.']",4675.987482070923
rag,top_k-1,neg_005,False,False,The candidate snippet implements a different function (absolute value) with a different logic and control flow compared to the Fibonacci function in the query code.,[],"['The candidate snippet calculates the absolute value of a number, while the query code calculates Fibonacci numbers.', 'The control flow in the candidate snippet uses a single conditional check, whereas the query code uses recursion with two conditional checks.']",2449.8581886291504
rag,top_k-1,pos_chunk_00011,True,True,"The candidate snippet has the same structure, control flow, and logic as the query code, with only minor formatting differences.","[{'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.9247427963025426}]","['The function signature is identical: `func (d *Download) AvgSpeed() uint64 {`', 'The conditional check and return statement are the same: `if totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {` and `return uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)`', 'The return statement for the case when `totalMills` is not greater than 0 is also identical: `return 0`']",3720.8762168884277
rag,top_k-1,neg_006,False,False,"The candidate snippet implements a different algorithm with a distinct purpose and structure, focusing on partitioning and maximizing sums rather than finding the maximum value in a slice.",[],"['The candidate snippet uses recursion and memoization, which is not present in the query code.', 'The logic of finding a maximum value in a single pass is fundamentally different from the partitioning and maximizing approach in the candidate snippet.']",2277.9362201690674
rag,top_k-1,pos_chunk_00002,True,True,"The candidate snippet is nearly identical to the query code in terms of structure, control flow, and logic, with only minor differences in formatting and comments.","[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.8124552035840062}]","['The function name and signature are identical: `func TestChunksLength(t *testing.T)`.', 'The initialization of the `Download` struct is similar, including the URL and MinChunkSize.', 'The logic for checking the start and end of chunks is preserved in the same order and structure.', 'Error handling and the conditions for checking chunk values are almost verbatim, with only slight variations in wording.']",3385.0202560424805
rag,top_k-1,pos_chunk_00012,True,True,"The candidate snippet is identical to the query code, with no changes in structure, call order, or control flow.","[{'chunk_id': 'chunk_00012', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalCost() time.Duration {\n\treturn time.Now().Sub(d.startedAt)\n}\n\n// Write updates progress size.', 'similarity': 0.847264926716214}]","[""The function signature is the same: 'func (d *Download) TotalCost() time.Duration'."", ""The return statement is identical: 'return time.Now().Sub(d.startedAt)'."", ""The only addition is a comment, which does not alter the code's structure or logic.""]",2315.221071243286
rag,top_k-1,pos_chunk_00008,True,True,"The candidate snippet is identical to the query code, with no changes in structure or logic.","[{'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.947433231668069}]","[""The function signature is the same: 'func (d *Download) TotalSize() uint64 {'"", ""The return statement is identical: 'return d.info.Size'""]",2166.8922901153564
rag,top_k-1,pos_chunk_00001,True,True,"The structure, call order, and control flow of the candidate snippet closely mirror the query code, with only minor changes in variable names and formatting.","[{'chunk_id': 'chunk_00001', 'path': 'got\\chunk.go', 'text': 'func (dst *OffsetWriter) Write(b []byte) (n int, err error) {\n\tn, err = dst.WriteAt(b, dst.offset)\n\tdst.offset += int64(n)\n\treturn\n}\n\n// Chunk represents the partial content range\ntype Chunk struct {\n\tStart, End uint64\n}', 'similarity': 0.8909566975102748}]","['The function signature and parameters are identical in structure.', 'The call to `dst.WriteAt` with the same parameters is present in both snippets.', 'The increment of `dst.offset` by `int64(n)` is in the same position and logic flow in both snippets.', 'The definition of the `Chunk` struct is similar, with the same fields in the same order.']",3798.1247901916504
rag,top_k-1,pos_chunk_00007,True,False,"The candidate snippet implements a different function with a different purpose and structure, focusing on downloading a file rather than returning a context.",[],"['The query function is a method that returns a context from a struct, while the candidate snippet is a standalone function that performs a download operation.', 'The query function has a simple return statement, whereas the candidate snippet contains multiple operations including error handling and a call to another function.']",1934.2401027679443
rag,top_k-1,neg_004,False,False,The candidate snippet implements a different function (absolute value) with a different logic and control flow compared to the query function (factorial).,[],"['The query function uses recursion to calculate the factorial of a number, while the candidate snippet uses a conditional statement to return the absolute value of a number.']",2082.0066928863525
rag,top_k-1,neg_015,False,False,"The candidate snippet implements a completely different algorithm and functionality, focusing on vertical traversal of a binary tree, which does not relate to merging slices of integers.",[],"['The query code merges two slices of integers, while the candidate code performs a vertical traversal of a binary tree.', 'The data structures and control flow in the candidate snippet are entirely different from the query code.']",2927.0687103271484
rag,top_k-1,neg_002,False,False,The candidate snippet does not share any structural or functional similarities with the query code. It serves a different purpose (generating a random string) and has a different control flow and logic.,[],[],1724.327564239502
rag,top_k-1,pos_chunk_00010,True,False,"The candidate snippet does not implement the same functionality as the query code. It only retrieves the size without calculating speed, and the structure and logic are different.","[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.8427877272758555}]","[""The candidate snippet defines a function 'Size' that returns the size, while the query code defines 'Speed' that calculates the download speed based on size and interval.""]",1976.9103527069092
rag,top_k-1,pos_chunk_00006,True,True,"The candidate snippet has a very similar structure, control flow, and logic to the query code, with only minor differences in comments and formatting.","[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.8678247773793265}]","['The function signature is identical: `func (d *Download) RunProgress(fn ProgressFunc)`', 'The initialization of `d.Interval` is done in the same way, checking if it is zero and setting it to `uint64(400 / runtime.NumCPU())`', 'The use of `sleepd := time.Duration(d.Interval) * time.Millisecond` is present in both codes.', 'The loop structure is the same, with a `for` loop that checks `d.StopProgress` and uses a `select` statement to check `d.ctx.Done()`.', 'The call to `fn(d)` and the atomic operations for `lastSize` and `size` are in the same order and logic.']",4070.0511932373047
rag,top_k-1,neg_007,False,False,"The candidate snippet does not contain any functionality related to counting vowels or similar logic as in the query code. It focuses on testing operator precedence parsing, which is unrelated to the vowel counting function.",[],"['The candidate snippet is a test function for operator precedence parsing, which does not involve counting characters or vowels.', 'The query code specifically counts vowels in a string, while the candidate code tests parsing of mathematical expressions.']",2333.1236839294434
rag,top_k-1,pos_chunk_00015,True,True,"The structure, control flow, and overall logic of the function are nearly identical to the query code, with only minor variations in variable names and comments.","[{'chunk_id': 'chunk_00015', 'path': 'got\\download.go', 'text': 'func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts', 'similarity': 0.8793595501963727}]","['Both snippets define a method `dl` on a `Download` struct.', 'Both use a `sync.WaitGroup` to manage concurrent downloads.', 'Both implement a concurrency limit using a buffered channel.', 'The logic for downloading chunks and handling errors is almost identical.']",2482.7871322631836
rag,top_k-1,neg_010,False,False,The candidate snippet implements a different functionality (reading a string) and does not share structural or control flow similarities with the query code (word counting).,[],[],1249.6449947357178
rag,top_k-1,neg_009,False,False,The candidate snippet implements a different algorithm (max sum after partitioning) and does not share structural or control flow similarities with the BubbleSort function.,[],[],1379.3280124664307
rag,top_k-1,neg_011,False,False,"The candidate snippet does not contain any code related to the functionality of converting a string to uppercase. It is a test function for operator precedence parsing, which is unrelated to the query function.",[],[],1504.1897296905518
rag,top_k-1,neg_003,False,False,The candidate snippet implements a different functionality (absolute value calculation) and does not share structural or logical similarities with the query function (unique integer extraction).,[],"['Different functionality (absolute value vs unique integers)', 'Different data structures used (map vs simple integer return)', 'Different control flow and logic']",1718.4488773345947
rag,top_k-1,pos_chunk_00005,True,True,"The candidate snippet has a similar structure, control flow, and logic to the query code, including the handling of context cancellation and error management.",[],"['Both snippets define a method `Start` for a `Download` struct.', 'Both snippets check if `d.info.Rangeable` is false and handle context cancellation with `select` statements.', 'Both snippets create a file using `os.Create` and defer closing the file.', 'Both snippets use a channel to handle errors from a download function and wait for completion using `select` statements.']",2231.3475608825684
rag,top_k-1,neg_013,False,False,The candidate snippet does not share any structural or functional similarities with the query code. It performs a different operation (loading an atomic integer) and does not involve iterating over a slice or counting even numbers.,[],"['The query code counts even numbers in a slice of integers.', 'The candidate snippet retrieves a total count from an atomic variable, which is unrelated to counting even numbers.']",3616.2731647491455
