method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
rag,top_k-1,neg_006,False,False,"The candidate snippet implements a different algorithm with a distinct purpose and structure, focusing on partitioning and dynamic programming rather than finding the maximum value in a slice.",[],"['The candidate snippet uses recursion and memoization, which is not present in the query code.', 'The logic of finding a maximum value is embedded within a more complex algorithm that calculates a maximum sum after partitioning, which is unrelated to the simple maximum finding in the query code.']",2213.52219581604
rag,top_k-1,neg_013,False,False,The candidate snippet does not share any structural or functional similarities with the query code. It performs a different operation (loading an atomic integer) and does not involve counting or iterating over a slice of integers.,[],[],1547.8897094726562
rag,top_k-1,neg_010,False,False,The candidate snippet implements a different functionality (reading a string) and does not share structural or control flow similarities with the query code (word counting).,[],[],1223.4382629394531
rag,top_k-1,neg_002,False,False,The candidate snippet does not share any structural or functional similarities with the query code. It serves a different purpose (generating a random string) and has a different control flow and logic.,[],[],1603.4281253814697
rag,top_k-1,pos_chunk_00006,True,True,"The structure, control flow, and overall logic of the code are very similar, with only minor changes in variable names and comments.","[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.7675689217874861}]","['Both functions are methods of a struct named Download.', 'Both functions check if an interval is set to zero and assign a default value based on the number of CPU cores.', 'Both functions enter an infinite loop that checks a stop condition.', 'Both functions use a select statement to check for a done signal from a context or similar mechanism.', 'Both functions call a progress function with the current instance as an argument.', 'Both functions update a value using atomic operations and then sleep for a specified duration.']",2465.7857418060303
rag,top_k-1,pos_chunk_00005,True,False,The candidate snippet implements a different functionality (progress tracking) and has a distinct structure and control flow compared to the query code (download starting and error handling).,[],[],1089.8592472076416
rag,top_k-1,pos_chunk_00015,True,True,"The structure, control flow, and overall logic of the code are very similar, with only minor changes in variable names and comments. Both snippets implement a concurrent download mechanism using goroutines and a wait group, and they handle errors in a similar manner.","[{'chunk_id': 'chunk_00015', 'path': 'got\\download.go', 'text': 'func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts', 'similarity': 0.7422878679350746}]","['Both functions are methods of a struct named Download.', 'Both use a sync.WaitGroup to wait for goroutines to finish.', 'Both use a channel to limit concurrency and handle errors.', 'The logic for downloading chunks and writing them to a destination is nearly identical, with only slight variations in variable names and comments.']",2277.8172492980957
rag,top_k-1,neg_004,False,False,The candidate snippet implements a different functionality (absolute value) and has a different structure and control flow compared to the query code (factorial calculation).,[],"['Different function purpose (abs vs. factorial)', 'Different control flow (if condition checks for negative vs. zero)', 'Different recursive structure (factorial uses recursion, abs does not)']",1682.2106838226318
rag,top_k-1,neg_001,False,False,"The candidate snippet implements a different algorithm with a distinct purpose and structure, focusing on finding divisors and checking for primality, rather than summing elements of a slice.",[],"['The function name and purpose are different (sumFourDivisors vs. SumSlice).', 'The logic involves checking for prime numbers and divisors, which is unrelated to summing integers.', 'The control flow and structure (nested loops, conditions) are significantly different from the simple summation in the query code.']",3086.811065673828
rag,top_k-1,pos_chunk_00014,True,False,"The structure and logic of the function differ significantly, with different receiver types and return types.",[],"[""Different receiver variable names ('counter' vs 'd')"", 'Different return types (node vs bool)', 'Different properties accessed (result.Rangeable vs info.Rangeable)']",1529.3090343475342
rag,top_k-1,pos_chunk_00001,True,True,"The structure and control flow of the Write function are very similar, with both functions performing a write operation and updating an index/offset based on the result of a write-at operation. The Chunk struct is also similar in terms of its fields, differing only in type.","[{'chunk_id': 'chunk_00001', 'path': 'got\\chunk.go', 'text': 'func (dst *OffsetWriter) Write(b []byte) (n int, err error) {\n\tn, err = dst.WriteAt(b, dst.offset)\n\tdst.offset += int64(n)\n\treturn\n}\n\n// Chunk represents the partial content range\ntype Chunk struct {\n\tStart, End uint64\n}', 'similarity': 0.6525348046817768}]","['Both functions are methods of a struct that perform a write operation.', ""Both functions call a 'WriteAt' method with similar parameters and update an index/offset based on the result."", 'The structure of the Chunk type is almost identical, differing only in the type of its fields.']",2551.567554473877
rag,top_k-1,neg_011,False,False,"The candidate snippet does not contain any code related to the functionality of converting a string to uppercase. It is a test function for operator precedence parsing, which is unrelated to the query function.",[],[],1615.9687042236328
rag,top_k-1,pos_chunk_00002,True,True,"The candidate snippet has a very similar structure, logic, and flow to the query code, with only minor changes in variable names and error messages.","[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7746990437782441}]","['The function name and signature are identical.', 'The initialization of the Download struct is almost the same, with only the URL differing.', 'The logic for checking the initialization of the Download object is similar, with the same control flow and error handling.', 'The chunk definitions and their checks are nearly identical in structure and logic, with only slight variations in wording.']",4208.595275878906
rag,top_k-1,pos_chunk_00009,True,False,"The candidate snippet has a different structure and variable names, and it uses a different method to retrieve the size (atomic.LoadUint64 instead of result.LoadUint64).","[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.6666778592823166}]","[""Different receiver variable name ('d' vs 'entry')"", ""Different field being accessed ('d.size' vs 'entry.flag')"", ""Different return type ('uint64' vs 'tmp')"", 'Different method of loading the value (atomic.LoadUint64 vs result.LoadUint64)']",2662.353515625
rag,top_k-1,neg_009,False,False,The candidate snippet implements a different algorithm (max sum after partitioning) and does not share structural similarities with the Bubble Sort function.,[],[],1329.9081325531006
rag,top_k-1,pos_chunk_00012,True,True,"The structure and logic of the function are very similar, with both functions calculating a duration based on a starting point and the current time.",[],"['Both functions are methods of a struct related to downloads.', 'Both functions return a duration calculated by subtracting a timestamp from the current time.', ""The use of 'Now()' and 'Sub()' methods is identical in both snippets.""]",1831.3872814178467
rag,top_k-1,pos_chunk_00004,True,True,"The structure, control flow, and overall logic of the code are very similar, with only minor changes in variable names and comments. Both snippets perform the same operations in a similar order, indicating a high degree of similarity.","[{'chunk_id': 'chunk_00004', 'path': 'got\\download.go', 'text': 'func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init', 'similarity': 0.6958946394984911}]","['Both functions initialize a download process with similar steps: setting start time, checking and setting default values for client and context, retrieving information about the download, checking if the content is rangeable, setting concurrency and chunk size, and creating chunks with start and end ranges.', 'The use of similar control structures (if statements, for loops) and the overall flow of the function is nearly identical, despite some differences in variable names and comments.']",3737.9603385925293
rag,top_k-1,neg_007,False,False,The candidate snippet does not contain any functionality related to counting vowels. It is focused on testing operator precedence parsing and does not share any structural or logical similarities with the query code.,[],[],1105.2732467651367
rag,top_k-1,neg_003,False,False,The candidate snippet does not share any structural or functional similarities with the query code. It implements a completely different functionality (calculating the absolute value of an integer) and has a different control flow and logic.,[],[],1374.8254776000977
rag,top_k-1,pos_chunk_00007,True,False,"The candidate snippet implements a different function with a different purpose and structure, focusing on downloading a file rather than returning a context from a struct.",[],"['The query function is a method that returns a context from a struct, while the candidate snippet is a standalone function that performs a download operation.', 'The query function has a simple return statement, whereas the candidate snippet contains multiple operations including error handling and a call to another function.']",1850.4974842071533
rag,top_k-1,neg_008,False,False,"The candidate snippet implements a different algorithm for checking palindromes, including handling non-alphanumeric characters and case sensitivity, which is not present in the query code.","[{'chunk_id': 'chunk_00187', 'path': 'leetcode-go\\125-valid-palindrome\\valid-palindrome.go', 'text': 'func isPalindrome(s string) bool {\n\tleft, right := 0, len(s) - 1\n\n\tfor left < right {\n\t\tif isNonAlphaNumeric(s[left]) {\n\t\t\tleft += 1\n\t\t\tcontinue\n\t\t}\n\t\tif isNonAlphaNumeric(s[right]) {\n\t\t\tright -= 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) {\n\t\t\treturn false\n\t\t}\n\n\t\tleft += 1\n\t\tright -= 1\n\t}\n\n\treturn true\n}', 'similarity': 0.7081730569137222}]","['The query code checks for palindromes without considering non-alphanumeric characters or case sensitivity.', 'The candidate snippet uses a two-pointer technique with additional checks for non-alphanumeric characters and case normalization.']",1732.4132919311523
rag,top_k-1,neg_005,False,False,The candidate snippet implements a completely different algorithm (counting equivalent domino pairs) and does not share any structural or logical similarities with the Fibonacci function.,[],[],1050.5523681640625
rag,top_k-1,pos_chunk_00008,True,False,"The structure and logic of the code are different. The query function accesses a field named 'flag' while the candidate accesses 'info'. Additionally, the receiver variable names differ, and the return types are not the same.","[{'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.6703809992248383}]","[""Different receiver variable names ('item' vs 'd')"", ""Different field accessed ('flag.Size' vs 'info.Size')"", 'Different return types (cnt vs uint64)']",1915.165662765503
rag,top_k-1,pos_chunk_00010,True,True,"The structure and logic of the function are nearly identical, with only minor changes in variable names and types.",[],"['Both functions calculate a speed based on the difference of two atomic values divided by an interval and multiplied by 1000.', 'The use of atomic operations (LoadUint64) is consistent in both snippets.', 'The overall formula and control flow are the same, indicating a high level of similarity.']",2352.1790504455566
rag,top_k-1,pos_chunk_00003,True,True,"The candidate snippet has a very similar structure, call order, and control flow to the query code, despite some differences in variable names and comments.","[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.865548941307772}]","['Both functions have the same signature and purpose.', 'The variable declarations and error handling are structured similarly.', 'The logic for creating the request, handling the response, and processing the content is almost identical.', 'Both snippets check the response status code and handle errors in the same way.', ""The handling of the 'content-range' header and the parsing of its value are nearly the same.""]",2598.788022994995
rag,top_k-1,neg_015,False,False,"The candidate snippet implements a completely different algorithm and functionality, focusing on vertical traversal of a binary tree, which is unrelated to the merging of slices in the query code.",[],"['The query code merges two slices of integers, while the candidate snippet performs a vertical traversal of a binary tree.', 'The data structures used (slices vs. maps) and the overall logic are distinct and serve different purposes.']",2022.249460220337
rag,top_k-1,neg_014,False,False,"The candidate snippet does not share any structural or functional similarities with the query code. It defines a method for a Boolean type, which is unrelated to the Contains function that checks for the presence of a target in a slice of integers.",[],[],1313.9915466308594
rag,top_k-1,pos_chunk_00013,True,False,"The structure and functionality of the candidate snippet differ significantly from the query code. The query code involves a specific operation on a custom type 'counter' and returns a node and an index, while the candidate snippet operates on a byte slice and returns an integer and an error. The control flow and operations performed are not similar enough to indicate plagiarism.",[],"['Different parameter types (entry vs. b)', 'Different return types (current, flag vs. int, error)', 'Different operations performed (cnt(node) vs. atomic.AddUint64)']",3047.149181365967
rag,top_k-1,neg_012,False,False,"The candidate snippet implements a different algorithm with a distinct purpose and structure, focusing on counting pairs of durations rather than calculating an average. The control flow and logic are not similar to the query code.",[],"['The query code calculates an average of numbers, while the candidate snippet counts pairs based on remainders.', 'The query code uses a simple loop to sum values, whereas the candidate snippet uses a map to track frequencies and involves conditional logic based on remainders.']",1999.405860900879
rag,top_k-1,pos_chunk_00011,True,True,"The structure, control flow, and logic of the function are very similar, despite differences in variable names and types.","[{'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.7398795150144943}]","['Both functions are methods of a struct related to download functionality.', 'Both functions check if a duration (in milliseconds) is greater than zero before performing a calculation.', 'Both functions perform a calculation involving a division of a value by the duration, multiplied by 1000.']",1934.8070621490479
