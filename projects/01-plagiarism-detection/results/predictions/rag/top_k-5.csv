method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
rag,top_k-5,neg_006,False,False,"The candidate snippets do not share structural similarities, control flow, or logic with the query code. Each candidate implements different algorithms and functionalities that do not resemble the FindMax function's approach to finding the maximum value in a slice.",[],[],1656.8851470947266
rag,top_k-5,neg_013,False,False,"The candidate snippets do not share structural similarities, control flow, or logic with the query code. They implement different functionalities and algorithms.",[],[],1204.8826217651367
rag,top_k-5,neg_010,False,False,The candidate snippets do not share structural or functional similarities with the query code. They serve different purposes and have distinct control flows.,[],[],1062.2289180755615
rag,top_k-5,neg_002,False,False,The candidate snippets do not share structural similarities or control flow with the query function. They serve different purposes and implement different algorithms.,[],[],949.0706920623779
rag,top_k-5,pos_chunk_00006,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. Both snippets implement a method that runs a progress function in a loop, checking for a stop condition and using a sleep interval based on a calculated duration.","[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.7675689217874861}]","['Both snippets define a method on a struct named Download.', 'Both methods check if a stop condition is met and break out of the loop if true.', 'Both methods use a select statement to check for a context done signal or continue execution.', 'Both methods call a progress function with the Download struct as an argument.', 'Both methods update a size variable using atomic operations.']",3659.6808433532715
rag,top_k-5,pos_chunk_00005,True,True,"The candidate snippet [3] has a similar structure, control flow, and logic to the query code, particularly in handling the rangeable check, file creation, truncation, and goroutine for downloading.",[],"['Both functions check if the item is rangeable and handle the context done case similarly.', 'Both functions create a file and truncate it to the total size before starting the download in a goroutine.', 'The overall flow of checking conditions, creating files, and handling errors is very similar.']",1973.968505859375
rag,top_k-5,pos_chunk_00015,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. Both snippets implement a concurrent download function using goroutines and a wait group, and they share similar variable names and patterns for error handling and channel usage.","[{'chunk_id': 'chunk_00015', 'path': 'got\\download.go', 'text': 'func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts', 'similarity': 0.7422878679350746}]","['Both snippets define a function with the same name and parameters.', 'Both use a `sync.WaitGroup` to manage concurrent downloads.', 'Both use a buffered channel to limit concurrency.', 'The error handling logic is almost identical, including the use of a deferred call to `Done()` on the wait group.', 'The logic for downloading chunks and writing to the destination is structurally the same.']",2642.9243087768555
rag,top_k-5,neg_004,False,False,The candidate snippets do not share any structural or functional similarities with the query code. They implement different functionalities and do not exhibit any resemblance in control flow or logic.,[],[],1174.579381942749
rag,top_k-5,neg_001,False,False,The candidate snippets do not share structural similarities or control flow with the query code. They implement different algorithms and functionalities unrelated to the summation of a slice of integers.,[],[],1321.4507102966309
rag,top_k-5,pos_chunk_00014,True,False,The candidate snippets do not contain any code that is structurally or functionally similar to the query code. They serve different purposes and have different implementations.,[],[],1377.2521018981934
rag,top_k-5,pos_chunk_00001,True,True,"The candidate snippet [1] has a similar structure and control flow to the query code, with both implementing a `Write` method that updates an index and returns values. The variable names and types differ, but the overall logic and method signature are closely aligned.","[{'chunk_id': 'chunk_00001', 'path': 'got\\chunk.go', 'text': 'func (dst *OffsetWriter) Write(b []byte) (n int, err error) {\n\tn, err = dst.WriteAt(b, dst.offset)\n\tdst.offset += int64(n)\n\treturn\n}\n\n// Chunk represents the partial content range\ntype Chunk struct {\n\tStart, End uint64\n}', 'similarity': 0.6525348046817768}]","['Both snippets define a method on a struct that writes data and updates an index.', 'Both methods return two values, one of which is an updated index or count.', 'The logic of calling a write-at method and then updating an index based on the result is present in both snippets.']",2968.5451984405518
rag,top_k-5,neg_011,False,False,"The candidate snippets do not share structural or functional similarities with the query code. They focus on different functionalities such as parsing, string manipulation, and character checks, which do not relate to converting a string to uppercase.",[],[],1248.47412109375
rag,top_k-5,pos_chunk_00002,True,True,"The candidate snippet [1] closely resembles the query code in structure, logic, and control flow, with only minor variations in wording and comments.","[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7746990437782441}]","['Function name and signature are identical: `func TestChunksLength(t *testing.T)`', 'The initialization of the `Download` struct is almost identical, with the same URL and `MinChunkSize` value.', 'The logic for checking the initialization of the download and error handling is structurally the same.', 'The chunk definitions (`chunk0` and `chunk1`) have the same start and end values and are used in the same way.', 'The error messages and conditions for checking the chunk values are very similar, with only slight changes in wording.']",3218.479633331299
rag,top_k-5,pos_chunk_00009,True,False,The candidate snippets do not share structural similarities or control flow with the query code. They implement different functionalities and have different variable names and return types.,"[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.6666778592823166}, {'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.6642737756230302}]",[],1232.2680950164795
rag,top_k-5,neg_009,False,False,"The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and data structures, and there is no overlap in logic or control flow.",[],[],1138.031244277954
rag,top_k-5,pos_chunk_00012,True,True,"The candidate snippet [1] has a similar structure and functionality to the query code, specifically in the method signature and the use of time calculation.",[],"['Both functions are methods of a struct (Download).', 'Both functions calculate a duration based on the current time and a starting point.', ""The use of 'time.Now().Sub' in candidate [1] mirrors the 'cnt.Now().Sub' in the query code.""]",1895.2665328979492
rag,top_k-5,pos_chunk_00004,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. Both snippets perform similar tasks in initializing a download, including setting default values, checking conditions, and creating chunks. The variable names and comments differ slightly, but the overall approach and sequence of operations are nearly identical, indicating potential plagiarism.","[{'chunk_id': 'chunk_00004', 'path': 'got\\download.go', 'text': 'func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init', 'similarity': 0.6958946394984911}]","['Both snippets define a method `Init` for the `Download` struct.', 'Both methods initialize the `startedAt` timestamp using `time.Now()`.', 'Both methods check if a client is set and assign a default client if not.', 'Both methods retrieve information about the download using a method called `GetInfoOrDownload` and handle errors similarly.', 'Both methods check if the file is rangeable and return early if it is not.', 'Both methods set default values for `Concurrency` and `ChunkSize` if they are zero.', 'Both methods calculate the number of chunks based on the size and chunk size, and create a slice to hold the chunks.', 'Both methods use a loop to set the start and end of each chunk, with similar logic for handling the last chunk.']",4132.841110229492
rag,top_k-5,neg_007,False,False,"The candidate snippets do not contain any code that is structurally or functionally similar to the query code for counting vowels. They focus on different functionalities such as token parsing, testing, and string manipulation, which do not overlap with the logic of counting vowels in a string.",[],[],2119.619131088257
rag,top_k-5,neg_003,False,False,The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and do not exhibit any overlapping logic or control flow.,[],[],1297.7941036224365
rag,top_k-5,pos_chunk_00007,True,False,"The query code and candidate snippets have different functionalities and structures. The query code is a simple method returning a field from a struct, while the candidates involve more complex operations related to downloading and context management.",[],"['The query code is a method of a struct that returns a field: `return tmp.node`.', 'Candidate snippets involve downloading logic, context handling, and other operations that do not relate to the simple return of a field.']",2532.938003540039
rag,top_k-5,neg_008,False,False,"The candidate snippets implement different logic and functionality compared to the query code. The query code checks for palindromes without considering non-alphanumeric characters or case sensitivity, while candidate snippet [1] includes additional checks for non-alphanumeric characters and case insensitivity, making it a different implementation altogether.","[{'chunk_id': 'chunk_00187', 'path': 'leetcode-go\\125-valid-palindrome\\valid-palindrome.go', 'text': 'func isPalindrome(s string) bool {\n\tleft, right := 0, len(s) - 1\n\n\tfor left < right {\n\t\tif isNonAlphaNumeric(s[left]) {\n\t\t\tleft += 1\n\t\t\tcontinue\n\t\t}\n\t\tif isNonAlphaNumeric(s[right]) {\n\t\t\tright -= 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) {\n\t\t\treturn false\n\t\t}\n\n\t\tleft += 1\n\t\tright -= 1\n\t}\n\n\treturn true\n}', 'similarity': 0.7081730569137222}]","['Candidate snippet [1] implements a different algorithm that handles non-alphanumeric characters and case sensitivity.', 'The query code uses a simple two-pointer technique to check for palindromes, while candidate snippet [1] uses a more complex approach with additional checks.']",2433.3503246307373
rag,top_k-5,neg_005,False,False,The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and have different control flows.,[],[],1240.5643463134766
rag,top_k-5,pos_chunk_00008,True,False,"The candidate snippets do not share structural or functional similarities with the query code. They implement different methods and functionalities related to the Download struct, and the TotalSize method in the candidates has different implementations and contexts.","[{'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.6703809992248383}, {'chunk_id': 'chunk_00007', 'path': 'got\\download.go', 'text': 'func (d *Download) Context() context.Context {\n\treturn d.ctx\n}\n\n// TotalSize returns file total size (0 if unknown).', 'similarity': 0.6541719878949522}]",[],1490.201711654663
rag,top_k-5,pos_chunk_00010,True,True,"The candidate snippet [1] has a similar structure and logic to the query code, including the use of atomic operations to load values and the calculation of speed based on a time interval.",[],"['Both functions are methods of a struct named Download.', 'Both functions calculate speed based on the difference of two atomic loaded values divided by an interval and multiplied by 1000.', 'The use of atomic.LoadUint64 is consistent in both snippets.']",2001.5993118286133
rag,top_k-5,pos_chunk_00003,True,True,"The candidate snippet [1] has a high degree of similarity to the query code in terms of structure, control flow, and logic, despite some differences in variable names and comments.","[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.865548941307772}, {'chunk_id': 'chunk_00017', 'path': 'got\\download.go', 'text': 'func (d *Download) DownloadChunk(c *Chunk, dest io.Writer) error {\n\n\tvar (\n\t\terr error\n\t\treq *http.Request\n\t\tres *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, d.Header); err != nil {\n\t\treturn err\n\t}\n\n\tcontentRange := fmt.Sprintf(""bytes=%d-%d"", c.Start, c.End)\n\treq.Header.Set(""Range"", contentRange)\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify the length\n\tif res.ContentLength != int64(c.End-c.Start+1) {\n\t\treturn fmt.Errorf(\n\t\t\t""Range request returned invalid Content-Length: %d however the range was: %s"",\n\t\t\tres.ContentLength, contentRange,\n\t\t)\n\t}\n\n\tdefer res.Body.Close()\n\n\t_, err = io.CopyN(dest, io.TeeReader(res.Body, d), res.ContentLength)\n\n\treturn err\n}\n\n// NewDownload returns new *Download with context.', 'similarity': 0.6945224669971536}]","['The function signature and return types are identical.', 'The use of error handling and the structure of the if statements are very similar.', 'The logic for creating the request and handling the response is almost identical, including the checks for status codes and content ranges.', 'The way the unsafe name is set from the response header is also similar, with only minor changes in the header name.']",2569.5605278015137
rag,top_k-5,neg_015,False,False,"The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and data structures, and there is no overlap in logic or flow.",[],[],1581.4225673675537
rag,top_k-5,neg_014,False,False,The candidate snippets do not share structural or functional similarities with the query code.,[],[],1130.815029144287
rag,top_k-5,pos_chunk_00013,True,False,The candidate snippets do not share structural or functional similarities with the query code. They implement different functionalities and have distinct control flows.,[],[],1060.2362155914307
rag,top_k-5,neg_012,False,False,"The candidate snippets do not share structural similarities, control flow, or logic with the query code. They implement different functionalities unrelated to calculating an average.",[],[],1143.676996231079
rag,top_k-5,pos_chunk_00011,True,True,"The candidate snippet [1] has a similar structure and logic to the query code, including the use of atomic operations, the calculation of average speed based on total milliseconds, and the overall flow of the function.","[{'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.7398795150144943}, {'chunk_id': 'chunk_00010', 'path': 'got\\download.go', 'text': 'func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.', 'similarity': 0.6672923205673673}]","['Both functions are methods of a struct related to download functionality.', 'Both functions check if a duration (milliseconds) is greater than zero before performing a calculation.', 'Both functions use atomic operations to read a value and perform a division to calculate speed.']",2449.852228164673
