method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
rag,rag_top_k12,neg_002,False,False,The candidate snippets do not share any structural or functional similarities with the query code. They serve different purposes and implement different functionalities.,[],[],1271.665096282959
rag,rag_top_k12,neg_005,False,False,The candidate snippets do not share any structural or functional similarities with the query code for the Fibonacci function. Each candidate implements different logic and algorithms unrelated to the Fibonacci sequence calculation.,[],[],1839.7307395935059
rag,rag_top_k12,neg_013,False,False,"The candidate snippets do not share structural similarities, control flow, or logic with the query function. They serve different purposes and implement different algorithms.",[],[],1593.8973426818848
rag,rag_top_k12,pos_chunk_00010,True,True,"The candidate snippet [2] contains an identical implementation of the query function, including the same logic and structure, making it a direct copy.","[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.8427877272758555}, {'chunk_id': 'chunk_00010', 'path': 'got\\download.go', 'text': 'func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.', 'similarity': 0.813157274634057}, {'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.76831317061961}]",['Candidate snippet [2] has the exact same function signature and body as the query code.'],1649.8329639434814
rag,rag_top_k12,neg_004,False,False,The candidate snippets do not share any structural or functional similarities with the query code for the Factorial function. They implement different functionalities and do not exhibit any resemblance in control flow or logic.,[],[],1537.726640701294
rag,rag_top_k12,neg_001,False,False,The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and functionalities unrelated to the summation of a slice of integers.,[],[],1571.9084739685059
rag,rag_top_k12,pos_chunk_00011,True,True,"The candidate snippet [1] has a similar structure and control flow to the query code, with the same logic for calculating average speed and the same conditional check for total milliseconds.","[{'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.9327829612208552}, {'chunk_id': 'chunk_00010', 'path': 'got\\download.go', 'text': 'func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.', 'similarity': 0.7829313366111307}]","['Candidate snippet [1] has the same function signature and purpose as the query code.', 'The logic for calculating the average speed is identical in both the query and candidate snippet [1].', 'The conditional check for total milliseconds is present in both the query and candidate snippet [1] in the same order.']",2095.1058864593506
rag,rag_top_k12,neg_010,False,False,The candidate snippets do not share structural or functional similarities with the query code. They serve different purposes and do not exhibit any significant overlap in logic or implementation.,[],[],1585.1383209228516
rag,rag_top_k12,pos_chunk_00008,True,True,"The candidate snippet [1] is identical to the query code, indicating direct copying without modification.","[{'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.947433231668069}]",['Candidate snippet [1] is identical to the query code.'],1239.9518489837646
rag,rag_top_k12,pos_chunk_00014,True,True,"The candidate snippet [1] contains an exact copy of the query function, which indicates plagiarism.","[{'chunk_id': 'chunk_00014', 'path': 'got\\download.go', 'text': 'func (d *Download) IsRangeable() bool {\n\treturn d.info.Rangeable\n}\n\n// Download chunks', 'similarity': 0.884463238101745}]",['Candidate snippet [1] has the exact same function definition and body as the query code.'],1966.5131568908691
rag,rag_top_k12,pos_chunk_00003,True,True,"The candidate snippet [1] has a high degree of similarity to the query code, including the same structure, control flow, and logic for handling HTTP requests and responses, as well as error handling and variable names.","[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.7881016919471014}, {'chunk_id': 'chunk_00017', 'path': 'got\\download.go', 'text': 'func (d *Download) DownloadChunk(c *Chunk, dest io.Writer) error {\n\n\tvar (\n\t\terr error\n\t\treq *http.Request\n\t\tres *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, d.Header); err != nil {\n\t\treturn err\n\t}\n\n\tcontentRange := fmt.Sprintf(""bytes=%d-%d"", c.Start, c.End)\n\treq.Header.Set(""Range"", contentRange)\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify the length\n\tif res.ContentLength != int64(c.End-c.Start+1) {\n\t\treturn fmt.Errorf(\n\t\t\t""Range request returned invalid Content-Length: %d however the range was: %s"",\n\t\t\tres.ContentLength, contentRange,\n\t\t)\n\t}\n\n\tdefer res.Body.Close()\n\n\t_, err = io.CopyN(dest, io.TeeReader(res.Body, d), res.ContentLength)\n\n\treturn err\n}\n\n// NewDownload returns new *Download with context.', 'similarity': 0.782558950682046}]","['The function signature is identical: `func (d *Download) GetInfoOrDownload() (*Info, error)`', 'The error handling and return statements are structured in the same way, including the use of `fmt.Errorf` for error messages.', 'The logic for checking the response status code and handling the content-range header is nearly identical, including the parsing of the content-range string and the creation of the `Info` struct with `Size` and `Rangeable` fields.']",3344.712495803833
rag,rag_top_k12,pos_chunk_00015,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. It implements the same functionality of downloading chunks concurrently with a wait group and a channel for error handling, with only minor variations in variable names and comments.","[{'chunk_id': 'chunk_00015', 'path': 'got\\download.go', 'text': 'func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts', 'similarity': 0.8800490653690556}]","['The use of a wait group (`wg`) to manage concurrent downloads is identical in both snippets.', 'The channel for concurrency control (`max`) is implemented in the same way, with the same logic for sending and receiving values.', 'The error handling mechanism using `errC` is also consistent between the two snippets, with similar checks for errors during chunk downloads.']",3479.5315265655518
rag,rag_top_k12,neg_009,False,False,"The candidate snippets do not share any structural or functional similarities with the query code for BubbleSort. Each candidate implements different algorithms and data structures, and there is no overlap in logic or control flow.",[],[],1708.2834243774414
rag,rag_top_k12,neg_008,False,False,The candidate snippets do not share any structural or functional similarities with the query code for checking palindromes.,[],[],1459.5952033996582
rag,rag_top_k12,neg_007,False,False,"The candidate snippets do not contain any code that is structurally or functionally similar to the query code for counting vowels. They focus on different functionalities such as token parsing and testing, which do not overlap with the logic of counting vowels in a string.",[],[],2388.850450515747
rag,rag_top_k12,neg_014,False,False,The candidate snippets do not share structural or functional similarities with the query code.,[],[],1433.4266185760498
rag,rag_top_k12,pos_chunk_00012,True,True,"The candidate snippet [1] contains an exact copy of the query function, which indicates plagiarism.","[{'chunk_id': 'chunk_00012', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalCost() time.Duration {\n\treturn time.Now().Sub(d.startedAt)\n}\n\n// Write updates progress size.', 'similarity': 0.847264926716214}]",['Candidate snippet [1] has the same function definition and implementation as the query code.'],1743.0438995361328
rag,rag_top_k12,pos_chunk_00007,True,True,"The candidate snippet [3] contains the exact same function definition as the query code, indicating direct copying.",[],['Candidate snippet [3] contains the exact function: `func (d *Download) Context() context.Context { return d.ctx }` which matches the query code.'],2293.867349624634
rag,rag_top_k12,neg_006,False,False,The candidate snippets do not share any structural or functional similarities with the query code. Each candidate implements different algorithms and logic unrelated to the task of finding the maximum value in a slice of integers.,[],[],2014.1260623931885
rag,rag_top_k12,pos_chunk_00006,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. It implements the same functionality with only minor variations in comments and formatting, indicating a high likelihood of plagiarism.","[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.8737930358492714}]","['The function signature and method receiver are identical: `func (d *Download) RunProgress(fn ProgressFunc)`.', 'The logic for setting the default interval is the same: `if d.Interval == 0 { d.Interval = uint64(400 / runtime.NumCPU()) }`.', 'The loop structure and the use of `select` for context checking are identical.', 'The sequence of operations within the loop (checking `d.StopProgress`, calling `fn(d)`, updating `lastSize`, and sleeping) is preserved in the same order.']",3412.043809890747
rag,rag_top_k12,pos_chunk_00009,True,True,"The candidate snippet [1] contains the exact same implementation of the Size() function as the query code, with no modifications or differences in structure, call order, or control flow.","[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.8433901530201564}]",['Candidate snippet [1] is identical to the query code.'],2973.679780960083
rag,rag_top_k12,neg_011,False,False,"The candidate snippets do not contain any code that is structurally or functionally similar to the query function. They focus on different functionalities related to parsing and tokenization, while the query function specifically converts a string to uppercase.",[],[],1960.3238105773926
rag,rag_top_k12,pos_chunk_00005,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. It implements the same functionality of starting a download, handling errors, and managing file operations in a similar manner, indicating a high degree of similarity.",[],"['Both snippets define a method `Start` for a `Download` struct.', 'Both snippets check if the file is rangeable and handle the case where it is not.', 'Both snippets create a file and defer its closure.', 'Both snippets use a channel to handle errors from a goroutine that downloads chunks.', 'The overall flow of error handling and context cancellation is nearly identical.']",3435.4851245880127
rag,rag_top_k12,neg_015,False,False,"The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and data structures, and there is no overlap in logic or flow.",[],[],3644.2527770996094
rag,rag_top_k12,neg_012,False,False,The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and functionalities unrelated to calculating an average of numbers.,[],[],2863.986015319824
rag,rag_top_k12,pos_chunk_00002,True,True,"The candidate snippet [1] is nearly identical to the query code, with only minor differences in formatting and comments. The structure, control flow, and logic are the same, indicating a high likelihood of plagiarism.","[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7723971455972203}]","['The function name and signature are identical: `func TestChunksLength(t *testing.T)`', 'The initialization of the `Download` struct is the same, including the URL and `MinChunkSize` values.', 'The error handling and checks for chunk start and end values are structured identically, with the same error messages.', 'The overall flow of the function, including the order of operations and conditions, is preserved in the candidate snippet.']",4082.653045654297
rag,rag_top_k12,pos_chunk_00013,True,True,"The candidate snippet [1] has a function that is structurally and functionally identical to the query code, with only minor variable name changes. The logic and control flow are the same, indicating a high likelihood of plagiarism.",[],"['Candidate snippet [1] has the same function signature and logic as the query code.', 'Both snippets use atomic operations to update a size variable and return the length of the byte slice.']",2447.2756385803223
rag,rag_top_k12,neg_003,False,False,"The candidate snippets do not share structural or functional similarities with the query code. They implement different algorithms and data structures, and there is no overlap in logic or control flow.",[],[],1594.0263271331787
rag,rag_top_k12,pos_chunk_00004,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. It contains identical variable names, function calls, and the overall sequence of operations is nearly the same, indicating a high likelihood of plagiarism.","[{'chunk_id': 'chunk_00004', 'path': 'got\\download.go', 'text': 'func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init', 'similarity': 0.787616168602992}]","['Both snippets define a method `Init` for the `Download` struct.', 'The logic for checking if `d.Client` and `d.ctx` are nil is present in both snippets.', 'The calculation of `chunksLen` and the creation of chunks is almost identical in both snippets.', 'The handling of the `Rangeable` property and the return statements are structured similarly.']",3408.2868099212646
rag,rag_top_k12,pos_chunk_00001,True,True,"The candidate snippet [1] has a very similar structure and logic to the query code, with only minor differences in variable names and formatting.","[{'chunk_id': 'chunk_00001', 'path': 'got\\chunk.go', 'text': 'func (dst *OffsetWriter) Write(b []byte) (n int, err error) {\n\tn, err = dst.WriteAt(b, dst.offset)\n\tdst.offset += int64(n)\n\treturn\n}\n\n// Chunk represents the partial content range\ntype Chunk struct {\n\tStart, End uint64\n}', 'similarity': 0.8895321894753399}]","['The function signature is almost identical: both define a method on a struct that takes a byte slice and returns an integer and an error.', 'The logic of calling `WriteAt` with the same parameters and updating the offset is the same in both snippets.', 'The `Chunk` struct definition is also present in both snippets, with the same fields.']",3637.7384662628174
