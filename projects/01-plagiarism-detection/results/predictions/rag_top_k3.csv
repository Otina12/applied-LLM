method,config_name,id,is_positive,is_plagiarized,reason,evidence_mine,evidence_oai,ms_elapsed
rag,rag_top_k3,neg_002,False,False,The candidate snippets do not share any structural or functional similarities with the query code. They serve different purposes and implement different functionalities.,[],[],1643.265724182129
rag,rag_top_k3,neg_005,False,False,"The candidate snippets do not share any structural or functional similarities with the query code. They implement different algorithms and have different purposes, control flows, and variable usages.",[],[],1423.7008094787598
rag,rag_top_k3,neg_013,False,False,The candidate snippets do not share structural or functional similarities with the query code. They implement different logic and algorithms unrelated to counting even numbers in a slice.,[],"['Candidate 1 is related to atomic operations and does not involve counting or iterating over a slice.', 'Candidate 2 implements an absolute value function, which is unrelated to the counting logic of the query.', 'Candidate 3 is focused on finding minimum rotations in a domino problem, which is a completely different algorithm.']",2118.7222003936768
rag,rag_top_k3,pos_chunk_00010,True,True,"The candidate snippet 2 is identical to the query code in structure, call order, and control flow, with only a comment added.","[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.8427877272758555}, {'chunk_id': 'chunk_00010', 'path': 'got\\download.go', 'text': 'func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.', 'similarity': 0.813157274634057}, {'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.76831317061961}]",['Candidate 2 is identical to the query code.'],1806.4723014831543
rag,rag_top_k3,neg_004,False,False,The candidate snippets do not share any structural or functional similarities with the query code.,[],"['Candidate 1 implements an absolute value function, which has a different purpose and structure than the factorial function.', 'Candidate 2 is an empty main function, which does not relate to the factorial calculation.', 'Candidate 3 defines a method for a struct, which is unrelated to the recursive factorial function.']",2786.3283157348633
rag,rag_top_k3,neg_001,False,False,The candidate snippets do not share structural similarities or control flow with the query code. They implement different functionalities and algorithms unrelated to summing a slice of integers.,[],"['Candidate 1 implements a dynamic programming solution for partitioning an array, which is unrelated to summing elements.', 'Candidate 2 calculates pairs of durations divisible by 60, which involves mapping and counting, not summing.', 'Candidate 3 defines a function to calculate the absolute value, which is a different operation altogether.']",3805.6960105895996
rag,rag_top_k3,pos_chunk_00011,True,True,"The candidate snippet [1] has a similar structure and control flow to the query code, with the same logic for calculating average speed and the same use of the `TotalCost` method and atomic operations.","[{'chunk_id': 'chunk_00011', 'path': 'got\\download.go', 'text': 'func (d *Download) AvgSpeed() uint64 {\n\n\tif totalMills := d.TotalCost().Milliseconds(); totalMills > 0 {\n\t\treturn uint64(atomic.LoadUint64(&d.size) / uint64(totalMills) * 1000)\n\t}\n\n\treturn 0\n}\n\n// TotalCost returns download duration.', 'similarity': 0.9327829612208552}, {'chunk_id': 'chunk_00010', 'path': 'got\\download.go', 'text': 'func (d *Download) Speed() uint64 {\n\treturn (atomic.LoadUint64(&d.size) - atomic.LoadUint64(&d.lastSize)) / d.Interval * 1000\n}\n\n// AvgSpeed returns average download speed.', 'similarity': 0.7829313366111307}]","['Both snippets define a method on the `Download` struct that calculates speed based on the size and total time.', 'Both snippets use `atomic.LoadUint64` to access the size variable.', 'The control flow is identical, checking if `totalMills` is greater than 0 before performing the calculation.']",2724.926710128784
rag,rag_top_k3,neg_010,False,False,The candidate snippets do not share structural or functional similarities with the query code. They serve different purposes and have different control flows.,[],[],1320.1987743377686
rag,rag_top_k3,pos_chunk_00008,True,True,"The candidate snippet [1] is identical to the query code, with only an additional comment added.","[{'chunk_id': 'chunk_00008', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalSize() uint64 {\n\treturn d.info.Size\n}\n\n// Size returns downloaded size.', 'similarity': 0.947433231668069}]",['Candidate snippet [1] is identical to the query code.'],1667.9704189300537
rag,rag_top_k3,pos_chunk_00014,True,True,"The candidate snippet [1] contains an exact copy of the query function, which indicates plagiarism.","[{'chunk_id': 'chunk_00014', 'path': 'got\\download.go', 'text': 'func (d *Download) IsRangeable() bool {\n\treturn d.info.Rangeable\n}\n\n// Download chunks', 'similarity': 0.884463238101745}]",['Candidate snippet [1] has the exact same function definition and body as the query code.'],1848.4258651733398
rag,rag_top_k3,pos_chunk_00003,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code, including the handling of HTTP requests, error checking, and response processing. The use of specific error messages and the overall flow of the function are nearly identical, indicating a high likelihood of plagiarism.","[{'chunk_id': 'chunk_00003', 'path': 'got\\download.go', 'text': 'func (d *Download) GetInfoOrDownload() (*Info, error) {\n\n\tvar (\n\t\terr  error\n\t\tdest *os.File\n\t\treq  *http.Request\n\t\tres  *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, append(d.Header, GotHeader{""Range"", ""bytes=0-0""})); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode >= 300 {\n\t\treturn &Info{}, fmt.Errorf(""Response status code is not ok: %d"", res.StatusCode)\n\t}\n\n\t// Set content disposition non trusted name\n\td.unsafeName = res.Header.Get(""content-disposition"")\n\n\tif dest, err = os.Create(d.Path()); err != nil {\n\t\treturn &Info{}, err\n\t}\n\tdefer dest.Close()\n\n\tif _, err = io.Copy(dest, io.TeeReader(res.Body, d)); err != nil {\n\t\treturn &Info{}, err\n\t}\n\n\t// Get content length from content-range response header,\n\t// if content-range exists, that means partial content is supported.\n\tif cr := res.Header.Get(""content-range""); cr != """" && res.ContentLength == 1 {\n\t\tl := strings.Split(cr, ""/"")\n\t\tif len(l) == 2 {\n\t\t\tif length, err := strconv.ParseUint(l[1], 10, 64); err == nil {\n\n\t\t\t\treturn &Info{\n\t\t\t\t\tSize:      length,\n\t\t\t\t\tRangeable: true,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t\t// Make sure the caller knows about the problem and we don\'t just silently fail\n\t\treturn &Info{}, fmt.Errorf(""Response includes content-range header which is invalid: %s"", cr)\n\t}\n\n\treturn &Info{}, nil\n}\n\n// Init set defaults and split file into chunks and gets Info,\n// you should call Init before Start', 'similarity': 0.7881016919471014}, {'chunk_id': 'chunk_00017', 'path': 'got\\download.go', 'text': 'func (d *Download) DownloadChunk(c *Chunk, dest io.Writer) error {\n\n\tvar (\n\t\terr error\n\t\treq *http.Request\n\t\tres *http.Response\n\t)\n\n\tif req, err = NewRequest(d.ctx, ""GET"", d.URL, d.Header); err != nil {\n\t\treturn err\n\t}\n\n\tcontentRange := fmt.Sprintf(""bytes=%d-%d"", c.Start, c.End)\n\treq.Header.Set(""Range"", contentRange)\n\n\tif res, err = d.Client.Do(req); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify the length\n\tif res.ContentLength != int64(c.End-c.Start+1) {\n\t\treturn fmt.Errorf(\n\t\t\t""Range request returned invalid Content-Length: %d however the range was: %s"",\n\t\t\tres.ContentLength, contentRange,\n\t\t)\n\t}\n\n\tdefer res.Body.Close()\n\n\t_, err = io.CopyN(dest, io.TeeReader(res.Body, d), res.ContentLength)\n\n\treturn err\n}\n\n// NewDownload returns new *Download with context.', 'similarity': 0.782558950682046}]","['The function signature and return types are identical.', 'The error handling and return statements are structured in the same way.', 'The logic for checking the response status code and handling the content-range header is almost verbatim.', 'The use of `defer` for closing resources is consistent in both snippets.']",3840.269088745117
rag,rag_top_k3,pos_chunk_00015,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. Both snippets implement a concurrent download of chunks using goroutines and a wait group, with the same error handling and channel usage.","[{'chunk_id': 'chunk_00015', 'path': 'got\\download.go', 'text': 'func (d *Download) dl(dest io.WriterAt, errC chan error) {\n\n\tvar (\n\t\t// Wait group.\n\t\twg sync.WaitGroup\n\n\t\t// Concurrency limit.\n\t\tmax = make(chan int, d.Concurrency)\n\t)\n\n\tfor i := 0; i < len(d.chunks); i++ {\n\n\t\tmax <- 1\n\t\twg.Add(1)\n\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Concurrently download and write chunk\n\t\t\tif err := d.DownloadChunk(d.chunks[i], &OffsetWriter{dest, int64(d.chunks[i].Start)}); err != nil {\n\t\t\t\terrC <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t<-max\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\terrC <- nil\n}\n\n// Return constant path which will not change once the download starts', 'similarity': 0.8800490653690556}]","['Both snippets define a method `dl` on the `Download` struct.', 'Both snippets use a `sync.WaitGroup` to manage concurrent downloads.', 'Both snippets use a buffered channel `max` to limit concurrency.', 'The error handling logic is identical, where errors are sent to the `errC` channel.', 'The loop structure for iterating over `d.chunks` is the same, with similar variable names and logic.']",4079.8919200897217
rag,rag_top_k3,neg_009,False,False,The candidate snippets implement different algorithms and do not share structural similarities with the query code.,[],[],1182.1179389953613
rag,rag_top_k3,neg_008,False,False,The candidate snippets do not share structural or functional similarities with the query code. They implement different functionalities unrelated to palindrome checking.,[],[],1577.9948234558105
rag,rag_top_k3,neg_007,False,False,"The candidate snippets do not contain any code that is structurally or functionally similar to the query code for counting vowels. They focus on different functionalities such as parsing expressions and tokenizing input, which are unrelated to vowel counting.",[],[],2400.0041484832764
rag,rag_top_k3,neg_014,False,False,"The candidate snippets do not share structural similarities, control flow, or logic with the query code. They implement different functionalities and do not resemble the Contains function in any meaningful way.",[],[],1719.7465896606445
rag,rag_top_k3,pos_chunk_00012,True,True,"The candidate snippet [1] is identical to the query code, indicating direct copying without modification.","[{'chunk_id': 'chunk_00012', 'path': 'got\\download.go', 'text': 'func (d *Download) TotalCost() time.Duration {\n\treturn time.Now().Sub(d.startedAt)\n}\n\n// Write updates progress size.', 'similarity': 0.847264926716214}]",['Candidate snippet [1] is identical to the query code.'],1366.5235042572021
rag,rag_top_k3,pos_chunk_00007,True,True,"The candidate snippet [3] is identical to the query code, including the function signature and body, indicating direct copying.",[],"['func (d *Download) Context() context.Context {', 'return d.ctx', '}']",1836.6949558258057
rag,rag_top_k3,neg_006,False,False,"The candidate snippets implement different algorithms and have distinct structures, control flows, and purposes compared to the query code.",[],"['Candidate 1 implements a dynamic programming solution for partitioning an array, which is unrelated to finding the maximum value in a slice.', 'Candidate 2 focuses on minimizing rotations in a domino problem, which has a completely different logic and structure.', 'Candidate 3 deals with finding the maximum difference between ancestor and descendant nodes in a binary tree, which is not related to the task of finding a maximum value in a slice.']",3068.0246353149414
rag,rag_top_k3,pos_chunk_00006,True,True,"The candidate snippet [1] closely resembles the query code in structure, control flow, and logic, with only minor variations in comments and formatting.","[{'chunk_id': 'chunk_00006', 'path': 'got\\download.go', 'text': 'func (d *Download) RunProgress(fn ProgressFunc) {\n\n\t// Set default interval.\n\tif d.Interval == 0 {\n\t\td.Interval = uint64(400 / runtime.NumCPU())\n\t}\n\n\tsleepd := time.Duration(d.Interval) * time.Millisecond\n\n\tfor {\n\n\t\tif d.StopProgress {\n\t\t\tbreak\n\t\t}\n\n\t\t// Context check.\n\t\tselect {\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Run progress func.\n\t\tfn(d)\n\n\t\t// Update last size\n\t\tatomic.StoreUint64(&d.lastSize, atomic.LoadUint64(&d.size))\n\n\t\t// Interval.\n\t\ttime.Sleep(sleepd)\n\t}\n}\n\n// Context returns download context.', 'similarity': 0.8737930358492714}]","['The overall structure of the loop and conditionals is identical.', 'The use of `select` for context checking is the same in both snippets.', 'The logic for updating `lastSize` and sleeping for the interval is preserved in the same order.']",2764.698028564453
rag,rag_top_k3,pos_chunk_00009,True,True,"The candidate snippet [1] is identical to the query code, indicating direct copying without modification.","[{'chunk_id': 'chunk_00009', 'path': 'got\\download.go', 'text': 'func (d *Download) Size() uint64 {\n\treturn atomic.LoadUint64(&d.size)\n}\n\n// Speed returns download speed.', 'similarity': 0.8433901530201564}]",['Candidate snippet [1] is exactly the same as the query code.'],1784.271240234375
rag,rag_top_k3,neg_011,False,False,"The candidate snippets do not contain any code that resembles the query function in structure, logic, or control flow. They serve different purposes and do not share any significant similarities.",[],[],1379.9314498901367
rag,rag_top_k3,pos_chunk_00005,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code, including the use of channels, error handling, and the overall flow of the download process.",[],"['Both snippets define a method `Start` for a `Download` struct.', 'Both snippets check if `d.info.Rangeable` is false and handle the context cancellation in a similar way.', 'Both snippets create a file using `os.Create` and handle errors in a similar manner.', 'Both snippets use a goroutine to call `d.dl(file, errs)` for downloading, and handle the errors from the channel in a similar select statement.']",3847.832679748535
rag,rag_top_k3,neg_015,False,False,"The candidate snippets do not share structural similarities or control flow with the query code. They implement different functionalities and algorithms, and there is no significant overlap in logic or design.",[],[],1772.0227241516113
rag,rag_top_k3,neg_012,False,False,"The candidate snippets do not share structural similarities, control flow, or logic with the query function. They serve different purposes and have distinct implementations.",[],[],1275.3386497497559
rag,rag_top_k3,pos_chunk_00002,True,True,"The candidate snippet [1] has a very similar structure, control flow, and logic to the query code. It contains the same variable names, error handling, and the same sequence of checks and assertions, indicating a high level of similarity and potential plagiarism.","[{'chunk_id': 'chunk_00002', 'path': 'got\\chunks_test.go', 'text': 'func TestChunksLength(t *testing.T) {\n\n\td := &Download{\n\t\tURL:          ""https://proof.ovh.net/files/10Mb.dat"",\n\t\tMinChunkSize: 5242870,\n\t}\n\n\tif err := d.Init(); err != nil {\n\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tchunk0 := Chunk{\n\t\tStart: 0,\n\t\tEnd:   5242870,\n\t}\n\n\t// Last chunk should not have end,\n\t// So the server must respond with the remaining content starting form 5242871\n\tchunk1 := Chunk{\n\t\tStart: 5242871,\n\t\tEnd:   10485759,\n\t}\n\n\tif d.info.Rangeable == false {\n\t\tt.Errorf(""Chunk information could not be retrieved for the test file: %s"", d.URL)\n\t\treturn\n\t}\n\n\tif d.chunks[0].Start != 0 {\n\n\t\tt.Errorf(""First chunk should start from 0, but got %d"", d.chunks[0].Start)\n\t}\n\n\tif chunk0.End != d.chunks[0].End {\n\n\t\tt.Errorf(""Chunk 0 expecting: %d but got: %d"", chunk0.End, d.chunks[0].End)\n\t}\n\n\tif d.chunks[1].Start != 5242871 {\n\n\t\tt.Errorf(""Second chunk should start from: 5242871, but got %d"", d.chunks[1].Start)\n\t}\n\n\tif chunk1.End != d.chunks[1].End {\n\n\t\tt.Errorf(""Chunk 1 expecting: %d but got: %d"", chunk1.End, d.chunks[1].End)\n\t}\n}', 'similarity': 0.7723971455972203}]","[""Both snippets define a function named 'TestChunksLength' with the same signature."", ""Both snippets create a 'Download' struct with the same URL and MinChunkSize."", ""Both snippets check for errors after calling 'd.Init()' and handle them in the same way."", ""Both snippets define two chunks, 'chunk0' and 'chunk1', with the same start and end values."", ""Both snippets contain similar conditional checks for the 'Rangeable' property and the expected values of chunk starts and ends.""]",3394.7157859802246
rag,rag_top_k3,pos_chunk_00013,True,True,"The candidate snippet [1] has a very similar structure and logic to the query code, with only minor changes in variable names and formatting.",[],"['Both functions are methods of a struct that handle writing byte slices.', 'Both use atomic operations to update a size variable.', 'The return values and their order are identical.']",1572.4053382873535
rag,rag_top_k3,neg_003,False,False,"The candidate snippets do not share structural similarities, control flow, or logic with the query code. They implement different functionalities and algorithms.",[],[],1457.9713344573975
rag,rag_top_k3,pos_chunk_00004,True,True,"The candidate snippet closely follows the structure, control flow, and logic of the query code, with only minor changes in variable names and comments. The overall approach to initializing the download process, handling errors, and setting up chunks is nearly identical, indicating a high degree of similarity.","[{'chunk_id': 'chunk_00004', 'path': 'got\\download.go', 'text': 'func (d *Download) Init() (err error) {\n\n\t// Set start time.\n\td.startedAt = time.Now()\n\n\t// Set default client.\n\tif d.Client == nil {\n\t\td.Client = DefaultClient\n\t}\n\n\t// Set default context.\n\tif d.ctx == nil {\n\t\td.ctx = context.Background()\n\t}\n\n\t// Get URL info and partial content support state\n\tif d.info, err = d.GetInfoOrDownload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Partial content not supported, and the file downladed.\n\tif d.info.Rangeable == false {\n\t\treturn nil\n\t}\n\n\t// Set concurrency default.\n\tif d.Concurrency == 0 {\n\t\td.Concurrency = getDefaultConcurrency()\n\t}\n\n\t// Set default chunk size\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = getDefaultChunkSize(d.info.Size, d.MinChunkSize, d.MaxChunkSize, uint64(d.Concurrency))\n\t}\n\n\tchunksLen := d.info.Size / d.ChunkSize\n\td.chunks = make([]*Chunk, 0, chunksLen)\n\n\t// Set chunk ranges.\n\tfor i := uint64(0); i < chunksLen; i++ {\n\n\t\tchunk := new(Chunk)\n\t\td.chunks = append(d.chunks, chunk)\n\n\t\tchunk.Start = (d.ChunkSize * i) + i\n\t\tchunk.End = chunk.Start + d.ChunkSize\n\t\tif chunk.End >= d.info.Size || i == chunksLen-1 {\n\t\t\tchunk.End = d.info.Size - 1\n\t\t\t// Break on last chunk if i < chunksLen\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start downloads the file chunks, and merges them.\n// Must be called only after init', 'similarity': 0.787616168602992}]","['Both snippets define a method `Init` for the `Download` struct.', 'Both snippets check if `d.Client` is nil and set it to `DefaultClient` if so.', 'Both snippets check if `d.ctx` is nil and set it to `context.Background()` if so.', 'Both snippets retrieve information using `d.GetInfoOrDownload()` and handle errors in a similar manner.', 'Both snippets check if `d.info.Rangeable` is false and return early if so.', 'Both snippets calculate `chunksLen` based on `d.info.Size` and `d.ChunkSize` and initialize `d.chunks` accordingly.', 'Both snippets use a loop to create and append chunks, setting their `Start` and `End` properties in a similar way.']",5340.993404388428
rag,rag_top_k3,pos_chunk_00001,True,True,"The candidate snippet [1] has a very similar structure and logic to the query code, including the same method signature, variable names, and control flow.","[{'chunk_id': 'chunk_00001', 'path': 'got\\chunk.go', 'text': 'func (dst *OffsetWriter) Write(b []byte) (n int, err error) {\n\tn, err = dst.WriteAt(b, dst.offset)\n\tdst.offset += int64(n)\n\treturn\n}\n\n// Chunk represents the partial content range\ntype Chunk struct {\n\tStart, End uint64\n}', 'similarity': 0.8895321894753399}]","['Both snippets define a method for writing bytes with a similar signature: `func (dst *OffsetWriter) Write(b []byte) (count int, e error)` vs `func (dst *OffsetWriter) Write(b []byte) (n int, err error)`.', 'Both snippets call a method `WriteAt` with the same parameters and update the `offset` in a similar manner.', 'The structure of the `Chunk` type is identical in both snippets, with the same fields `Start` and `End` defined in the same order.']",3664.722442626953
